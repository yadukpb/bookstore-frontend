{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Timeout = exports.TimeoutError = void 0;\nconst timers_1 = require(\"timers\");\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\n/** @internal */\nclass TimeoutError extends Error {\n  get name() {\n    return 'TimeoutError';\n  }\n  constructor(message, options) {\n    super(message, options);\n  }\n  static is(error) {\n    return error != null && typeof error === 'object' && 'name' in error && error.name === 'TimeoutError';\n  }\n}\nexports.TimeoutError = TimeoutError;\n/**\n * @internal\n * This class is an abstraction over timeouts\n * The Timeout class can only be in the pending or rejected states. It is guaranteed not to resolve\n * if interacted with exclusively through its public API\n * */\nclass Timeout extends Promise {\n  get [Symbol.toStringTag]() {\n    return 'MongoDBTimeout';\n  }\n  /** Create a new timeout that expires in `duration` ms */\n  constructor() {\n    let executor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => null;\n    let duration = arguments.length > 1 ? arguments[1] : undefined;\n    let unref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let reject;\n    if (duration < 0) {\n      throw new error_1.MongoInvalidArgumentError('Cannot create a Timeout with a negative duration');\n    }\n    super((_, promiseReject) => {\n      reject = promiseReject;\n      executor(utils_1.noop, promiseReject);\n    });\n    this.ended = null;\n    this.timedOut = false;\n    this.duration = duration;\n    this.start = Math.trunc(performance.now());\n    if (this.duration > 0) {\n      this.id = (0, timers_1.setTimeout)(() => {\n        this.ended = Math.trunc(performance.now());\n        this.timedOut = true;\n        reject(new TimeoutError(`Expired after ${duration}ms`));\n      }, this.duration);\n      if (typeof this.id.unref === 'function' && unref) {\n        // Ensure we do not keep the Node.js event loop running\n        this.id.unref();\n      }\n    }\n  }\n  /**\n   * Clears the underlying timeout. This method is idempotent\n   */\n  clear() {\n    (0, timers_1.clearTimeout)(this.id);\n    this.id = undefined;\n  }\n  static expires(durationMS, unref) {\n    return new Timeout(undefined, durationMS, unref);\n  }\n  static is(timeout) {\n    return typeof timeout === 'object' && timeout != null && Symbol.toStringTag in timeout && timeout[Symbol.toStringTag] === 'MongoDBTimeout' && 'then' in timeout && typeof timeout.then === 'function';\n  }\n}\nexports.Timeout = Timeout;","map":{"version":3,"mappings":";;;;;;AAAA;AAEA;AACA;AAEA;AACA,MAAaA,YAAa,SAAQC,KAAK;EACrC,IAAaC,IAAI;IACf,OAAO,cAAc;EACvB;EAEAC,YAAYC,OAAe,EAAEC,OAA2B;IACtD,KAAK,CAACD,OAAO,EAAEC,OAAO,CAAC;EACzB;EAEA,OAAOC,EAAE,CAACC,KAAc;IACtB,OACEA,KAAK,IAAI,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,MAAM,IAAIA,KAAK,IAAIA,KAAK,CAACL,IAAI,KAAK,cAAc;EAElG;;AAbFM;AAkBA;;;;;;AAMA,MAAaC,OAAQ,SAAQC,OAAc;EACzC,KAAKC,MAAM,CAACC,WAAW,IAAC;IACtB,OAAO,gBAAgB;EACzB;EASA;EACAT,cAAoF;IAAA,IAAhEU,+EAAqB,MAAM,IAAI;IAAA,IAAEC,QAAgB;IAAA,IAAEC,KAAK,uEAAG,KAAK;IAClF,IAAIC,MAAe;IAEnB,IAAIF,QAAQ,GAAG,CAAC,EAAE;MAChB,MAAM,IAAIG,iCAAyB,CAAC,kDAAkD,CAAC;IACzF;IAEA,KAAK,CAAC,CAACC,CAAC,EAAEC,aAAa,KAAI;MACzBH,MAAM,GAAGG,aAAa;MAEtBN,QAAQ,CAACO,YAAI,EAAED,aAAa,CAAC;IAC/B,CAAC,CAAC;IAhBG,UAAK,GAAkB,IAAI;IAE3B,aAAQ,GAAG,KAAK;IAgBrB,IAAI,CAACL,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACO,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACC,WAAW,CAACC,GAAG,EAAE,CAAC;IAE1C,IAAI,IAAI,CAACX,QAAQ,GAAG,CAAC,EAAE;MACrB,IAAI,CAACY,EAAE,GAAG,uBAAU,EAAC,MAAK;QACxB,IAAI,CAACC,KAAK,GAAGL,IAAI,CAACC,KAAK,CAACC,WAAW,CAACC,GAAG,EAAE,CAAC;QAC1C,IAAI,CAACG,QAAQ,GAAG,IAAI;QACpBZ,MAAM,CAAC,IAAIhB,YAAY,CAAC,iBAAiBc,QAAQ,IAAI,CAAC,CAAC;MACzD,CAAC,EAAE,IAAI,CAACA,QAAQ,CAAC;MACjB,IAAI,OAAO,IAAI,CAACY,EAAE,CAACX,KAAK,KAAK,UAAU,IAAIA,KAAK,EAAE;QAChD;QACA,IAAI,CAACW,EAAE,CAACX,KAAK,EAAE;MACjB;IACF;EACF;EAEA;;;EAGAc,KAAK;IACH,yBAAY,EAAC,IAAI,CAACH,EAAE,CAAC;IACrB,IAAI,CAACA,EAAE,GAAGI,SAAS;EACrB;EAEO,OAAOC,OAAO,CAACC,UAAkB,EAAEjB,KAAe;IACvD,OAAO,IAAIN,OAAO,CAACqB,SAAS,EAAEE,UAAU,EAAEjB,KAAK,CAAC;EAClD;EAEA,OAAOT,EAAE,CAAC2B,OAAgB;IACxB,OACE,OAAOA,OAAO,KAAK,QAAQ,IAC3BA,OAAO,IAAI,IAAI,IACftB,MAAM,CAACC,WAAW,IAAIqB,OAAO,IAC7BA,OAAO,CAACtB,MAAM,CAACC,WAAW,CAAC,KAAK,gBAAgB,IAChD,MAAM,IAAIqB,OAAO,IACjB,OAAOA,OAAO,CAACC,IAAI,KAAK,UAAU;EAEtC;;AA/DF1B","names":["TimeoutError","Error","name","constructor","message","options","is","error","exports","Timeout","Promise","Symbol","toStringTag","executor","duration","unref","reject","error_1","_","promiseReject","utils_1","start","Math","trunc","performance","now","id","ended","timedOut","clear","undefined","expires","durationMS","timeout","then"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/timeout.ts"],"sourcesContent":["import { clearTimeout, setTimeout } from 'timers';\n\nimport { MongoInvalidArgumentError } from './error';\nimport { noop } from './utils';\n\n/** @internal */\nexport class TimeoutError extends Error {\n  override get name(): 'TimeoutError' {\n    return 'TimeoutError';\n  }\n\n  constructor(message: string, options?: { cause?: Error }) {\n    super(message, options);\n  }\n\n  static is(error: unknown): error is TimeoutError {\n    return (\n      error != null && typeof error === 'object' && 'name' in error && error.name === 'TimeoutError'\n    );\n  }\n}\n\ntype Executor = ConstructorParameters<typeof Promise<never>>[0];\ntype Reject = Parameters<ConstructorParameters<typeof Promise<never>>[0]>[1];\n/**\n * @internal\n * This class is an abstraction over timeouts\n * The Timeout class can only be in the pending or rejected states. It is guaranteed not to resolve\n * if interacted with exclusively through its public API\n * */\nexport class Timeout extends Promise<never> {\n  get [Symbol.toStringTag](): 'MongoDBTimeout' {\n    return 'MongoDBTimeout';\n  }\n\n  private id?: NodeJS.Timeout;\n\n  public readonly start: number;\n  public ended: number | null = null;\n  public duration: number;\n  public timedOut = false;\n\n  /** Create a new timeout that expires in `duration` ms */\n  private constructor(executor: Executor = () => null, duration: number, unref = false) {\n    let reject!: Reject;\n\n    if (duration < 0) {\n      throw new MongoInvalidArgumentError('Cannot create a Timeout with a negative duration');\n    }\n\n    super((_, promiseReject) => {\n      reject = promiseReject;\n\n      executor(noop, promiseReject);\n    });\n\n    this.duration = duration;\n    this.start = Math.trunc(performance.now());\n\n    if (this.duration > 0) {\n      this.id = setTimeout(() => {\n        this.ended = Math.trunc(performance.now());\n        this.timedOut = true;\n        reject(new TimeoutError(`Expired after ${duration}ms`));\n      }, this.duration);\n      if (typeof this.id.unref === 'function' && unref) {\n        // Ensure we do not keep the Node.js event loop running\n        this.id.unref();\n      }\n    }\n  }\n\n  /**\n   * Clears the underlying timeout. This method is idempotent\n   */\n  clear(): void {\n    clearTimeout(this.id);\n    this.id = undefined;\n  }\n\n  public static expires(durationMS: number, unref?: boolean): Timeout {\n    return new Timeout(undefined, durationMS, unref);\n  }\n\n  static is(timeout: unknown): timeout is Timeout {\n    return (\n      typeof timeout === 'object' &&\n      timeout != null &&\n      Symbol.toStringTag in timeout &&\n      timeout[Symbol.toStringTag] === 'MongoDBTimeout' &&\n      'then' in timeout &&\n      typeof timeout.then === 'function'\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}