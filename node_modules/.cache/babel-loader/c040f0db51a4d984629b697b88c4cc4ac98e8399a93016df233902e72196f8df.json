{"ast":null,"code":"/*! firebase-admin v12.7.0 */\n\"use strict\";\n\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2SessionHandler = exports.ExponentialBackoffPoller = exports.ApiSettings = exports.AuthorizedHttp2Client = exports.AuthorizedHttpClient = exports.parseHttpResponse = exports.Http2Client = exports.HttpClient = exports.RequestClient = exports.defaultRetryConfig = exports.RequestResponseError = void 0;\nconst error_1 = require(\"./error\");\nconst validator = require(\"./validator\");\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst http2 = require(\"http2\");\nconst url = require(\"url\");\nconst events_1 = require(\"events\");\nclass DefaultRequestResponse {\n  /**\n   * Constructs a new `RequestResponse` from the given `LowLevelResponse`.\n   */\n  constructor(resp) {\n    this.status = resp.status;\n    this.headers = resp.headers;\n    this.text = resp.data;\n    try {\n      if (!resp.data) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'HTTP response missing data.');\n      }\n      this.parsedData = JSON.parse(resp.data);\n    } catch (err) {\n      this.parsedData = undefined;\n      this.parseError = err;\n    }\n    this.request = `${resp.config.method} ${resp.config.url}`;\n  }\n  get data() {\n    if (this.isJson()) {\n      return this.parsedData;\n    }\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, `Error while parsing response data: \"${this.parseError.toString()}\". Raw server ` + `response: \"${this.text}\". Status code: \"${this.status}\". Outgoing ` + `request: \"${this.request}.\"`);\n  }\n  isJson() {\n    return typeof this.parsedData !== 'undefined';\n  }\n}\n/**\n * Represents a multipart HTTP or HTTP/2 response. Parts that constitute the response body can be accessed\n * via the multipart getter. Getters for text and data throw errors.\n */\nclass MultipartRequestResponse {\n  constructor(resp) {\n    this.status = resp.status;\n    this.headers = resp.headers;\n    this.multipart = resp.multipart;\n  }\n  get text() {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, 'Unable to parse multipart payload as text');\n  }\n  get data() {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, 'Unable to parse multipart payload as JSON');\n  }\n  isJson() {\n    return false;\n  }\n}\nclass RequestResponseError extends Error {\n  constructor(response) {\n    super(`Server responded with status ${response.status}.`);\n    this.response = response;\n    // Set the prototype so that instanceof checks will work correctly.\n    // See: https://github.com/Microsoft/TypeScript/issues/13965\n    Object.setPrototypeOf(this, RequestResponseError.prototype);\n  }\n}\nexports.RequestResponseError = RequestResponseError;\n/**\n * Default retry configuration for HTTP and HTTP/2 requests. Retries up to 4 times on connection reset and timeout\n * errors as well as 503 errors. Exposed as a function to ensure that every `RequestClient` gets its own `RetryConfig`\n * instance.\n */\nfunction defaultRetryConfig() {\n  return {\n    maxRetries: 4,\n    statusCodes: [503],\n    ioErrorCodes: ['ECONNRESET', 'ETIMEDOUT'],\n    backOffFactor: 0.5,\n    maxDelayInMillis: 60 * 1000\n  };\n}\nexports.defaultRetryConfig = defaultRetryConfig;\n/**\n * Ensures that the given `RetryConfig` object is valid.\n *\n * @param retry - The configuration to be validated.\n */\nfunction validateRetryConfig(retry) {\n  if (!validator.isNumber(retry.maxRetries) || retry.maxRetries < 0) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'maxRetries must be a non-negative integer');\n  }\n  if (typeof retry.backOffFactor !== 'undefined') {\n    if (!validator.isNumber(retry.backOffFactor) || retry.backOffFactor < 0) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'backOffFactor must be a non-negative number');\n    }\n  }\n  if (!validator.isNumber(retry.maxDelayInMillis) || retry.maxDelayInMillis < 0) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'maxDelayInMillis must be a non-negative integer');\n  }\n  if (typeof retry.statusCodes !== 'undefined' && !validator.isArray(retry.statusCodes)) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'statusCodes must be an array');\n  }\n  if (typeof retry.ioErrorCodes !== 'undefined' && !validator.isArray(retry.ioErrorCodes)) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'ioErrorCodes must be an array');\n  }\n}\nclass RequestClient {\n  constructor() {\n    let retry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultRetryConfig();\n    if (retry) {\n      this.retry = retry;\n      validateRetryConfig(this.retry);\n    }\n  }\n  createRequestResponse(resp) {\n    if (resp.multipart) {\n      return new MultipartRequestResponse(resp);\n    }\n    return new DefaultRequestResponse(resp);\n  }\n  waitForRetry(delayMillis) {\n    if (delayMillis > 0) {\n      return new Promise(resolve => {\n        setTimeout(resolve, delayMillis);\n      });\n    }\n    return Promise.resolve();\n  }\n  /**\n   * Checks if a failed request is eligible for a retry, and if so returns the duration to wait before initiating\n   * the retry.\n   *\n   * @param retryAttempts - Number of retries completed up to now.\n   * @param err - The last encountered error.\n   * @returns A 2-tuple where the 1st element is the duration to wait before another retry, and the\n   *     2nd element is a boolean indicating whether the request is eligible for a retry or not.\n   */\n  getRetryDelayMillis(retryAttempts, err) {\n    if (!this.isRetryEligible(retryAttempts, err)) {\n      return [0, false];\n    }\n    const response = err.response;\n    if (response && response.headers['retry-after']) {\n      const delayMillis = this.parseRetryAfterIntoMillis(response.headers['retry-after']);\n      if (delayMillis > 0) {\n        return [delayMillis, true];\n      }\n    }\n    return [this.backOffDelayMillis(retryAttempts), true];\n  }\n  isRetryEligible(retryAttempts, err) {\n    if (!this.retry) {\n      return false;\n    }\n    if (retryAttempts >= this.retry.maxRetries) {\n      return false;\n    }\n    if (err.response) {\n      const statusCodes = this.retry.statusCodes || [];\n      return statusCodes.indexOf(err.response.status) !== -1;\n    }\n    if (err.code) {\n      const retryCodes = this.retry.ioErrorCodes || [];\n      return retryCodes.indexOf(err.code) !== -1;\n    }\n    return false;\n  }\n  /**???\n   * Parses the Retry-After header as a milliseconds value. Return value is negative if the Retry-After header\n   * contains an expired timestamp or otherwise malformed.\n   */\n  parseRetryAfterIntoMillis(retryAfter) {\n    const delaySeconds = parseInt(retryAfter, 10);\n    if (!isNaN(delaySeconds)) {\n      return delaySeconds * 1000;\n    }\n    const date = new Date(retryAfter);\n    if (!isNaN(date.getTime())) {\n      return date.getTime() - Date.now();\n    }\n    return -1;\n  }\n  backOffDelayMillis(retryAttempts) {\n    if (retryAttempts === 0) {\n      return 0;\n    }\n    if (!this.retry) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected this.retry to exist.');\n    }\n    const backOffFactor = this.retry.backOffFactor || 0;\n    const delayInSeconds = 2 ** retryAttempts * backOffFactor;\n    return Math.min(delayInSeconds * 1000, this.retry.maxDelayInMillis);\n  }\n}\nexports.RequestClient = RequestClient;\nclass HttpClient extends RequestClient {\n  constructor(retry) {\n    super(retry);\n  }\n  /**\n   * Sends an HTTP request to a remote server. If the server responds with a successful response (2xx), the returned\n   * promise resolves with an `RequestResponse`. If the server responds with an error (3xx, 4xx, 5xx), the promise\n   * rejects with an `RequestResponseError`. In case of all other errors, the promise rejects with a `FirebaseAppError`.\n   * If a request fails due to a low-level network error, the client transparently retries the request once before\n   * rejecting the promise.\n   *\n   * If the request data is specified as an object, it will be serialized into a JSON string. The application/json\n   * content-type header will also be automatically set in this case. For all other payload types, the content-type\n   * header should be explicitly set by the caller. To send a JSON leaf value (e.g. \"foo\", 5), parse it into JSON,\n   * and pass as a string or a Buffer along with the appropriate content-type header.\n   *\n   * @param config - HTTP request to be sent.\n   * @returns A promise that resolves with the response details.\n   */\n  send(config) {\n    return this.sendWithRetry(config);\n  }\n  /**\n   * Sends an HTTP request. In the event of an error, retries the HTTP request according to the\n   * `RetryConfig` set on the `HttpClient`.\n   *\n   * @param config - HTTP request to be sent.\n   * @param retryAttempts - Number of retries performed up to now.\n   * @returns A promise that resolves with the response details.\n   */\n  sendWithRetry(config) {\n    let retryAttempts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return AsyncHttpCall.invoke(config).then(resp => {\n      return this.createRequestResponse(resp);\n    }).catch(err => {\n      const [delayMillis, canRetry] = this.getRetryDelayMillis(retryAttempts, err);\n      if (canRetry && this.retry && delayMillis <= this.retry.maxDelayInMillis) {\n        return this.waitForRetry(delayMillis).then(() => {\n          return this.sendWithRetry(config, retryAttempts + 1);\n        });\n      }\n      if (err.response) {\n        throw new RequestResponseError(this.createRequestResponse(err.response));\n      }\n      if (err.code === 'ETIMEDOUT') {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_TIMEOUT, `Error while making request: ${err.message}.`);\n      }\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making request: ${err.message}. Error code: ${err.code}`);\n    });\n  }\n}\nexports.HttpClient = HttpClient;\nclass Http2Client extends RequestClient {\n  constructor() {\n    let retry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultRetryConfig();\n    super(retry);\n  }\n  /**\n   * Sends an HTTP/2 request to a remote server. If the server responds with a successful response (2xx), the returned\n   * promise resolves with an `RequestResponse`. If the server responds with an error (3xx, 4xx, 5xx), the promise\n   * rejects with an `RequestResponseError`. In case of all other errors, the promise rejects with a `FirebaseAppError`.\n   * If a request fails due to a low-level network error, the client transparently retries the request once before\n   * rejecting the promise.\n   *\n   * If the request data is specified as an object, it will be serialized into a JSON string. The application/json\n   * content-type header will also be automatically set in this case. For all other payload types, the content-type\n   * header should be explicitly set by the caller. To send a JSON leaf value (e.g. \"foo\", 5), parse it into JSON,\n   * and pass as a string or a Buffer along with the appropriate content-type header.\n   *\n   * @param config - HTTP/2 request to be sent.\n   * @returns A promise that resolves with the response details.\n   */\n  send(config) {\n    return this.sendWithRetry(config);\n  }\n  /**\n   * Sends an HTTP/2 request. In the event of an error, retries the HTTP/2 request according to the\n   * `RetryConfig` set on the `Http2Client`.\n   *\n   * @param config - HTTP/2 request to be sent.\n   * @param retryAttempts - Number of retries performed up to now.\n   * @returns A promise that resolves with the response details.\n   */\n  sendWithRetry(config) {\n    let retryAttempts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return AsyncHttp2Call.invoke(config).then(resp => {\n      return this.createRequestResponse(resp);\n    }).catch(err => {\n      const [delayMillis, canRetry] = this.getRetryDelayMillis(retryAttempts, err);\n      if (canRetry && this.retry && delayMillis <= this.retry.maxDelayInMillis) {\n        return this.waitForRetry(delayMillis).then(() => {\n          return this.sendWithRetry(config, retryAttempts + 1);\n        });\n      }\n      if (err.response) {\n        throw new RequestResponseError(this.createRequestResponse(err.response));\n      }\n      if (err.code === 'ETIMEDOUT') {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_TIMEOUT, `Error while making request: ${err.message}.`);\n      }\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making request: ${err.message}. Error code: ${err.code}`);\n    });\n  }\n}\nexports.Http2Client = Http2Client;\n/**\n * Parses a full HTTP or HTTP/2 response message containing both a header and a body.\n *\n * @param response - The HTTP or HTTP/2 response to be parsed.\n * @param config - The request configuration that resulted in the HTTP or HTTP/2 response.\n * @returns An object containing the response's parsed status, headers and the body.\n */\nfunction parseHttpResponse(response, config) {\n  const responseText = validator.isBuffer(response) ? response.toString('utf-8') : response;\n  const endOfHeaderPos = responseText.indexOf('\\r\\n\\r\\n');\n  const headerLines = responseText.substring(0, endOfHeaderPos).split('\\r\\n');\n  const statusLine = headerLines[0];\n  const status = statusLine.trim().split(/\\s/)[1];\n  const headers = {};\n  headerLines.slice(1).forEach(line => {\n    const colonPos = line.indexOf(':');\n    const name = line.substring(0, colonPos).trim().toLowerCase();\n    const value = line.substring(colonPos + 1).trim();\n    headers[name] = value;\n  });\n  let data = responseText.substring(endOfHeaderPos + 4);\n  if (data.endsWith('\\n')) {\n    data = data.slice(0, -1);\n  }\n  if (data.endsWith('\\r')) {\n    data = data.slice(0, -1);\n  }\n  const lowLevelResponse = {\n    status: parseInt(status, 10),\n    headers,\n    data,\n    config,\n    request: null\n  };\n  if (!validator.isNumber(lowLevelResponse.status)) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Malformed HTTP status line.');\n  }\n  return new DefaultRequestResponse(lowLevelResponse);\n}\nexports.parseHttpResponse = parseHttpResponse;\n/**\n * A helper class for common functionality needed to send requests over the wire.\n * It also wraps the callback API of the Node.js standard library in a more flexible Promise API.\n */\nclass AsyncRequestCall {\n  constructor(configImpl) {\n    this.configImpl = configImpl;\n  }\n  /**\n   * Extracts multipart boundary from the HTTP header. The content-type header of a multipart\n   * response has the form 'multipart/subtype; boundary=string'.\n   *\n   * If the content-type header does not exist, or does not start with\n   * 'multipart/', then null will be returned.\n   */\n  getMultipartBoundary(headers) {\n    const contentType = headers['content-type'];\n    if (!contentType || !contentType.startsWith('multipart/')) {\n      return null;\n    }\n    const segments = contentType.split(';');\n    const emptyObject = {};\n    const headerParams = segments.slice(1).map(segment => segment.trim().split('=')).reduce((curr, params) => {\n      // Parse key=value pairs in the content-type header into properties of an object.\n      if (params.length === 2) {\n        const keyValuePair = {};\n        keyValuePair[params[0]] = params[1];\n        return Object.assign(curr, keyValuePair);\n      }\n      return curr;\n    }, emptyObject);\n    return headerParams.boundary;\n  }\n  handleMultipartResponse(response, respStream, boundary) {\n    const busboy = require('@fastify/busboy'); // eslint-disable-line @typescript-eslint/no-var-requires\n    const multipartParser = new busboy.Dicer({\n      boundary\n    });\n    const responseBuffer = [];\n    multipartParser.on('part', part => {\n      const tempBuffers = [];\n      part.on('data', partData => {\n        tempBuffers.push(partData);\n      });\n      part.on('end', () => {\n        responseBuffer.push(Buffer.concat(tempBuffers));\n      });\n    });\n    multipartParser.on('finish', () => {\n      response.data = undefined;\n      response.multipart = responseBuffer;\n      this.finalizeResponse(response);\n    });\n    respStream.pipe(multipartParser);\n  }\n  handleRegularResponse(response, respStream) {\n    const responseBuffer = [];\n    respStream.on('data', chunk => {\n      responseBuffer.push(chunk);\n    });\n    respStream.on('error', err => {\n      const req = response.request;\n      if (req && req.destroyed) {\n        return;\n      }\n      this.enhanceAndReject(err, null, req);\n    });\n    respStream.on('end', () => {\n      response.data = Buffer.concat(responseBuffer).toString();\n      this.finalizeResponse(response);\n    });\n  }\n  /**\n   * Finalizes the current request call in-flight by either resolving or rejecting the associated\n   * promise. In the event of an error, adds additional useful information to the returned error.\n   */\n  finalizeResponse(response) {\n    if (response.status >= 200 && response.status < 300) {\n      this.resolve(response);\n    } else {\n      this.rejectWithError('Request failed with status code ' + response.status, null, response.request, response);\n    }\n  }\n  /**\n   * Creates a new error from the given message, and enhances it with other information available.\n   * Then the promise associated with this request call is rejected with the resulting error.\n   */\n  rejectWithError(message, code, request, response) {\n    const error = new Error(message);\n    this.enhanceAndReject(error, code, request, response);\n  }\n  enhanceAndReject(error, code, request, response) {\n    this.reject(this.enhanceError(error, code, request, response));\n  }\n  /**\n   * Enhances the given error by adding more information to it. Specifically, the request config,\n   * the underlying request and response will be attached to the error.\n   */\n  enhanceError(error, code, request, response) {\n    error.config = this.configImpl;\n    if (code) {\n      error.code = code;\n    }\n    error.request = request;\n    error.response = response;\n    return error;\n  }\n}\n/**\n * A helper class for sending HTTP requests over the wire. This is a wrapper around the standard\n * http and https packages of Node.js, providing content processing, timeouts and error handling.\n * It also wraps the callback API of the Node.js standard library in a more flexible Promise API.\n */\nclass AsyncHttpCall extends AsyncRequestCall {\n  /**\n   * Sends an HTTP request based on the provided configuration.\n   */\n  static invoke(config) {\n    return new AsyncHttpCall(config).promise;\n  }\n  constructor(config) {\n    const httpConfigImpl = new HttpRequestConfigImpl(config);\n    super(httpConfigImpl);\n    try {\n      this.httpConfigImpl = httpConfigImpl;\n      this.options = this.httpConfigImpl.buildRequestOptions();\n      this.entity = this.httpConfigImpl.buildEntity(this.options.headers);\n      this.promise = new Promise((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n        this.execute();\n      });\n    } catch (err) {\n      this.promise = Promise.reject(this.enhanceError(err, null));\n    }\n  }\n  execute() {\n    const transport = this.options.protocol === 'https:' ? https : http;\n    const req = transport.request(this.options, res => {\n      this.handleResponse(res, req);\n    });\n    // Handle errors\n    req.on('error', err => {\n      if (req.aborted) {\n        return;\n      }\n      this.enhanceAndReject(err, null, req);\n    });\n    const timeout = this.httpConfigImpl.timeout;\n    const timeoutCallback = () => {\n      req.destroy();\n      this.rejectWithError(`timeout of ${timeout}ms exceeded`, 'ETIMEDOUT', req);\n    };\n    if (timeout) {\n      // Listen to timeouts and throw an error.\n      req.setTimeout(timeout, timeoutCallback);\n    }\n    // Send the request\n    req.end(this.entity);\n  }\n  handleResponse(res, req) {\n    if (req.aborted) {\n      return;\n    }\n    if (!res.statusCode) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected a statusCode on the response from a ClientRequest');\n    }\n    const response = {\n      status: res.statusCode,\n      headers: res.headers,\n      request: req,\n      data: undefined,\n      config: this.httpConfigImpl\n    };\n    const boundary = this.getMultipartBoundary(res.headers);\n    const respStream = this.uncompressResponse(res);\n    if (boundary) {\n      this.handleMultipartResponse(response, respStream, boundary);\n    } else {\n      this.handleRegularResponse(response, respStream);\n    }\n  }\n  uncompressResponse(res) {\n    // Uncompress the response body transparently if required.\n    let respStream = res;\n    const encodings = ['gzip', 'compress', 'deflate'];\n    if (res.headers['content-encoding'] && encodings.indexOf(res.headers['content-encoding']) !== -1) {\n      // Add the unzipper to the body stream processing pipeline.\n      const zlib = require('zlib'); // eslint-disable-line @typescript-eslint/no-var-requires\n      respStream = respStream.pipe(zlib.createUnzip());\n      // Remove the content-encoding in order to not confuse downstream operations.\n      delete res.headers['content-encoding'];\n    }\n    return respStream;\n  }\n}\nclass AsyncHttp2Call extends AsyncRequestCall {\n  /**\n   * Sends an HTTP2 request based on the provided configuration.\n   */\n  static invoke(config) {\n    return new AsyncHttp2Call(config).promise;\n  }\n  constructor(config) {\n    const http2ConfigImpl = new Http2RequestConfigImpl(config);\n    super(http2ConfigImpl);\n    try {\n      this.http2ConfigImpl = http2ConfigImpl;\n      this.options = this.http2ConfigImpl.buildRequestOptions();\n      this.entity = this.http2ConfigImpl.buildEntity(this.options.headers);\n      this.promise = new Promise((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n        this.execute();\n      });\n    } catch (err) {\n      this.promise = Promise.reject(this.enhanceError(err, null));\n    }\n  }\n  execute() {\n    const req = this.http2ConfigImpl.http2SessionHandler.session.request({\n      ':method': this.options.method,\n      ':scheme': this.options.protocol,\n      ':path': this.options.path,\n      ...this.options.headers\n    });\n    req.on('response', headers => {\n      this.handleHttp2Response(headers, req);\n    });\n    // Handle errors\n    req.on('error', err => {\n      if (req.aborted) {\n        return;\n      }\n      this.enhanceAndReject(err, null, req);\n    });\n    const timeout = this.http2ConfigImpl.timeout;\n    const timeoutCallback = () => {\n      req.destroy();\n      this.rejectWithError(`timeout of ${timeout}ms exceeded`, 'ETIMEDOUT', req);\n    };\n    if (timeout) {\n      // Listen to timeouts and throw an error.\n      req.setTimeout(timeout, timeoutCallback);\n    }\n    req.end(this.entity);\n  }\n  handleHttp2Response(headers, stream) {\n    if (stream.aborted) {\n      return;\n    }\n    if (!headers[':status']) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected a statusCode on the response from a ClientRequest');\n    }\n    const response = {\n      status: headers[':status'],\n      headers: headers,\n      request: stream,\n      data: undefined,\n      config: this.http2ConfigImpl\n    };\n    const boundary = this.getMultipartBoundary(headers);\n    const respStream = this.uncompressResponse(headers, stream);\n    if (boundary) {\n      this.handleMultipartResponse(response, respStream, boundary);\n    } else {\n      this.handleRegularResponse(response, respStream);\n    }\n  }\n  uncompressResponse(headers, stream) {\n    // Uncompress the response body transparently if required.\n    let respStream = stream;\n    const encodings = ['gzip', 'compress', 'deflate'];\n    if (headers['content-encoding'] && encodings.indexOf(headers['content-encoding']) !== -1) {\n      // Add the unzipper to the body stream processing pipeline.\n      const zlib = require('zlib'); // eslint-disable-line @typescript-eslint/no-var-requires\n      respStream = respStream.pipe(zlib.createUnzip());\n      // Remove the content-encoding in order to not confuse downstream operations.\n      delete headers['content-encoding'];\n    }\n    return respStream;\n  }\n}\n/**\n * An adapter class with common functionality needed to extract options and entity data from a `RequestConfig`.\n */\nclass BaseRequestConfigImpl {\n  constructor(config) {\n    this.config = config;\n    this.config = config;\n  }\n  get method() {\n    return this.config.method;\n  }\n  get url() {\n    return this.config.url;\n  }\n  get headers() {\n    return this.config.headers;\n  }\n  get data() {\n    return this.config.data;\n  }\n  get timeout() {\n    return this.config.timeout;\n  }\n  buildEntity(headers) {\n    let data;\n    if (!this.hasEntity() || !this.isEntityEnclosingRequest()) {\n      return data;\n    }\n    if (validator.isBuffer(this.data)) {\n      data = this.data;\n    } else if (validator.isObject(this.data)) {\n      data = Buffer.from(JSON.stringify(this.data), 'utf-8');\n      if (typeof headers['content-type'] === 'undefined') {\n        headers['content-type'] = 'application/json;charset=utf-8';\n      }\n    } else if (validator.isString(this.data)) {\n      data = Buffer.from(this.data, 'utf-8');\n    } else {\n      throw new Error('Request data must be a string, a Buffer or a json serializable object');\n    }\n    // Add Content-Length header if data exists.\n    headers['Content-Length'] = data.length.toString();\n    return data;\n  }\n  buildUrl() {\n    const fullUrl = this.urlWithProtocol();\n    if (!this.hasEntity() || this.isEntityEnclosingRequest()) {\n      return url.parse(fullUrl);\n    }\n    if (!validator.isObject(this.data)) {\n      throw new Error(`${this.method} requests cannot have a body`);\n    }\n    // Parse URL and append data to query string.\n    const parsedUrl = new url.URL(fullUrl);\n    const dataObj = this.data;\n    for (const key in dataObj) {\n      if (Object.prototype.hasOwnProperty.call(dataObj, key)) {\n        parsedUrl.searchParams.append(key, dataObj[key]);\n      }\n    }\n    return url.parse(parsedUrl.toString());\n  }\n  urlWithProtocol() {\n    const fullUrl = this.url;\n    if (fullUrl.startsWith('http://') || fullUrl.startsWith('https://')) {\n      return fullUrl;\n    }\n    return `https://${fullUrl}`;\n  }\n  hasEntity() {\n    return !!this.data;\n  }\n  isEntityEnclosingRequest() {\n    // GET and HEAD requests do not support entity (body) in request.\n    return this.method !== 'GET' && this.method !== 'HEAD';\n  }\n}\n/**\n * An adapter class for extracting options and entity data from an `HttpRequestConfig`.\n */\nclass HttpRequestConfigImpl extends BaseRequestConfigImpl {\n  constructor(httpConfig) {\n    super(httpConfig);\n    this.httpConfig = httpConfig;\n  }\n  get httpAgent() {\n    return this.httpConfig.httpAgent;\n  }\n  buildRequestOptions() {\n    const parsed = this.buildUrl();\n    const protocol = parsed.protocol;\n    let port = parsed.port;\n    if (!port) {\n      const isHttps = protocol === 'https:';\n      port = isHttps ? '443' : '80';\n    }\n    return {\n      protocol,\n      hostname: parsed.hostname,\n      port,\n      path: parsed.path,\n      method: this.method,\n      agent: this.httpAgent,\n      headers: Object.assign({}, this.headers)\n    };\n  }\n}\n/**\n * An adapter class for extracting options and entity data from an `Http2RequestConfig`.\n */\nclass Http2RequestConfigImpl extends BaseRequestConfigImpl {\n  constructor(http2Config) {\n    super(http2Config);\n    this.http2Config = http2Config;\n  }\n  get http2SessionHandler() {\n    return this.http2Config.http2SessionHandler;\n  }\n  buildRequestOptions() {\n    const parsed = this.buildUrl();\n    const protocol = parsed.protocol;\n    return {\n      protocol,\n      path: parsed.path,\n      method: this.method,\n      headers: Object.assign({}, this.headers)\n    };\n  }\n}\nclass AuthorizedHttpClient extends HttpClient {\n  constructor(app) {\n    super();\n    this.app = app;\n  }\n  send(request) {\n    return this.getToken().then(token => {\n      const requestCopy = Object.assign({}, request);\n      requestCopy.headers = Object.assign({}, request.headers);\n      const authHeader = 'Authorization';\n      requestCopy.headers[authHeader] = `Bearer ${token}`;\n      // Fix issue where firebase-admin does not specify quota project that is\n      // necessary for use when utilizing human account with ADC (RSDF)\n      if (!requestCopy.headers['x-goog-user-project'] && this.app.options.projectId) {\n        requestCopy.headers['x-goog-user-project'] = this.app.options.projectId;\n      }\n      if (!requestCopy.httpAgent && this.app.options.httpAgent) {\n        requestCopy.httpAgent = this.app.options.httpAgent;\n      }\n      return super.send(requestCopy);\n    });\n  }\n  getToken() {\n    return this.app.INTERNAL.getToken().then(accessTokenObj => accessTokenObj.accessToken);\n  }\n}\nexports.AuthorizedHttpClient = AuthorizedHttpClient;\nclass AuthorizedHttp2Client extends Http2Client {\n  constructor(app) {\n    super();\n    this.app = app;\n  }\n  send(request) {\n    return this.getToken().then(token => {\n      const requestCopy = Object.assign({}, request);\n      requestCopy.headers = Object.assign({}, request.headers);\n      const authHeader = 'Authorization';\n      requestCopy.headers[authHeader] = `Bearer ${token}`;\n      return super.send(requestCopy);\n    });\n  }\n  getToken() {\n    return this.app.INTERNAL.getToken().then(accessTokenObj => accessTokenObj.accessToken);\n  }\n}\nexports.AuthorizedHttp2Client = AuthorizedHttp2Client;\n/**\n * Class that defines all the settings for the backend API endpoint.\n *\n * @param endpoint - The Firebase Auth backend endpoint.\n * @param httpMethod - The HTTP method for that endpoint.\n * @constructor\n */\nclass ApiSettings {\n  constructor(endpoint) {\n    let httpMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'POST';\n    this.endpoint = endpoint;\n    this.httpMethod = httpMethod;\n    this.setRequestValidator(null).setResponseValidator(null);\n  }\n  /** @returns The backend API endpoint. */\n  getEndpoint() {\n    return this.endpoint;\n  }\n  /** @returns The request HTTP method. */\n  getHttpMethod() {\n    return this.httpMethod;\n  }\n  /**\n   * @param requestValidator - The request validator.\n   * @returns The current API settings instance.\n   */\n  setRequestValidator(requestValidator) {\n    const nullFunction = () => undefined;\n    this.requestValidator = requestValidator || nullFunction;\n    return this;\n  }\n  /** @returns The request validator. */\n  getRequestValidator() {\n    return this.requestValidator;\n  }\n  /**\n   * @param responseValidator - The response validator.\n   * @returns The current API settings instance.\n   */\n  setResponseValidator(responseValidator) {\n    const nullFunction = () => undefined;\n    this.responseValidator = responseValidator || nullFunction;\n    return this;\n  }\n  /** @returns The response validator. */\n  getResponseValidator() {\n    return this.responseValidator;\n  }\n}\nexports.ApiSettings = ApiSettings;\n/**\n * Class used for polling an endpoint with exponential backoff.\n *\n * Example usage:\n * ```\n * const poller = new ExponentialBackoffPoller();\n * poller\n *     .poll(() => {\n *       return myRequestToPoll()\n *           .then((responseData: any) => {\n *             if (!isValid(responseData)) {\n *               // Continue polling.\n *               return null;\n *             }\n *\n *             // Polling complete. Resolve promise with final response data.\n *             return responseData;\n *           });\n *     })\n *     .then((responseData: any) => {\n *       console.log(`Final response: ${responseData}`);\n *     });\n * ```\n */\nclass ExponentialBackoffPoller extends events_1.EventEmitter {\n  constructor() {\n    let initialPollingDelayMillis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;\n    let maxPollingDelayMillis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n    let masterTimeoutMillis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n    super();\n    this.initialPollingDelayMillis = initialPollingDelayMillis;\n    this.maxPollingDelayMillis = maxPollingDelayMillis;\n    this.masterTimeoutMillis = masterTimeoutMillis;\n    this.numTries = 0;\n    this.completed = false;\n  }\n  /**\n   * Poll the provided callback with exponential backoff.\n   *\n   * @param callback - The callback to be called for each poll. If the\n   *     callback resolves to a falsey value, polling will continue. Otherwise, the truthy\n   *     resolution will be used to resolve the promise returned by this method.\n   * @returns A Promise which resolves to the truthy value returned by the provided\n   *     callback when polling is complete.\n   */\n  poll(callback) {\n    if (this.pollCallback) {\n      throw new Error('poll() can only be called once per instance of ExponentialBackoffPoller');\n    }\n    this.pollCallback = callback;\n    this.on('poll', this.repoll);\n    this.masterTimer = setTimeout(() => {\n      if (this.completed) {\n        return;\n      }\n      this.markCompleted();\n      this.reject(new Error('ExponentialBackoffPoller deadline exceeded - Master timeout reached'));\n    }, this.masterTimeoutMillis);\n    return new Promise((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n      this.repoll();\n    });\n  }\n  repoll() {\n    this.pollCallback().then(result => {\n      if (this.completed) {\n        return;\n      }\n      if (!result) {\n        this.repollTimer = setTimeout(() => this.emit('poll'), this.getPollingDelayMillis());\n        this.numTries++;\n        return;\n      }\n      this.markCompleted();\n      this.resolve(result);\n    }).catch(err => {\n      if (this.completed) {\n        return;\n      }\n      this.markCompleted();\n      this.reject(err);\n    });\n  }\n  getPollingDelayMillis() {\n    const increasedPollingDelay = Math.pow(2, this.numTries) * this.initialPollingDelayMillis;\n    return Math.min(increasedPollingDelay, this.maxPollingDelayMillis);\n  }\n  markCompleted() {\n    this.completed = true;\n    if (this.masterTimer) {\n      clearTimeout(this.masterTimer);\n    }\n    if (this.repollTimer) {\n      clearTimeout(this.repollTimer);\n    }\n  }\n}\nexports.ExponentialBackoffPoller = ExponentialBackoffPoller;\nclass Http2SessionHandler {\n  constructor(url) {\n    this.http2Session = this.createSession(url);\n  }\n  createSession(url) {\n    if (!this.http2Session || this.isClosed) {\n      const opts = {\n        // Set local max concurrent stream limit to respect backend limit\n        peerMaxConcurrentStreams: 100,\n        ALPNProtocols: ['h2']\n      };\n      const http2Session = http2.connect(url, opts);\n      http2Session.on('goaway', (errorCode, _, opaqueData) => {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making requests: GOAWAY - ${opaqueData.toString()}, Error code: ${errorCode}`);\n      });\n      http2Session.on('error', error => {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making requests: ${error}`);\n      });\n      return http2Session;\n    }\n    return this.http2Session;\n  }\n  get session() {\n    return this.http2Session;\n  }\n  get isClosed() {\n    return this.http2Session.closed;\n  }\n  close() {\n    this.http2Session.close();\n  }\n}\nexports.Http2SessionHandler = Http2SessionHandler;","map":{"version":3,"names":["Object","defineProperty","exports","value","Http2SessionHandler","ExponentialBackoffPoller","ApiSettings","AuthorizedHttp2Client","AuthorizedHttpClient","parseHttpResponse","Http2Client","HttpClient","RequestClient","defaultRetryConfig","RequestResponseError","error_1","require","validator","http","https","http2","url","events_1","DefaultRequestResponse","constructor","resp","status","headers","text","data","FirebaseAppError","AppErrorCodes","INTERNAL_ERROR","parsedData","JSON","parse","err","undefined","parseError","request","config","method","isJson","UNABLE_TO_PARSE_RESPONSE","toString","MultipartRequestResponse","multipart","Error","response","setPrototypeOf","prototype","maxRetries","statusCodes","ioErrorCodes","backOffFactor","maxDelayInMillis","validateRetryConfig","retry","isNumber","INVALID_ARGUMENT","isArray","createRequestResponse","waitForRetry","delayMillis","Promise","resolve","setTimeout","getRetryDelayMillis","retryAttempts","isRetryEligible","parseRetryAfterIntoMillis","backOffDelayMillis","indexOf","code","retryCodes","retryAfter","delaySeconds","parseInt","isNaN","date","Date","getTime","now","delayInSeconds","Math","min","send","sendWithRetry","AsyncHttpCall","invoke","then","catch","canRetry","NETWORK_TIMEOUT","message","NETWORK_ERROR","AsyncHttp2Call","responseText","isBuffer","endOfHeaderPos","headerLines","substring","split","statusLine","trim","slice","forEach","line","colonPos","name","toLowerCase","endsWith","lowLevelResponse","AsyncRequestCall","configImpl","getMultipartBoundary","contentType","startsWith","segments","emptyObject","headerParams","map","segment","reduce","curr","params","length","keyValuePair","assign","boundary","handleMultipartResponse","respStream","busboy","multipartParser","Dicer","responseBuffer","on","part","tempBuffers","partData","push","Buffer","concat","finalizeResponse","pipe","handleRegularResponse","chunk","req","destroyed","enhanceAndReject","rejectWithError","error","reject","enhanceError","promise","httpConfigImpl","HttpRequestConfigImpl","options","buildRequestOptions","entity","buildEntity","execute","transport","protocol","res","handleResponse","aborted","timeout","timeoutCallback","destroy","end","statusCode","uncompressResponse","encodings","zlib","createUnzip","http2ConfigImpl","Http2RequestConfigImpl","http2SessionHandler","session","path","handleHttp2Response","stream","BaseRequestConfigImpl","hasEntity","isEntityEnclosingRequest","isObject","from","stringify","isString","buildUrl","fullUrl","urlWithProtocol","parsedUrl","URL","dataObj","key","hasOwnProperty","call","searchParams","append","httpConfig","httpAgent","parsed","port","isHttps","hostname","agent","http2Config","app","getToken","token","requestCopy","authHeader","projectId","INTERNAL","accessTokenObj","accessToken","endpoint","httpMethod","setRequestValidator","setResponseValidator","getEndpoint","getHttpMethod","requestValidator","nullFunction","getRequestValidator","responseValidator","getResponseValidator","EventEmitter","initialPollingDelayMillis","maxPollingDelayMillis","masterTimeoutMillis","numTries","completed","poll","callback","pollCallback","repoll","masterTimer","markCompleted","result","repollTimer","emit","getPollingDelayMillis","increasedPollingDelay","pow","clearTimeout","http2Session","createSession","isClosed","opts","peerMaxConcurrentStreams","ALPNProtocols","connect","errorCode","_","opaqueData","closed","close"],"sources":["/home/yadu/Music/Gifty/node_modules/firebase-admin/lib/utils/api-request.js"],"sourcesContent":["/*! firebase-admin v12.7.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Http2SessionHandler = exports.ExponentialBackoffPoller = exports.ApiSettings = exports.AuthorizedHttp2Client = exports.AuthorizedHttpClient = exports.parseHttpResponse = exports.Http2Client = exports.HttpClient = exports.RequestClient = exports.defaultRetryConfig = exports.RequestResponseError = void 0;\nconst error_1 = require(\"./error\");\nconst validator = require(\"./validator\");\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst http2 = require(\"http2\");\nconst url = require(\"url\");\nconst events_1 = require(\"events\");\nclass DefaultRequestResponse {\n    /**\n     * Constructs a new `RequestResponse` from the given `LowLevelResponse`.\n     */\n    constructor(resp) {\n        this.status = resp.status;\n        this.headers = resp.headers;\n        this.text = resp.data;\n        try {\n            if (!resp.data) {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'HTTP response missing data.');\n            }\n            this.parsedData = JSON.parse(resp.data);\n        }\n        catch (err) {\n            this.parsedData = undefined;\n            this.parseError = err;\n        }\n        this.request = `${resp.config.method} ${resp.config.url}`;\n    }\n    get data() {\n        if (this.isJson()) {\n            return this.parsedData;\n        }\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, `Error while parsing response data: \"${this.parseError.toString()}\". Raw server ` +\n            `response: \"${this.text}\". Status code: \"${this.status}\". Outgoing ` +\n            `request: \"${this.request}.\"`);\n    }\n    isJson() {\n        return typeof this.parsedData !== 'undefined';\n    }\n}\n/**\n * Represents a multipart HTTP or HTTP/2 response. Parts that constitute the response body can be accessed\n * via the multipart getter. Getters for text and data throw errors.\n */\nclass MultipartRequestResponse {\n    constructor(resp) {\n        this.status = resp.status;\n        this.headers = resp.headers;\n        this.multipart = resp.multipart;\n    }\n    get text() {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, 'Unable to parse multipart payload as text');\n    }\n    get data() {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, 'Unable to parse multipart payload as JSON');\n    }\n    isJson() {\n        return false;\n    }\n}\nclass RequestResponseError extends Error {\n    constructor(response) {\n        super(`Server responded with status ${response.status}.`);\n        this.response = response;\n        // Set the prototype so that instanceof checks will work correctly.\n        // See: https://github.com/Microsoft/TypeScript/issues/13965\n        Object.setPrototypeOf(this, RequestResponseError.prototype);\n    }\n}\nexports.RequestResponseError = RequestResponseError;\n/**\n * Default retry configuration for HTTP and HTTP/2 requests. Retries up to 4 times on connection reset and timeout\n * errors as well as 503 errors. Exposed as a function to ensure that every `RequestClient` gets its own `RetryConfig`\n * instance.\n */\nfunction defaultRetryConfig() {\n    return {\n        maxRetries: 4,\n        statusCodes: [503],\n        ioErrorCodes: ['ECONNRESET', 'ETIMEDOUT'],\n        backOffFactor: 0.5,\n        maxDelayInMillis: 60 * 1000,\n    };\n}\nexports.defaultRetryConfig = defaultRetryConfig;\n/**\n * Ensures that the given `RetryConfig` object is valid.\n *\n * @param retry - The configuration to be validated.\n */\nfunction validateRetryConfig(retry) {\n    if (!validator.isNumber(retry.maxRetries) || retry.maxRetries < 0) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'maxRetries must be a non-negative integer');\n    }\n    if (typeof retry.backOffFactor !== 'undefined') {\n        if (!validator.isNumber(retry.backOffFactor) || retry.backOffFactor < 0) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'backOffFactor must be a non-negative number');\n        }\n    }\n    if (!validator.isNumber(retry.maxDelayInMillis) || retry.maxDelayInMillis < 0) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'maxDelayInMillis must be a non-negative integer');\n    }\n    if (typeof retry.statusCodes !== 'undefined' && !validator.isArray(retry.statusCodes)) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'statusCodes must be an array');\n    }\n    if (typeof retry.ioErrorCodes !== 'undefined' && !validator.isArray(retry.ioErrorCodes)) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, 'ioErrorCodes must be an array');\n    }\n}\nclass RequestClient {\n    constructor(retry = defaultRetryConfig()) {\n        if (retry) {\n            this.retry = retry;\n            validateRetryConfig(this.retry);\n        }\n    }\n    createRequestResponse(resp) {\n        if (resp.multipart) {\n            return new MultipartRequestResponse(resp);\n        }\n        return new DefaultRequestResponse(resp);\n    }\n    waitForRetry(delayMillis) {\n        if (delayMillis > 0) {\n            return new Promise((resolve) => {\n                setTimeout(resolve, delayMillis);\n            });\n        }\n        return Promise.resolve();\n    }\n    /**\n     * Checks if a failed request is eligible for a retry, and if so returns the duration to wait before initiating\n     * the retry.\n     *\n     * @param retryAttempts - Number of retries completed up to now.\n     * @param err - The last encountered error.\n     * @returns A 2-tuple where the 1st element is the duration to wait before another retry, and the\n     *     2nd element is a boolean indicating whether the request is eligible for a retry or not.\n     */\n    getRetryDelayMillis(retryAttempts, err) {\n        if (!this.isRetryEligible(retryAttempts, err)) {\n            return [0, false];\n        }\n        const response = err.response;\n        if (response && response.headers['retry-after']) {\n            const delayMillis = this.parseRetryAfterIntoMillis(response.headers['retry-after']);\n            if (delayMillis > 0) {\n                return [delayMillis, true];\n            }\n        }\n        return [this.backOffDelayMillis(retryAttempts), true];\n    }\n    isRetryEligible(retryAttempts, err) {\n        if (!this.retry) {\n            return false;\n        }\n        if (retryAttempts >= this.retry.maxRetries) {\n            return false;\n        }\n        if (err.response) {\n            const statusCodes = this.retry.statusCodes || [];\n            return statusCodes.indexOf(err.response.status) !== -1;\n        }\n        if (err.code) {\n            const retryCodes = this.retry.ioErrorCodes || [];\n            return retryCodes.indexOf(err.code) !== -1;\n        }\n        return false;\n    }\n    /**???\n     * Parses the Retry-After header as a milliseconds value. Return value is negative if the Retry-After header\n     * contains an expired timestamp or otherwise malformed.\n     */\n    parseRetryAfterIntoMillis(retryAfter) {\n        const delaySeconds = parseInt(retryAfter, 10);\n        if (!isNaN(delaySeconds)) {\n            return delaySeconds * 1000;\n        }\n        const date = new Date(retryAfter);\n        if (!isNaN(date.getTime())) {\n            return date.getTime() - Date.now();\n        }\n        return -1;\n    }\n    backOffDelayMillis(retryAttempts) {\n        if (retryAttempts === 0) {\n            return 0;\n        }\n        if (!this.retry) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected this.retry to exist.');\n        }\n        const backOffFactor = this.retry.backOffFactor || 0;\n        const delayInSeconds = (2 ** retryAttempts) * backOffFactor;\n        return Math.min(delayInSeconds * 1000, this.retry.maxDelayInMillis);\n    }\n}\nexports.RequestClient = RequestClient;\nclass HttpClient extends RequestClient {\n    constructor(retry) {\n        super(retry);\n    }\n    /**\n     * Sends an HTTP request to a remote server. If the server responds with a successful response (2xx), the returned\n     * promise resolves with an `RequestResponse`. If the server responds with an error (3xx, 4xx, 5xx), the promise\n     * rejects with an `RequestResponseError`. In case of all other errors, the promise rejects with a `FirebaseAppError`.\n     * If a request fails due to a low-level network error, the client transparently retries the request once before\n     * rejecting the promise.\n     *\n     * If the request data is specified as an object, it will be serialized into a JSON string. The application/json\n     * content-type header will also be automatically set in this case. For all other payload types, the content-type\n     * header should be explicitly set by the caller. To send a JSON leaf value (e.g. \"foo\", 5), parse it into JSON,\n     * and pass as a string or a Buffer along with the appropriate content-type header.\n     *\n     * @param config - HTTP request to be sent.\n     * @returns A promise that resolves with the response details.\n     */\n    send(config) {\n        return this.sendWithRetry(config);\n    }\n    /**\n     * Sends an HTTP request. In the event of an error, retries the HTTP request according to the\n     * `RetryConfig` set on the `HttpClient`.\n     *\n     * @param config - HTTP request to be sent.\n     * @param retryAttempts - Number of retries performed up to now.\n     * @returns A promise that resolves with the response details.\n     */\n    sendWithRetry(config, retryAttempts = 0) {\n        return AsyncHttpCall.invoke(config)\n            .then((resp) => {\n            return this.createRequestResponse(resp);\n        })\n            .catch((err) => {\n            const [delayMillis, canRetry] = this.getRetryDelayMillis(retryAttempts, err);\n            if (canRetry && this.retry && delayMillis <= this.retry.maxDelayInMillis) {\n                return this.waitForRetry(delayMillis).then(() => {\n                    return this.sendWithRetry(config, retryAttempts + 1);\n                });\n            }\n            if (err.response) {\n                throw new RequestResponseError(this.createRequestResponse(err.response));\n            }\n            if (err.code === 'ETIMEDOUT') {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_TIMEOUT, `Error while making request: ${err.message}.`);\n            }\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making request: ${err.message}. Error code: ${err.code}`);\n        });\n    }\n}\nexports.HttpClient = HttpClient;\nclass Http2Client extends RequestClient {\n    constructor(retry = defaultRetryConfig()) {\n        super(retry);\n    }\n    /**\n     * Sends an HTTP/2 request to a remote server. If the server responds with a successful response (2xx), the returned\n     * promise resolves with an `RequestResponse`. If the server responds with an error (3xx, 4xx, 5xx), the promise\n     * rejects with an `RequestResponseError`. In case of all other errors, the promise rejects with a `FirebaseAppError`.\n     * If a request fails due to a low-level network error, the client transparently retries the request once before\n     * rejecting the promise.\n     *\n     * If the request data is specified as an object, it will be serialized into a JSON string. The application/json\n     * content-type header will also be automatically set in this case. For all other payload types, the content-type\n     * header should be explicitly set by the caller. To send a JSON leaf value (e.g. \"foo\", 5), parse it into JSON,\n     * and pass as a string or a Buffer along with the appropriate content-type header.\n     *\n     * @param config - HTTP/2 request to be sent.\n     * @returns A promise that resolves with the response details.\n     */\n    send(config) {\n        return this.sendWithRetry(config);\n    }\n    /**\n     * Sends an HTTP/2 request. In the event of an error, retries the HTTP/2 request according to the\n     * `RetryConfig` set on the `Http2Client`.\n     *\n     * @param config - HTTP/2 request to be sent.\n     * @param retryAttempts - Number of retries performed up to now.\n     * @returns A promise that resolves with the response details.\n     */\n    sendWithRetry(config, retryAttempts = 0) {\n        return AsyncHttp2Call.invoke(config)\n            .then((resp) => {\n            return this.createRequestResponse(resp);\n        })\n            .catch((err) => {\n            const [delayMillis, canRetry] = this.getRetryDelayMillis(retryAttempts, err);\n            if (canRetry && this.retry && delayMillis <= this.retry.maxDelayInMillis) {\n                return this.waitForRetry(delayMillis).then(() => {\n                    return this.sendWithRetry(config, retryAttempts + 1);\n                });\n            }\n            if (err.response) {\n                throw new RequestResponseError(this.createRequestResponse(err.response));\n            }\n            if (err.code === 'ETIMEDOUT') {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_TIMEOUT, `Error while making request: ${err.message}.`);\n            }\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making request: ${err.message}. Error code: ${err.code}`);\n        });\n    }\n}\nexports.Http2Client = Http2Client;\n/**\n * Parses a full HTTP or HTTP/2 response message containing both a header and a body.\n *\n * @param response - The HTTP or HTTP/2 response to be parsed.\n * @param config - The request configuration that resulted in the HTTP or HTTP/2 response.\n * @returns An object containing the response's parsed status, headers and the body.\n */\nfunction parseHttpResponse(response, config) {\n    const responseText = validator.isBuffer(response) ?\n        response.toString('utf-8') : response;\n    const endOfHeaderPos = responseText.indexOf('\\r\\n\\r\\n');\n    const headerLines = responseText.substring(0, endOfHeaderPos).split('\\r\\n');\n    const statusLine = headerLines[0];\n    const status = statusLine.trim().split(/\\s/)[1];\n    const headers = {};\n    headerLines.slice(1).forEach((line) => {\n        const colonPos = line.indexOf(':');\n        const name = line.substring(0, colonPos).trim().toLowerCase();\n        const value = line.substring(colonPos + 1).trim();\n        headers[name] = value;\n    });\n    let data = responseText.substring(endOfHeaderPos + 4);\n    if (data.endsWith('\\n')) {\n        data = data.slice(0, -1);\n    }\n    if (data.endsWith('\\r')) {\n        data = data.slice(0, -1);\n    }\n    const lowLevelResponse = {\n        status: parseInt(status, 10),\n        headers,\n        data,\n        config,\n        request: null,\n    };\n    if (!validator.isNumber(lowLevelResponse.status)) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Malformed HTTP status line.');\n    }\n    return new DefaultRequestResponse(lowLevelResponse);\n}\nexports.parseHttpResponse = parseHttpResponse;\n/**\n * A helper class for common functionality needed to send requests over the wire.\n * It also wraps the callback API of the Node.js standard library in a more flexible Promise API.\n */\nclass AsyncRequestCall {\n    constructor(configImpl) {\n        this.configImpl = configImpl;\n    }\n    /**\n     * Extracts multipart boundary from the HTTP header. The content-type header of a multipart\n     * response has the form 'multipart/subtype; boundary=string'.\n     *\n     * If the content-type header does not exist, or does not start with\n     * 'multipart/', then null will be returned.\n     */\n    getMultipartBoundary(headers) {\n        const contentType = headers['content-type'];\n        if (!contentType || !contentType.startsWith('multipart/')) {\n            return null;\n        }\n        const segments = contentType.split(';');\n        const emptyObject = {};\n        const headerParams = segments.slice(1)\n            .map((segment) => segment.trim().split('='))\n            .reduce((curr, params) => {\n            // Parse key=value pairs in the content-type header into properties of an object.\n            if (params.length === 2) {\n                const keyValuePair = {};\n                keyValuePair[params[0]] = params[1];\n                return Object.assign(curr, keyValuePair);\n            }\n            return curr;\n        }, emptyObject);\n        return headerParams.boundary;\n    }\n    handleMultipartResponse(response, respStream, boundary) {\n        const busboy = require('@fastify/busboy'); // eslint-disable-line @typescript-eslint/no-var-requires\n        const multipartParser = new busboy.Dicer({ boundary });\n        const responseBuffer = [];\n        multipartParser.on('part', (part) => {\n            const tempBuffers = [];\n            part.on('data', (partData) => {\n                tempBuffers.push(partData);\n            });\n            part.on('end', () => {\n                responseBuffer.push(Buffer.concat(tempBuffers));\n            });\n        });\n        multipartParser.on('finish', () => {\n            response.data = undefined;\n            response.multipart = responseBuffer;\n            this.finalizeResponse(response);\n        });\n        respStream.pipe(multipartParser);\n    }\n    handleRegularResponse(response, respStream) {\n        const responseBuffer = [];\n        respStream.on('data', (chunk) => {\n            responseBuffer.push(chunk);\n        });\n        respStream.on('error', (err) => {\n            const req = response.request;\n            if (req && req.destroyed) {\n                return;\n            }\n            this.enhanceAndReject(err, null, req);\n        });\n        respStream.on('end', () => {\n            response.data = Buffer.concat(responseBuffer).toString();\n            this.finalizeResponse(response);\n        });\n    }\n    /**\n     * Finalizes the current request call in-flight by either resolving or rejecting the associated\n     * promise. In the event of an error, adds additional useful information to the returned error.\n     */\n    finalizeResponse(response) {\n        if (response.status >= 200 && response.status < 300) {\n            this.resolve(response);\n        }\n        else {\n            this.rejectWithError('Request failed with status code ' + response.status, null, response.request, response);\n        }\n    }\n    /**\n     * Creates a new error from the given message, and enhances it with other information available.\n     * Then the promise associated with this request call is rejected with the resulting error.\n     */\n    rejectWithError(message, code, request, response) {\n        const error = new Error(message);\n        this.enhanceAndReject(error, code, request, response);\n    }\n    enhanceAndReject(error, code, request, response) {\n        this.reject(this.enhanceError(error, code, request, response));\n    }\n    /**\n     * Enhances the given error by adding more information to it. Specifically, the request config,\n     * the underlying request and response will be attached to the error.\n     */\n    enhanceError(error, code, request, response) {\n        error.config = this.configImpl;\n        if (code) {\n            error.code = code;\n        }\n        error.request = request;\n        error.response = response;\n        return error;\n    }\n}\n/**\n * A helper class for sending HTTP requests over the wire. This is a wrapper around the standard\n * http and https packages of Node.js, providing content processing, timeouts and error handling.\n * It also wraps the callback API of the Node.js standard library in a more flexible Promise API.\n */\nclass AsyncHttpCall extends AsyncRequestCall {\n    /**\n     * Sends an HTTP request based on the provided configuration.\n     */\n    static invoke(config) {\n        return new AsyncHttpCall(config).promise;\n    }\n    constructor(config) {\n        const httpConfigImpl = new HttpRequestConfigImpl(config);\n        super(httpConfigImpl);\n        try {\n            this.httpConfigImpl = httpConfigImpl;\n            this.options = this.httpConfigImpl.buildRequestOptions();\n            this.entity = this.httpConfigImpl.buildEntity(this.options.headers);\n            this.promise = new Promise((resolve, reject) => {\n                this.resolve = resolve;\n                this.reject = reject;\n                this.execute();\n            });\n        }\n        catch (err) {\n            this.promise = Promise.reject(this.enhanceError(err, null));\n        }\n    }\n    execute() {\n        const transport = this.options.protocol === 'https:' ? https : http;\n        const req = transport.request(this.options, (res) => {\n            this.handleResponse(res, req);\n        });\n        // Handle errors\n        req.on('error', (err) => {\n            if (req.aborted) {\n                return;\n            }\n            this.enhanceAndReject(err, null, req);\n        });\n        const timeout = this.httpConfigImpl.timeout;\n        const timeoutCallback = () => {\n            req.destroy();\n            this.rejectWithError(`timeout of ${timeout}ms exceeded`, 'ETIMEDOUT', req);\n        };\n        if (timeout) {\n            // Listen to timeouts and throw an error.\n            req.setTimeout(timeout, timeoutCallback);\n        }\n        // Send the request\n        req.end(this.entity);\n    }\n    handleResponse(res, req) {\n        if (req.aborted) {\n            return;\n        }\n        if (!res.statusCode) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected a statusCode on the response from a ClientRequest');\n        }\n        const response = {\n            status: res.statusCode,\n            headers: res.headers,\n            request: req,\n            data: undefined,\n            config: this.httpConfigImpl,\n        };\n        const boundary = this.getMultipartBoundary(res.headers);\n        const respStream = this.uncompressResponse(res);\n        if (boundary) {\n            this.handleMultipartResponse(response, respStream, boundary);\n        }\n        else {\n            this.handleRegularResponse(response, respStream);\n        }\n    }\n    uncompressResponse(res) {\n        // Uncompress the response body transparently if required.\n        let respStream = res;\n        const encodings = ['gzip', 'compress', 'deflate'];\n        if (res.headers['content-encoding'] && encodings.indexOf(res.headers['content-encoding']) !== -1) {\n            // Add the unzipper to the body stream processing pipeline.\n            const zlib = require('zlib'); // eslint-disable-line @typescript-eslint/no-var-requires\n            respStream = respStream.pipe(zlib.createUnzip());\n            // Remove the content-encoding in order to not confuse downstream operations.\n            delete res.headers['content-encoding'];\n        }\n        return respStream;\n    }\n}\nclass AsyncHttp2Call extends AsyncRequestCall {\n    /**\n     * Sends an HTTP2 request based on the provided configuration.\n     */\n    static invoke(config) {\n        return new AsyncHttp2Call(config).promise;\n    }\n    constructor(config) {\n        const http2ConfigImpl = new Http2RequestConfigImpl(config);\n        super(http2ConfigImpl);\n        try {\n            this.http2ConfigImpl = http2ConfigImpl;\n            this.options = this.http2ConfigImpl.buildRequestOptions();\n            this.entity = this.http2ConfigImpl.buildEntity(this.options.headers);\n            this.promise = new Promise((resolve, reject) => {\n                this.resolve = resolve;\n                this.reject = reject;\n                this.execute();\n            });\n        }\n        catch (err) {\n            this.promise = Promise.reject(this.enhanceError(err, null));\n        }\n    }\n    execute() {\n        const req = this.http2ConfigImpl.http2SessionHandler.session.request({\n            ':method': this.options.method,\n            ':scheme': this.options.protocol,\n            ':path': this.options.path,\n            ...this.options.headers\n        });\n        req.on('response', (headers) => {\n            this.handleHttp2Response(headers, req);\n        });\n        // Handle errors\n        req.on('error', (err) => {\n            if (req.aborted) {\n                return;\n            }\n            this.enhanceAndReject(err, null, req);\n        });\n        const timeout = this.http2ConfigImpl.timeout;\n        const timeoutCallback = () => {\n            req.destroy();\n            this.rejectWithError(`timeout of ${timeout}ms exceeded`, 'ETIMEDOUT', req);\n        };\n        if (timeout) {\n            // Listen to timeouts and throw an error.\n            req.setTimeout(timeout, timeoutCallback);\n        }\n        req.end(this.entity);\n    }\n    handleHttp2Response(headers, stream) {\n        if (stream.aborted) {\n            return;\n        }\n        if (!headers[':status']) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, 'Expected a statusCode on the response from a ClientRequest');\n        }\n        const response = {\n            status: headers[':status'],\n            headers: headers,\n            request: stream,\n            data: undefined,\n            config: this.http2ConfigImpl,\n        };\n        const boundary = this.getMultipartBoundary(headers);\n        const respStream = this.uncompressResponse(headers, stream);\n        if (boundary) {\n            this.handleMultipartResponse(response, respStream, boundary);\n        }\n        else {\n            this.handleRegularResponse(response, respStream);\n        }\n    }\n    uncompressResponse(headers, stream) {\n        // Uncompress the response body transparently if required.\n        let respStream = stream;\n        const encodings = ['gzip', 'compress', 'deflate'];\n        if (headers['content-encoding'] && encodings.indexOf(headers['content-encoding']) !== -1) {\n            // Add the unzipper to the body stream processing pipeline.\n            const zlib = require('zlib'); // eslint-disable-line @typescript-eslint/no-var-requires\n            respStream = respStream.pipe(zlib.createUnzip());\n            // Remove the content-encoding in order to not confuse downstream operations.\n            delete headers['content-encoding'];\n        }\n        return respStream;\n    }\n}\n/**\n * An adapter class with common functionality needed to extract options and entity data from a `RequestConfig`.\n */\nclass BaseRequestConfigImpl {\n    constructor(config) {\n        this.config = config;\n        this.config = config;\n    }\n    get method() {\n        return this.config.method;\n    }\n    get url() {\n        return this.config.url;\n    }\n    get headers() {\n        return this.config.headers;\n    }\n    get data() {\n        return this.config.data;\n    }\n    get timeout() {\n        return this.config.timeout;\n    }\n    buildEntity(headers) {\n        let data;\n        if (!this.hasEntity() || !this.isEntityEnclosingRequest()) {\n            return data;\n        }\n        if (validator.isBuffer(this.data)) {\n            data = this.data;\n        }\n        else if (validator.isObject(this.data)) {\n            data = Buffer.from(JSON.stringify(this.data), 'utf-8');\n            if (typeof headers['content-type'] === 'undefined') {\n                headers['content-type'] = 'application/json;charset=utf-8';\n            }\n        }\n        else if (validator.isString(this.data)) {\n            data = Buffer.from(this.data, 'utf-8');\n        }\n        else {\n            throw new Error('Request data must be a string, a Buffer or a json serializable object');\n        }\n        // Add Content-Length header if data exists.\n        headers['Content-Length'] = data.length.toString();\n        return data;\n    }\n    buildUrl() {\n        const fullUrl = this.urlWithProtocol();\n        if (!this.hasEntity() || this.isEntityEnclosingRequest()) {\n            return url.parse(fullUrl);\n        }\n        if (!validator.isObject(this.data)) {\n            throw new Error(`${this.method} requests cannot have a body`);\n        }\n        // Parse URL and append data to query string.\n        const parsedUrl = new url.URL(fullUrl);\n        const dataObj = this.data;\n        for (const key in dataObj) {\n            if (Object.prototype.hasOwnProperty.call(dataObj, key)) {\n                parsedUrl.searchParams.append(key, dataObj[key]);\n            }\n        }\n        return url.parse(parsedUrl.toString());\n    }\n    urlWithProtocol() {\n        const fullUrl = this.url;\n        if (fullUrl.startsWith('http://') || fullUrl.startsWith('https://')) {\n            return fullUrl;\n        }\n        return `https://${fullUrl}`;\n    }\n    hasEntity() {\n        return !!this.data;\n    }\n    isEntityEnclosingRequest() {\n        // GET and HEAD requests do not support entity (body) in request.\n        return this.method !== 'GET' && this.method !== 'HEAD';\n    }\n}\n/**\n * An adapter class for extracting options and entity data from an `HttpRequestConfig`.\n */\nclass HttpRequestConfigImpl extends BaseRequestConfigImpl {\n    constructor(httpConfig) {\n        super(httpConfig);\n        this.httpConfig = httpConfig;\n    }\n    get httpAgent() {\n        return this.httpConfig.httpAgent;\n    }\n    buildRequestOptions() {\n        const parsed = this.buildUrl();\n        const protocol = parsed.protocol;\n        let port = parsed.port;\n        if (!port) {\n            const isHttps = protocol === 'https:';\n            port = isHttps ? '443' : '80';\n        }\n        return {\n            protocol,\n            hostname: parsed.hostname,\n            port,\n            path: parsed.path,\n            method: this.method,\n            agent: this.httpAgent,\n            headers: Object.assign({}, this.headers),\n        };\n    }\n}\n/**\n * An adapter class for extracting options and entity data from an `Http2RequestConfig`.\n */\nclass Http2RequestConfigImpl extends BaseRequestConfigImpl {\n    constructor(http2Config) {\n        super(http2Config);\n        this.http2Config = http2Config;\n    }\n    get http2SessionHandler() {\n        return this.http2Config.http2SessionHandler;\n    }\n    buildRequestOptions() {\n        const parsed = this.buildUrl();\n        const protocol = parsed.protocol;\n        return {\n            protocol,\n            path: parsed.path,\n            method: this.method,\n            headers: Object.assign({}, this.headers),\n        };\n    }\n}\nclass AuthorizedHttpClient extends HttpClient {\n    constructor(app) {\n        super();\n        this.app = app;\n    }\n    send(request) {\n        return this.getToken().then((token) => {\n            const requestCopy = Object.assign({}, request);\n            requestCopy.headers = Object.assign({}, request.headers);\n            const authHeader = 'Authorization';\n            requestCopy.headers[authHeader] = `Bearer ${token}`;\n            // Fix issue where firebase-admin does not specify quota project that is\n            // necessary for use when utilizing human account with ADC (RSDF)\n            if (!requestCopy.headers['x-goog-user-project'] && this.app.options.projectId) {\n                requestCopy.headers['x-goog-user-project'] = this.app.options.projectId;\n            }\n            if (!requestCopy.httpAgent && this.app.options.httpAgent) {\n                requestCopy.httpAgent = this.app.options.httpAgent;\n            }\n            return super.send(requestCopy);\n        });\n    }\n    getToken() {\n        return this.app.INTERNAL.getToken()\n            .then((accessTokenObj) => accessTokenObj.accessToken);\n    }\n}\nexports.AuthorizedHttpClient = AuthorizedHttpClient;\nclass AuthorizedHttp2Client extends Http2Client {\n    constructor(app) {\n        super();\n        this.app = app;\n    }\n    send(request) {\n        return this.getToken().then((token) => {\n            const requestCopy = Object.assign({}, request);\n            requestCopy.headers = Object.assign({}, request.headers);\n            const authHeader = 'Authorization';\n            requestCopy.headers[authHeader] = `Bearer ${token}`;\n            return super.send(requestCopy);\n        });\n    }\n    getToken() {\n        return this.app.INTERNAL.getToken()\n            .then((accessTokenObj) => accessTokenObj.accessToken);\n    }\n}\nexports.AuthorizedHttp2Client = AuthorizedHttp2Client;\n/**\n * Class that defines all the settings for the backend API endpoint.\n *\n * @param endpoint - The Firebase Auth backend endpoint.\n * @param httpMethod - The HTTP method for that endpoint.\n * @constructor\n */\nclass ApiSettings {\n    constructor(endpoint, httpMethod = 'POST') {\n        this.endpoint = endpoint;\n        this.httpMethod = httpMethod;\n        this.setRequestValidator(null)\n            .setResponseValidator(null);\n    }\n    /** @returns The backend API endpoint. */\n    getEndpoint() {\n        return this.endpoint;\n    }\n    /** @returns The request HTTP method. */\n    getHttpMethod() {\n        return this.httpMethod;\n    }\n    /**\n     * @param requestValidator - The request validator.\n     * @returns The current API settings instance.\n     */\n    setRequestValidator(requestValidator) {\n        const nullFunction = () => undefined;\n        this.requestValidator = requestValidator || nullFunction;\n        return this;\n    }\n    /** @returns The request validator. */\n    getRequestValidator() {\n        return this.requestValidator;\n    }\n    /**\n     * @param responseValidator - The response validator.\n     * @returns The current API settings instance.\n     */\n    setResponseValidator(responseValidator) {\n        const nullFunction = () => undefined;\n        this.responseValidator = responseValidator || nullFunction;\n        return this;\n    }\n    /** @returns The response validator. */\n    getResponseValidator() {\n        return this.responseValidator;\n    }\n}\nexports.ApiSettings = ApiSettings;\n/**\n * Class used for polling an endpoint with exponential backoff.\n *\n * Example usage:\n * ```\n * const poller = new ExponentialBackoffPoller();\n * poller\n *     .poll(() => {\n *       return myRequestToPoll()\n *           .then((responseData: any) => {\n *             if (!isValid(responseData)) {\n *               // Continue polling.\n *               return null;\n *             }\n *\n *             // Polling complete. Resolve promise with final response data.\n *             return responseData;\n *           });\n *     })\n *     .then((responseData: any) => {\n *       console.log(`Final response: ${responseData}`);\n *     });\n * ```\n */\nclass ExponentialBackoffPoller extends events_1.EventEmitter {\n    constructor(initialPollingDelayMillis = 1000, maxPollingDelayMillis = 10000, masterTimeoutMillis = 60000) {\n        super();\n        this.initialPollingDelayMillis = initialPollingDelayMillis;\n        this.maxPollingDelayMillis = maxPollingDelayMillis;\n        this.masterTimeoutMillis = masterTimeoutMillis;\n        this.numTries = 0;\n        this.completed = false;\n    }\n    /**\n     * Poll the provided callback with exponential backoff.\n     *\n     * @param callback - The callback to be called for each poll. If the\n     *     callback resolves to a falsey value, polling will continue. Otherwise, the truthy\n     *     resolution will be used to resolve the promise returned by this method.\n     * @returns A Promise which resolves to the truthy value returned by the provided\n     *     callback when polling is complete.\n     */\n    poll(callback) {\n        if (this.pollCallback) {\n            throw new Error('poll() can only be called once per instance of ExponentialBackoffPoller');\n        }\n        this.pollCallback = callback;\n        this.on('poll', this.repoll);\n        this.masterTimer = setTimeout(() => {\n            if (this.completed) {\n                return;\n            }\n            this.markCompleted();\n            this.reject(new Error('ExponentialBackoffPoller deadline exceeded - Master timeout reached'));\n        }, this.masterTimeoutMillis);\n        return new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n            this.repoll();\n        });\n    }\n    repoll() {\n        this.pollCallback()\n            .then((result) => {\n            if (this.completed) {\n                return;\n            }\n            if (!result) {\n                this.repollTimer =\n                    setTimeout(() => this.emit('poll'), this.getPollingDelayMillis());\n                this.numTries++;\n                return;\n            }\n            this.markCompleted();\n            this.resolve(result);\n        })\n            .catch((err) => {\n            if (this.completed) {\n                return;\n            }\n            this.markCompleted();\n            this.reject(err);\n        });\n    }\n    getPollingDelayMillis() {\n        const increasedPollingDelay = Math.pow(2, this.numTries) * this.initialPollingDelayMillis;\n        return Math.min(increasedPollingDelay, this.maxPollingDelayMillis);\n    }\n    markCompleted() {\n        this.completed = true;\n        if (this.masterTimer) {\n            clearTimeout(this.masterTimer);\n        }\n        if (this.repollTimer) {\n            clearTimeout(this.repollTimer);\n        }\n    }\n}\nexports.ExponentialBackoffPoller = ExponentialBackoffPoller;\nclass Http2SessionHandler {\n    constructor(url) {\n        this.http2Session = this.createSession(url);\n    }\n    createSession(url) {\n        if (!this.http2Session || this.isClosed) {\n            const opts = {\n                // Set local max concurrent stream limit to respect backend limit\n                peerMaxConcurrentStreams: 100,\n                ALPNProtocols: ['h2']\n            };\n            const http2Session = http2.connect(url, opts);\n            http2Session.on('goaway', (errorCode, _, opaqueData) => {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making requests: GOAWAY - ${opaqueData.toString()}, Error code: ${errorCode}`);\n            });\n            http2Session.on('error', (error) => {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making requests: ${error}`);\n            });\n            return http2Session;\n        }\n        return this.http2Session;\n    }\n    get session() {\n        return this.http2Session;\n    }\n    get isClosed() {\n        return this.http2Session.closed;\n    }\n    close() {\n        this.http2Session.close();\n    }\n}\nexports.Http2SessionHandler = Http2SessionHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}