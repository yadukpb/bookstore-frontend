{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.onData = onData;\nconst utils_1 = require(\"../../utils\");\n/**\n * onData is adapted from Node.js' events.on helper\n * https://nodejs.org/api/events.html#eventsonemitter-eventname-options\n *\n * Returns an AsyncIterator that iterates each 'data' event emitted from emitter.\n * It will reject upon an error event.\n */\nfunction onData(emitter) {\n  // Setup pending events and pending promise lists\n  /**\n   * When the caller has not yet called .next(), we store the\n   * value from the event in this list. Next time they call .next()\n   * we pull the first value out of this list and resolve a promise with it.\n   */\n  const unconsumedEvents = new utils_1.List();\n  /**\n   * When there has not yet been an event, a new promise will be created\n   * and implicitly stored in this list. When an event occurs we take the first\n   * promise in this list and resolve it.\n   */\n  const unconsumedPromises = new utils_1.List();\n  /**\n   * Stored an error created by an error event.\n   * This error will turn into a rejection for the subsequent .next() call\n   */\n  let error = null;\n  /** Set to true only after event listeners have been removed. */\n  let finished = false;\n  const iterator = {\n    next() {\n      // First, we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value != null) {\n        return Promise.resolve({\n          value,\n          done: false\n        });\n      }\n      // Then we error, if an error happened\n      // This happens one time if at all, because after 'error'\n      // we stop listening\n      if (error != null) {\n        const p = Promise.reject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n      // If the iterator is finished, resolve to done\n      if (finished) return closeHandler();\n      // Wait until an event happens\n      const {\n        promise,\n        resolve,\n        reject\n      } = (0, utils_1.promiseWithResolvers)();\n      unconsumedPromises.push({\n        resolve,\n        reject\n      });\n      return promise;\n    },\n    return() {\n      return closeHandler();\n    },\n    throw(err) {\n      errorHandler(err);\n      return Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n  // Adding event handlers\n  emitter.on('data', eventHandler);\n  emitter.on('error', errorHandler);\n  return iterator;\n  function eventHandler(value) {\n    const promise = unconsumedPromises.shift();\n    if (promise != null) promise.resolve({\n      value,\n      done: false\n    });else unconsumedEvents.push(value);\n  }\n  function errorHandler(err) {\n    const promise = unconsumedPromises.shift();\n    if (promise != null) promise.reject(err);else error = err;\n    void closeHandler();\n  }\n  function closeHandler() {\n    // Adding event handlers\n    emitter.off('data', eventHandler);\n    emitter.off('error', errorHandler);\n    finished = true;\n    const doneResult = {\n      value: undefined,\n      done: finished\n    };\n    for (const promise of unconsumedPromises) {\n      promise.resolve(doneResult);\n    }\n    return Promise.resolve(doneResult);\n  }\n}","map":{"version":3,"mappings":";;;;;AAoBAA;AAlBA;AAWA;;;;;;;AAOA,SAAgBC,MAAM,CAACC,OAAqB;EAC1C;EACA;;;;;EAKA,MAAMC,gBAAgB,GAAG,IAAIC,YAAI,EAAU;EAC3C;;;;;EAKA,MAAMC,kBAAkB,GAAG,IAAID,YAAI,EAAmB;EAEtD;;;;EAIA,IAAIE,KAAK,GAAiB,IAAI;EAE9B;EACA,IAAIC,QAAQ,GAAG,KAAK;EAEpB,MAAMC,QAAQ,GAA2B;IACvCC,IAAI;MACF;MACA,MAAMC,KAAK,GAAGP,gBAAgB,CAACQ,KAAK,EAAE;MACtC,IAAID,KAAK,IAAI,IAAI,EAAE;QACjB,OAAOE,OAAO,CAACC,OAAO,CAAC;UAAEH,KAAK;UAAEI,IAAI,EAAE;QAAK,CAAE,CAAC;MAChD;MAEA;MACA;MACA;MACA,IAAIR,KAAK,IAAI,IAAI,EAAE;QACjB,MAAMS,CAAC,GAAGH,OAAO,CAACI,MAAM,CAACV,KAAK,CAAC;QAC/B;QACAA,KAAK,GAAG,IAAI;QACZ,OAAOS,CAAC;MACV;MAEA;MACA,IAAIR,QAAQ,EAAE,OAAOU,YAAY,EAAE;MAEnC;MACA,MAAM;QAAEC,OAAO;QAAEL,OAAO;QAAEG;MAAM,CAAE,GAAG,gCAAoB,GAA0B;MACnFX,kBAAkB,CAACc,IAAI,CAAC;QAAEN,OAAO;QAAEG;MAAM,CAAE,CAAC;MAC5C,OAAOE,OAAO;IAChB,CAAC;IAEDE,MAAM;MACJ,OAAOH,YAAY,EAAE;IACvB,CAAC;IAEDI,KAAK,CAACC,GAAU;MACdC,YAAY,CAACD,GAAG,CAAC;MACjB,OAAOV,OAAO,CAACC,OAAO,CAAC;QAAEH,KAAK,EAAEc,SAAS;QAAEV,IAAI,EAAE;MAAI,CAAE,CAAC;IAC1D,CAAC;IAED,CAACW,MAAM,CAACC,aAAa,IAAC;MACpB,OAAO,IAAI;IACb;GACD;EAED;EACAxB,OAAO,CAACyB,EAAE,CAAC,MAAM,EAAEC,YAAY,CAAC;EAChC1B,OAAO,CAACyB,EAAE,CAAC,OAAO,EAAEJ,YAAY,CAAC;EAEjC,OAAOf,QAAQ;EAEf,SAASoB,YAAY,CAAClB,KAAa;IACjC,MAAMQ,OAAO,GAAGb,kBAAkB,CAACM,KAAK,EAAE;IAC1C,IAAIO,OAAO,IAAI,IAAI,EAAEA,OAAO,CAACL,OAAO,CAAC;MAAEH,KAAK;MAAEI,IAAI,EAAE;IAAK,CAAE,CAAC,CAAC,KACxDX,gBAAgB,CAACgB,IAAI,CAACT,KAAK,CAAC;EACnC;EAEA,SAASa,YAAY,CAACD,GAAU;IAC9B,MAAMJ,OAAO,GAAGb,kBAAkB,CAACM,KAAK,EAAE;IAC1C,IAAIO,OAAO,IAAI,IAAI,EAAEA,OAAO,CAACF,MAAM,CAACM,GAAG,CAAC,CAAC,KACpChB,KAAK,GAAGgB,GAAG;IAChB,KAAKL,YAAY,EAAE;EACrB;EAEA,SAASA,YAAY;IACnB;IACAf,OAAO,CAAC2B,GAAG,CAAC,MAAM,EAAED,YAAY,CAAC;IACjC1B,OAAO,CAAC2B,GAAG,CAAC,OAAO,EAAEN,YAAY,CAAC;IAClChB,QAAQ,GAAG,IAAI;IACf,MAAMuB,UAAU,GAAG;MAAEpB,KAAK,EAAEc,SAAS;MAAEV,IAAI,EAAEP;IAAQ,CAAW;IAEhE,KAAK,MAAMW,OAAO,IAAIb,kBAAkB,EAAE;MACxCa,OAAO,CAACL,OAAO,CAACiB,UAAU,CAAC;IAC7B;IAEA,OAAOlB,OAAO,CAACC,OAAO,CAACiB,UAAU,CAAC;EACpC;AACF","names":["exports","onData","emitter","unconsumedEvents","utils_1","unconsumedPromises","error","finished","iterator","next","value","shift","Promise","resolve","done","p","reject","closeHandler","promise","push","return","throw","err","errorHandler","undefined","Symbol","asyncIterator","on","eventHandler","off","doneResult"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/cmap/wire_protocol/on_data.ts"],"sourcesContent":["import { type EventEmitter } from 'events';\n\nimport { List, promiseWithResolvers } from '../../utils';\n\n/**\n * @internal\n * An object holding references to a promise's resolve and reject functions.\n */\ntype PendingPromises = Omit<\n  ReturnType<typeof promiseWithResolvers<IteratorResult<Buffer>>>,\n  'promise'\n>;\n\n/**\n * onData is adapted from Node.js' events.on helper\n * https://nodejs.org/api/events.html#eventsonemitter-eventname-options\n *\n * Returns an AsyncIterator that iterates each 'data' event emitted from emitter.\n * It will reject upon an error event.\n */\nexport function onData(emitter: EventEmitter) {\n  // Setup pending events and pending promise lists\n  /**\n   * When the caller has not yet called .next(), we store the\n   * value from the event in this list. Next time they call .next()\n   * we pull the first value out of this list and resolve a promise with it.\n   */\n  const unconsumedEvents = new List<Buffer>();\n  /**\n   * When there has not yet been an event, a new promise will be created\n   * and implicitly stored in this list. When an event occurs we take the first\n   * promise in this list and resolve it.\n   */\n  const unconsumedPromises = new List<PendingPromises>();\n\n  /**\n   * Stored an error created by an error event.\n   * This error will turn into a rejection for the subsequent .next() call\n   */\n  let error: Error | null = null;\n\n  /** Set to true only after event listeners have been removed. */\n  let finished = false;\n\n  const iterator: AsyncGenerator<Buffer> = {\n    next() {\n      // First, we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value != null) {\n        return Promise.resolve({ value, done: false });\n      }\n\n      // Then we error, if an error happened\n      // This happens one time if at all, because after 'error'\n      // we stop listening\n      if (error != null) {\n        const p = Promise.reject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished, resolve to done\n      if (finished) return closeHandler();\n\n      // Wait until an event happens\n      const { promise, resolve, reject } = promiseWithResolvers<IteratorResult<Buffer>>();\n      unconsumedPromises.push({ resolve, reject });\n      return promise;\n    },\n\n    return() {\n      return closeHandler();\n    },\n\n    throw(err: Error) {\n      errorHandler(err);\n      return Promise.resolve({ value: undefined, done: true });\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n\n  // Adding event handlers\n  emitter.on('data', eventHandler);\n  emitter.on('error', errorHandler);\n\n  return iterator;\n\n  function eventHandler(value: Buffer) {\n    const promise = unconsumedPromises.shift();\n    if (promise != null) promise.resolve({ value, done: false });\n    else unconsumedEvents.push(value);\n  }\n\n  function errorHandler(err: Error) {\n    const promise = unconsumedPromises.shift();\n    if (promise != null) promise.reject(err);\n    else error = err;\n    void closeHandler();\n  }\n\n  function closeHandler() {\n    // Adding event handlers\n    emitter.off('data', eventHandler);\n    emitter.off('error', errorHandler);\n    finished = true;\n    const doneResult = { value: undefined, done: finished } as const;\n\n    for (const promise of unconsumedPromises) {\n      promise.resolve(doneResult);\n    }\n\n    return Promise.resolve(doneResult);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}