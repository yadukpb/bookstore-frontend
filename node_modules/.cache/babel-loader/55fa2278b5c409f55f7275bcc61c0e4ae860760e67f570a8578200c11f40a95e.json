{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HumanCallbackWorkflow = void 0;\nconst bson_1 = require(\"../../../bson\");\nconst error_1 = require(\"../../../error\");\nconst timeout_1 = require(\"../../../timeout\");\nconst mongodb_oidc_1 = require(\"../mongodb_oidc\");\nconst callback_workflow_1 = require(\"./callback_workflow\");\n/**\n * Class implementing behaviour for the non human callback workflow.\n * @internal\n */\nclass HumanCallbackWorkflow extends callback_workflow_1.CallbackWorkflow {\n  /**\n   * Instantiate the human callback workflow.\n   */\n  constructor(cache, callback) {\n    super(cache, callback);\n  }\n  /**\n   * Execute the OIDC human callback workflow.\n   */\n  async execute(connection, credentials) {\n    // Check if the Client Cache has an access token.\n    // If it does, cache the access token in the Connection Cache and perform a One-Step SASL conversation\n    // using the access token. If the server returns an Authentication error (18),\n    // invalidate the access token token from the Client Cache, clear the Connection Cache,\n    // and restart the authentication flow. Raise any other errors to the user. On success, exit the algorithm.\n    if (this.cache.hasAccessToken) {\n      const token = this.cache.getAccessToken();\n      connection.accessToken = token;\n      try {\n        return await this.finishAuthentication(connection, credentials, token);\n      } catch (error) {\n        if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {\n          this.cache.removeAccessToken();\n          delete connection.accessToken;\n          return await this.execute(connection, credentials);\n        } else {\n          throw error;\n        }\n      }\n    }\n    // Check if the Client Cache has a refresh token.\n    // If it does, call the OIDC Human Callback with the cached refresh token and IdpInfo to get a\n    // new access token. Cache the new access token in the Client Cache and Connection Cache.\n    // Perform a One-Step SASL conversation using the new access token. If the the server returns\n    // an Authentication error (18), clear the refresh token, invalidate the access token from the\n    // Client Cache, clear the Connection Cache, and restart the authentication flow. Raise any other\n    // errors to the user. On success, exit the algorithm.\n    if (this.cache.hasRefreshToken) {\n      const refreshToken = this.cache.getRefreshToken();\n      const result = await this.fetchAccessToken(this.cache.getIdpInfo(), credentials, refreshToken);\n      this.cache.put(result);\n      connection.accessToken = result.accessToken;\n      try {\n        return await this.finishAuthentication(connection, credentials, result.accessToken);\n      } catch (error) {\n        if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.AuthenticationFailed) {\n          this.cache.removeRefreshToken();\n          delete connection.accessToken;\n          return await this.execute(connection, credentials);\n        } else {\n          throw error;\n        }\n      }\n    }\n    // Start a new Two-Step SASL conversation.\n    // Run a PrincipalStepRequest to get the IdpInfo.\n    // Call the OIDC Human Callback with the new IdpInfo to get a new access token and optional refresh\n    // token. Drivers MUST NOT pass a cached refresh token to the callback when performing\n    // a new Two-Step conversation. Cache the new IdpInfo and refresh token in the Client Cache and the\n    // new access token in the Client Cache and Connection Cache.\n    // Attempt to authenticate using a JwtStepRequest with the new access token. Raise any errors to the user.\n    const startResponse = await this.startAuthentication(connection, credentials);\n    const conversationId = startResponse.conversationId;\n    const idpInfo = bson_1.BSON.deserialize(startResponse.payload.buffer);\n    const callbackResponse = await this.fetchAccessToken(idpInfo, credentials);\n    this.cache.put(callbackResponse, idpInfo);\n    connection.accessToken = callbackResponse.accessToken;\n    return await this.finishAuthentication(connection, credentials, callbackResponse.accessToken, conversationId);\n  }\n  /**\n   * Fetches an access token using the callback.\n   */\n  async fetchAccessToken(idpInfo, credentials, refreshToken) {\n    const controller = new AbortController();\n    const params = {\n      timeoutContext: controller.signal,\n      version: mongodb_oidc_1.OIDC_VERSION,\n      idpInfo: idpInfo\n    };\n    if (credentials.username) {\n      params.username = credentials.username;\n    }\n    if (refreshToken) {\n      params.refreshToken = refreshToken;\n    }\n    const timeout = timeout_1.Timeout.expires(callback_workflow_1.HUMAN_TIMEOUT_MS);\n    try {\n      return await Promise.race([this.executeAndValidateCallback(params), timeout]);\n    } catch (error) {\n      if (timeout_1.TimeoutError.is(error)) {\n        controller.abort();\n        throw new error_1.MongoOIDCError(`OIDC callback timed out after ${callback_workflow_1.HUMAN_TIMEOUT_MS}ms.`);\n      }\n      throw error;\n    } finally {\n      timeout.clear();\n    }\n  }\n}\nexports.HumanCallbackWorkflow = HumanCallbackWorkflow;","map":{"version":3,"mappings":"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","names":["HumanCallbackWorkflow","callback_workflow_1","constructor","cache","callback","execute","connection","credentials","hasAccessToken","token","getAccessToken","accessToken","finishAuthentication","error","error_1","code","AuthenticationFailed","removeAccessToken","hasRefreshToken","refreshToken","getRefreshToken","result","fetchAccessToken","getIdpInfo","put","removeRefreshToken","startResponse","startAuthentication","conversationId","idpInfo","bson_1","deserialize","payload","buffer","callbackResponse","controller","AbortController","params","timeoutContext","signal","version","mongodb_oidc_1","username","timeout","timeout_1","expires","Promise","race","executeAndValidateCallback","is","abort","clear","exports"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/cmap/auth/mongodb_oidc/human_callback_workflow.ts"],"sourcesContent":["import { BSON } from '../../../bson';\nimport { MONGODB_ERROR_CODES, MongoError, MongoOIDCError } from '../../../error';\nimport { Timeout, TimeoutError } from '../../../timeout';\nimport { type Connection } from '../../connection';\nimport { type MongoCredentials } from '../mongo_credentials';\nimport {\n  type IdPInfo,\n  OIDC_VERSION,\n  type OIDCCallbackFunction,\n  type OIDCCallbackParams,\n  type OIDCResponse\n} from '../mongodb_oidc';\nimport { CallbackWorkflow, HUMAN_TIMEOUT_MS } from './callback_workflow';\nimport { type TokenCache } from './token_cache';\n\n/**\n * Class implementing behaviour for the non human callback workflow.\n * @internal\n */\nexport class HumanCallbackWorkflow extends CallbackWorkflow {\n  /**\n   * Instantiate the human callback workflow.\n   */\n  constructor(cache: TokenCache, callback: OIDCCallbackFunction) {\n    super(cache, callback);\n  }\n\n  /**\n   * Execute the OIDC human callback workflow.\n   */\n  async execute(connection: Connection, credentials: MongoCredentials): Promise<void> {\n    // Check if the Client Cache has an access token.\n    // If it does, cache the access token in the Connection Cache and perform a One-Step SASL conversation\n    // using the access token. If the server returns an Authentication error (18),\n    // invalidate the access token token from the Client Cache, clear the Connection Cache,\n    // and restart the authentication flow. Raise any other errors to the user. On success, exit the algorithm.\n    if (this.cache.hasAccessToken) {\n      const token = this.cache.getAccessToken();\n      connection.accessToken = token;\n      try {\n        return await this.finishAuthentication(connection, credentials, token);\n      } catch (error) {\n        if (\n          error instanceof MongoError &&\n          error.code === MONGODB_ERROR_CODES.AuthenticationFailed\n        ) {\n          this.cache.removeAccessToken();\n          delete connection.accessToken;\n          return await this.execute(connection, credentials);\n        } else {\n          throw error;\n        }\n      }\n    }\n    // Check if the Client Cache has a refresh token.\n    // If it does, call the OIDC Human Callback with the cached refresh token and IdpInfo to get a\n    // new access token. Cache the new access token in the Client Cache and Connection Cache.\n    // Perform a One-Step SASL conversation using the new access token. If the the server returns\n    // an Authentication error (18), clear the refresh token, invalidate the access token from the\n    // Client Cache, clear the Connection Cache, and restart the authentication flow. Raise any other\n    // errors to the user. On success, exit the algorithm.\n    if (this.cache.hasRefreshToken) {\n      const refreshToken = this.cache.getRefreshToken();\n      const result = await this.fetchAccessToken(\n        this.cache.getIdpInfo(),\n        credentials,\n        refreshToken\n      );\n      this.cache.put(result);\n      connection.accessToken = result.accessToken;\n      try {\n        return await this.finishAuthentication(connection, credentials, result.accessToken);\n      } catch (error) {\n        if (\n          error instanceof MongoError &&\n          error.code === MONGODB_ERROR_CODES.AuthenticationFailed\n        ) {\n          this.cache.removeRefreshToken();\n          delete connection.accessToken;\n          return await this.execute(connection, credentials);\n        } else {\n          throw error;\n        }\n      }\n    }\n\n    // Start a new Two-Step SASL conversation.\n    // Run a PrincipalStepRequest to get the IdpInfo.\n    // Call the OIDC Human Callback with the new IdpInfo to get a new access token and optional refresh\n    // token. Drivers MUST NOT pass a cached refresh token to the callback when performing\n    // a new Two-Step conversation. Cache the new IdpInfo and refresh token in the Client Cache and the\n    // new access token in the Client Cache and Connection Cache.\n    // Attempt to authenticate using a JwtStepRequest with the new access token. Raise any errors to the user.\n    const startResponse = await this.startAuthentication(connection, credentials);\n    const conversationId = startResponse.conversationId;\n    const idpInfo = BSON.deserialize(startResponse.payload.buffer) as IdPInfo;\n    const callbackResponse = await this.fetchAccessToken(idpInfo, credentials);\n    this.cache.put(callbackResponse, idpInfo);\n    connection.accessToken = callbackResponse.accessToken;\n    return await this.finishAuthentication(\n      connection,\n      credentials,\n      callbackResponse.accessToken,\n      conversationId\n    );\n  }\n\n  /**\n   * Fetches an access token using the callback.\n   */\n  private async fetchAccessToken(\n    idpInfo: IdPInfo,\n    credentials: MongoCredentials,\n    refreshToken?: string\n  ): Promise<OIDCResponse> {\n    const controller = new AbortController();\n    const params: OIDCCallbackParams = {\n      timeoutContext: controller.signal,\n      version: OIDC_VERSION,\n      idpInfo: idpInfo\n    };\n    if (credentials.username) {\n      params.username = credentials.username;\n    }\n    if (refreshToken) {\n      params.refreshToken = refreshToken;\n    }\n    const timeout = Timeout.expires(HUMAN_TIMEOUT_MS);\n    try {\n      return await Promise.race([this.executeAndValidateCallback(params), timeout]);\n    } catch (error) {\n      if (TimeoutError.is(error)) {\n        controller.abort();\n        throw new MongoOIDCError(`OIDC callback timed out after ${HUMAN_TIMEOUT_MS}ms.`);\n      }\n      throw error;\n    } finally {\n      timeout.clear();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}