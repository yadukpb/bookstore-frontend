{"ast":null,"code":"/*! firebase-admin v12.7.0 */\n\"use strict\";\n\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FirebaseRemoteConfigError = exports.RemoteConfigApiClient = void 0;\nconst api_request_1 = require(\"../utils/api-request\");\nconst error_1 = require(\"../utils/error\");\nconst utils = require(\"../utils/index\");\nconst validator = require(\"../utils/validator\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\n// Remote Config backend constants\n/**\n  * Allows the `FIREBASE_REMOTE_CONFIG_URL_BASE` environment\n  * variable to override the default API endpoint URL.\n  */\nconst FIREBASE_REMOTE_CONFIG_URL_BASE = process.env.FIREBASE_REMOTE_CONFIG_URL_BASE || 'https://firebaseremoteconfig.googleapis.com';\nconst FIREBASE_REMOTE_CONFIG_HEADERS = {\n  'X-Firebase-Client': `fire-admin-node/${utils.getSdkVersion()}`,\n  // There is a known issue in which the ETag is not properly returned in cases where the request\n  // does not specify a compression type. Currently, it is required to include the header\n  // `Accept-Encoding: gzip` or equivalent in all requests.\n  // https://firebase.google.com/docs/remote-config/use-config-rest#etag_usage_and_forced_updates\n  'Accept-Encoding': 'gzip'\n};\n/**\n * Class that facilitates sending requests to the Firebase Remote Config backend API.\n *\n * @internal\n */\nclass RemoteConfigApiClient {\n  constructor(app) {\n    this.app = app;\n    if (!validator.isNonNullObject(app) || !('options' in app)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'First argument passed to admin.remoteConfig() must be a valid Firebase app instance.');\n    }\n    this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n  }\n  getTemplate() {\n    return this.getUrl().then(url => {\n      const request = {\n        method: 'GET',\n        url: `${url}/remoteConfig`,\n        headers: FIREBASE_REMOTE_CONFIG_HEADERS\n      };\n      return this.httpClient.send(request);\n    }).then(resp => {\n      return this.toRemoteConfigTemplate(resp);\n    }).catch(err => {\n      throw this.toFirebaseError(err);\n    });\n  }\n  getTemplateAtVersion(versionNumber) {\n    const data = {\n      versionNumber: this.validateVersionNumber(versionNumber)\n    };\n    return this.getUrl().then(url => {\n      const request = {\n        method: 'GET',\n        url: `${url}/remoteConfig`,\n        headers: FIREBASE_REMOTE_CONFIG_HEADERS,\n        data\n      };\n      return this.httpClient.send(request);\n    }).then(resp => {\n      return this.toRemoteConfigTemplate(resp);\n    }).catch(err => {\n      throw this.toFirebaseError(err);\n    });\n  }\n  validateTemplate(template) {\n    template = this.validateInputRemoteConfigTemplate(template);\n    return this.sendPutRequest(template, template.etag, true).then(resp => {\n      // validating a template returns an etag with the suffix -0 means that your update\n      // was successfully validated. We set the etag back to the original etag of the template\n      // to allow future operations.\n      this.validateEtag(resp.headers['etag']);\n      return this.toRemoteConfigTemplate(resp, template.etag);\n    }).catch(err => {\n      throw this.toFirebaseError(err);\n    });\n  }\n  publishTemplate(template, options) {\n    template = this.validateInputRemoteConfigTemplate(template);\n    let ifMatch = template.etag;\n    if (options && options.force === true) {\n      // setting `If-Match: *` forces the Remote Config template to be updated\n      // and circumvent the ETag, and the protection from that it provides.\n      ifMatch = '*';\n    }\n    return this.sendPutRequest(template, ifMatch).then(resp => {\n      return this.toRemoteConfigTemplate(resp);\n    }).catch(err => {\n      throw this.toFirebaseError(err);\n    });\n  }\n  rollback(versionNumber) {\n    const data = {\n      versionNumber: this.validateVersionNumber(versionNumber)\n    };\n    return this.getUrl().then(url => {\n      const request = {\n        method: 'POST',\n        url: `${url}/remoteConfig:rollback`,\n        headers: FIREBASE_REMOTE_CONFIG_HEADERS,\n        data\n      };\n      return this.httpClient.send(request);\n    }).then(resp => {\n      return this.toRemoteConfigTemplate(resp);\n    }).catch(err => {\n      throw this.toFirebaseError(err);\n    });\n  }\n  listVersions(options) {\n    if (typeof options !== 'undefined') {\n      options = this.validateListVersionsOptions(options);\n    }\n    return this.getUrl().then(url => {\n      const request = {\n        method: 'GET',\n        url: `${url}/remoteConfig:listVersions`,\n        headers: FIREBASE_REMOTE_CONFIG_HEADERS,\n        data: options\n      };\n      return this.httpClient.send(request);\n    }).then(resp => {\n      return resp.data;\n    }).catch(err => {\n      throw this.toFirebaseError(err);\n    });\n  }\n  getServerTemplate() {\n    return this.getUrl().then(url => {\n      const request = {\n        method: 'GET',\n        url: `${url}/namespaces/firebase-server/serverRemoteConfig`,\n        headers: FIREBASE_REMOTE_CONFIG_HEADERS\n      };\n      return this.httpClient.send(request);\n    }).then(resp => {\n      return this.toRemoteConfigServerTemplate(resp);\n    }).catch(err => {\n      throw this.toFirebaseError(err);\n    });\n  }\n  sendPutRequest(template, etag, validateOnly) {\n    let path = 'remoteConfig';\n    if (validateOnly) {\n      path += '?validate_only=true';\n    }\n    return this.getUrl().then(url => {\n      const request = {\n        method: 'PUT',\n        url: `${url}/${path}`,\n        headers: {\n          ...FIREBASE_REMOTE_CONFIG_HEADERS,\n          'If-Match': etag\n        },\n        data: {\n          conditions: template.conditions,\n          parameters: template.parameters,\n          parameterGroups: template.parameterGroups,\n          version: template.version\n        }\n      };\n      return this.httpClient.send(request);\n    });\n  }\n  getUrl() {\n    return this.getProjectIdPrefix().then(projectIdPrefix => {\n      return `${FIREBASE_REMOTE_CONFIG_URL_BASE}/v1/${projectIdPrefix}`;\n    });\n  }\n  getProjectIdPrefix() {\n    if (this.projectIdPrefix) {\n      return Promise.resolve(this.projectIdPrefix);\n    }\n    return utils.findProjectId(this.app).then(projectId => {\n      if (!validator.isNonEmptyString(projectId)) {\n        throw new FirebaseRemoteConfigError('unknown-error', 'Failed to determine project ID. Initialize the SDK with service account credentials, or ' + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT ' + 'environment variable.');\n      }\n      this.projectIdPrefix = `projects/${projectId}`;\n      return this.projectIdPrefix;\n    });\n  }\n  toFirebaseError(err) {\n    if (err instanceof error_1.PrefixedFirebaseError) {\n      return err;\n    }\n    const response = err.response;\n    if (!response.isJson()) {\n      return new FirebaseRemoteConfigError('unknown-error', `Unexpected response with status: ${response.status} and body: ${response.text}`);\n    }\n    const error = response.data.error || {};\n    let code = 'unknown-error';\n    if (error.status && error.status in ERROR_CODE_MAPPING) {\n      code = ERROR_CODE_MAPPING[error.status];\n    }\n    const message = error.message || `Unknown server error: ${response.text}`;\n    return new FirebaseRemoteConfigError(code, message);\n  }\n  /**\n   * Creates a RemoteConfigTemplate from the API response.\n   * If provided, customEtag is used instead of the etag returned in the API response.\n   *\n   * @param {HttpResponse} resp API response object.\n   * @param {string} customEtag A custom etag to replace the etag fom the API response (Optional).\n   */\n  toRemoteConfigTemplate(resp, customEtag) {\n    const etag = typeof customEtag === 'undefined' ? resp.headers['etag'] : customEtag;\n    this.validateEtag(etag);\n    return {\n      conditions: resp.data.conditions,\n      parameters: resp.data.parameters,\n      parameterGroups: resp.data.parameterGroups,\n      etag,\n      version: resp.data.version\n    };\n  }\n  /**\n   * Creates a RemoteConfigServerTemplate from the API response.\n   * If provided, customEtag is used instead of the etag returned in the API response.\n   *\n   * @param {HttpResponse} resp API response object.\n   * @param {string} customEtag A custom etag to replace the etag fom the API response (Optional).\n   */\n  toRemoteConfigServerTemplate(resp, customEtag) {\n    const etag = typeof customEtag === 'undefined' ? resp.headers['etag'] : customEtag;\n    this.validateEtag(etag);\n    return {\n      conditions: resp.data.conditions,\n      parameters: resp.data.parameters,\n      etag,\n      version: resp.data.version\n    };\n  }\n  /**\n   * Checks if the given RemoteConfigTemplate object is valid.\n   * The object must have valid parameters, parameter groups, conditions, and an etag.\n   * Removes output only properties from version metadata.\n   *\n   * @param {RemoteConfigTemplate} template A RemoteConfigTemplate object to be validated.\n   *\n   * @returns {RemoteConfigTemplate} The validated RemoteConfigTemplate object.\n   */\n  validateInputRemoteConfigTemplate(template) {\n    const templateCopy = (0, deep_copy_1.deepCopy)(template);\n    if (!validator.isNonNullObject(templateCopy)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', `Invalid Remote Config template: ${JSON.stringify(templateCopy)}`);\n    }\n    if (!validator.isNonEmptyString(templateCopy.etag)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'ETag must be a non-empty string.');\n    }\n    if (!validator.isNonNullObject(templateCopy.parameters)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');\n    }\n    if (!validator.isNonNullObject(templateCopy.parameterGroups)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameter groups must be a non-null object');\n    }\n    if (!validator.isArray(templateCopy.conditions)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');\n    }\n    if (typeof templateCopy.version !== 'undefined') {\n      // exclude output only properties and keep the only input property: description\n      templateCopy.version = {\n        description: templateCopy.version.description\n      };\n    }\n    return templateCopy;\n  }\n  /**\n   * Checks if a given version number is valid.\n   * A version number must be an integer or a string in int64 format.\n   * If valid, returns the string representation of the provided version number.\n   *\n   * @param {string|number} versionNumber A version number to be validated.\n   *\n   * @returns {string} The validated version number as a string.\n   */\n  validateVersionNumber(versionNumber) {\n    let propertyName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'versionNumber';\n    if (!validator.isNonEmptyString(versionNumber) && !validator.isNumber(versionNumber)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', `${propertyName} must be a non-empty string in int64 format or a number`);\n    }\n    if (!Number.isInteger(Number(versionNumber))) {\n      throw new FirebaseRemoteConfigError('invalid-argument', `${propertyName} must be an integer or a string in int64 format`);\n    }\n    return versionNumber.toString();\n  }\n  validateEtag(etag) {\n    if (!validator.isNonEmptyString(etag)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'ETag header is not present in the server response.');\n    }\n  }\n  /**\n   * Checks if a given `ListVersionsOptions` object is valid. If successful, creates a copy of the\n   * options object and convert `startTime` and `endTime` to RFC3339 UTC \"Zulu\" format, if present.\n   *\n   * @param {ListVersionsOptions} options An options object to be validated.\n   *\n   * @returns {ListVersionsOptions} A copy of the provided options object with timestamps converted\n   * to UTC Zulu format.\n   */\n  validateListVersionsOptions(options) {\n    const optionsCopy = (0, deep_copy_1.deepCopy)(options);\n    if (!validator.isNonNullObject(optionsCopy)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'ListVersionsOptions must be a non-null object.');\n    }\n    if (typeof optionsCopy.pageSize !== 'undefined') {\n      if (!validator.isNumber(optionsCopy.pageSize)) {\n        throw new FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number.');\n      }\n      if (optionsCopy.pageSize < 1 || optionsCopy.pageSize > 300) {\n        throw new FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number between 1 and 300 (inclusive).');\n      }\n    }\n    if (typeof optionsCopy.pageToken !== 'undefined' && !validator.isNonEmptyString(optionsCopy.pageToken)) {\n      throw new FirebaseRemoteConfigError('invalid-argument', 'pageToken must be a string value.');\n    }\n    if (typeof optionsCopy.endVersionNumber !== 'undefined') {\n      optionsCopy.endVersionNumber = this.validateVersionNumber(optionsCopy.endVersionNumber, 'endVersionNumber');\n    }\n    if (typeof optionsCopy.startTime !== 'undefined') {\n      if (!(optionsCopy.startTime instanceof Date) && !validator.isUTCDateString(optionsCopy.startTime)) {\n        throw new FirebaseRemoteConfigError('invalid-argument', 'startTime must be a valid Date object or a UTC date string.');\n      }\n      // Convert startTime to RFC3339 UTC \"Zulu\" format.\n      if (optionsCopy.startTime instanceof Date) {\n        optionsCopy.startTime = optionsCopy.startTime.toISOString();\n      } else {\n        optionsCopy.startTime = new Date(optionsCopy.startTime).toISOString();\n      }\n    }\n    if (typeof optionsCopy.endTime !== 'undefined') {\n      if (!(optionsCopy.endTime instanceof Date) && !validator.isUTCDateString(optionsCopy.endTime)) {\n        throw new FirebaseRemoteConfigError('invalid-argument', 'endTime must be a valid Date object or a UTC date string.');\n      }\n      // Convert endTime to RFC3339 UTC \"Zulu\" format.\n      if (optionsCopy.endTime instanceof Date) {\n        optionsCopy.endTime = optionsCopy.endTime.toISOString();\n      } else {\n        optionsCopy.endTime = new Date(optionsCopy.endTime).toISOString();\n      }\n    }\n    // Remove undefined fields from optionsCopy\n    Object.keys(optionsCopy).forEach(key => typeof optionsCopy[key] === 'undefined' && delete optionsCopy[key]);\n    return optionsCopy;\n  }\n}\nexports.RemoteConfigApiClient = RemoteConfigApiClient;\nconst ERROR_CODE_MAPPING = {\n  ABORTED: 'aborted',\n  ALREADY_EXISTS: 'already-exists',\n  INVALID_ARGUMENT: 'invalid-argument',\n  INTERNAL: 'internal-error',\n  FAILED_PRECONDITION: 'failed-precondition',\n  NOT_FOUND: 'not-found',\n  OUT_OF_RANGE: 'out-of-range',\n  PERMISSION_DENIED: 'permission-denied',\n  RESOURCE_EXHAUSTED: 'resource-exhausted',\n  UNAUTHENTICATED: 'unauthenticated',\n  UNKNOWN: 'unknown-error'\n};\n/**\n * Firebase Remote Config error code structure. This extends PrefixedFirebaseError.\n *\n * @param {RemoteConfigErrorCode} code The error code.\n * @param {string} message The error message.\n * @constructor\n */\nclass FirebaseRemoteConfigError extends error_1.PrefixedFirebaseError {\n  constructor(code, message) {\n    super('remote-config', code, message);\n  }\n}\nexports.FirebaseRemoteConfigError = FirebaseRemoteConfigError;","map":{"version":3,"names":["Object","defineProperty","exports","value","FirebaseRemoteConfigError","RemoteConfigApiClient","api_request_1","require","error_1","utils","validator","deep_copy_1","FIREBASE_REMOTE_CONFIG_URL_BASE","process","env","FIREBASE_REMOTE_CONFIG_HEADERS","getSdkVersion","constructor","app","isNonNullObject","httpClient","AuthorizedHttpClient","getTemplate","getUrl","then","url","request","method","headers","send","resp","toRemoteConfigTemplate","catch","err","toFirebaseError","getTemplateAtVersion","versionNumber","data","validateVersionNumber","validateTemplate","template","validateInputRemoteConfigTemplate","sendPutRequest","etag","validateEtag","publishTemplate","options","ifMatch","force","rollback","listVersions","validateListVersionsOptions","getServerTemplate","toRemoteConfigServerTemplate","validateOnly","path","conditions","parameters","parameterGroups","version","getProjectIdPrefix","projectIdPrefix","Promise","resolve","findProjectId","projectId","isNonEmptyString","PrefixedFirebaseError","response","isJson","status","text","error","code","ERROR_CODE_MAPPING","message","customEtag","templateCopy","deepCopy","JSON","stringify","isArray","description","propertyName","isNumber","Number","isInteger","toString","optionsCopy","pageSize","pageToken","endVersionNumber","startTime","Date","isUTCDateString","toISOString","endTime","keys","forEach","key","ABORTED","ALREADY_EXISTS","INVALID_ARGUMENT","INTERNAL","FAILED_PRECONDITION","NOT_FOUND","OUT_OF_RANGE","PERMISSION_DENIED","RESOURCE_EXHAUSTED","UNAUTHENTICATED","UNKNOWN"],"sources":["/home/yadu/Music/Gifty/node_modules/firebase-admin/lib/remote-config/remote-config-api-client-internal.js"],"sourcesContent":["/*! firebase-admin v12.7.0 */\n\"use strict\";\n/*!\n * Copyright 2020 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FirebaseRemoteConfigError = exports.RemoteConfigApiClient = void 0;\nconst api_request_1 = require(\"../utils/api-request\");\nconst error_1 = require(\"../utils/error\");\nconst utils = require(\"../utils/index\");\nconst validator = require(\"../utils/validator\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\n// Remote Config backend constants\n/**\n  * Allows the `FIREBASE_REMOTE_CONFIG_URL_BASE` environment\n  * variable to override the default API endpoint URL.\n  */\nconst FIREBASE_REMOTE_CONFIG_URL_BASE = process.env.FIREBASE_REMOTE_CONFIG_URL_BASE || 'https://firebaseremoteconfig.googleapis.com';\nconst FIREBASE_REMOTE_CONFIG_HEADERS = {\n    'X-Firebase-Client': `fire-admin-node/${utils.getSdkVersion()}`,\n    // There is a known issue in which the ETag is not properly returned in cases where the request\n    // does not specify a compression type. Currently, it is required to include the header\n    // `Accept-Encoding: gzip` or equivalent in all requests.\n    // https://firebase.google.com/docs/remote-config/use-config-rest#etag_usage_and_forced_updates\n    'Accept-Encoding': 'gzip',\n};\n/**\n * Class that facilitates sending requests to the Firebase Remote Config backend API.\n *\n * @internal\n */\nclass RemoteConfigApiClient {\n    constructor(app) {\n        this.app = app;\n        if (!validator.isNonNullObject(app) || !('options' in app)) {\n            throw new FirebaseRemoteConfigError('invalid-argument', 'First argument passed to admin.remoteConfig() must be a valid Firebase app instance.');\n        }\n        this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n    }\n    getTemplate() {\n        return this.getUrl()\n            .then((url) => {\n            const request = {\n                method: 'GET',\n                url: `${url}/remoteConfig`,\n                headers: FIREBASE_REMOTE_CONFIG_HEADERS\n            };\n            return this.httpClient.send(request);\n        })\n            .then((resp) => {\n            return this.toRemoteConfigTemplate(resp);\n        })\n            .catch((err) => {\n            throw this.toFirebaseError(err);\n        });\n    }\n    getTemplateAtVersion(versionNumber) {\n        const data = { versionNumber: this.validateVersionNumber(versionNumber) };\n        return this.getUrl()\n            .then((url) => {\n            const request = {\n                method: 'GET',\n                url: `${url}/remoteConfig`,\n                headers: FIREBASE_REMOTE_CONFIG_HEADERS,\n                data\n            };\n            return this.httpClient.send(request);\n        })\n            .then((resp) => {\n            return this.toRemoteConfigTemplate(resp);\n        })\n            .catch((err) => {\n            throw this.toFirebaseError(err);\n        });\n    }\n    validateTemplate(template) {\n        template = this.validateInputRemoteConfigTemplate(template);\n        return this.sendPutRequest(template, template.etag, true)\n            .then((resp) => {\n            // validating a template returns an etag with the suffix -0 means that your update\n            // was successfully validated. We set the etag back to the original etag of the template\n            // to allow future operations.\n            this.validateEtag(resp.headers['etag']);\n            return this.toRemoteConfigTemplate(resp, template.etag);\n        })\n            .catch((err) => {\n            throw this.toFirebaseError(err);\n        });\n    }\n    publishTemplate(template, options) {\n        template = this.validateInputRemoteConfigTemplate(template);\n        let ifMatch = template.etag;\n        if (options && options.force === true) {\n            // setting `If-Match: *` forces the Remote Config template to be updated\n            // and circumvent the ETag, and the protection from that it provides.\n            ifMatch = '*';\n        }\n        return this.sendPutRequest(template, ifMatch)\n            .then((resp) => {\n            return this.toRemoteConfigTemplate(resp);\n        })\n            .catch((err) => {\n            throw this.toFirebaseError(err);\n        });\n    }\n    rollback(versionNumber) {\n        const data = { versionNumber: this.validateVersionNumber(versionNumber) };\n        return this.getUrl()\n            .then((url) => {\n            const request = {\n                method: 'POST',\n                url: `${url}/remoteConfig:rollback`,\n                headers: FIREBASE_REMOTE_CONFIG_HEADERS,\n                data\n            };\n            return this.httpClient.send(request);\n        })\n            .then((resp) => {\n            return this.toRemoteConfigTemplate(resp);\n        })\n            .catch((err) => {\n            throw this.toFirebaseError(err);\n        });\n    }\n    listVersions(options) {\n        if (typeof options !== 'undefined') {\n            options = this.validateListVersionsOptions(options);\n        }\n        return this.getUrl()\n            .then((url) => {\n            const request = {\n                method: 'GET',\n                url: `${url}/remoteConfig:listVersions`,\n                headers: FIREBASE_REMOTE_CONFIG_HEADERS,\n                data: options\n            };\n            return this.httpClient.send(request);\n        })\n            .then((resp) => {\n            return resp.data;\n        })\n            .catch((err) => {\n            throw this.toFirebaseError(err);\n        });\n    }\n    getServerTemplate() {\n        return this.getUrl()\n            .then((url) => {\n            const request = {\n                method: 'GET',\n                url: `${url}/namespaces/firebase-server/serverRemoteConfig`,\n                headers: FIREBASE_REMOTE_CONFIG_HEADERS\n            };\n            return this.httpClient.send(request);\n        })\n            .then((resp) => {\n            return this.toRemoteConfigServerTemplate(resp);\n        })\n            .catch((err) => {\n            throw this.toFirebaseError(err);\n        });\n    }\n    sendPutRequest(template, etag, validateOnly) {\n        let path = 'remoteConfig';\n        if (validateOnly) {\n            path += '?validate_only=true';\n        }\n        return this.getUrl()\n            .then((url) => {\n            const request = {\n                method: 'PUT',\n                url: `${url}/${path}`,\n                headers: { ...FIREBASE_REMOTE_CONFIG_HEADERS, 'If-Match': etag },\n                data: {\n                    conditions: template.conditions,\n                    parameters: template.parameters,\n                    parameterGroups: template.parameterGroups,\n                    version: template.version,\n                }\n            };\n            return this.httpClient.send(request);\n        });\n    }\n    getUrl() {\n        return this.getProjectIdPrefix()\n            .then((projectIdPrefix) => {\n            return `${FIREBASE_REMOTE_CONFIG_URL_BASE}/v1/${projectIdPrefix}`;\n        });\n    }\n    getProjectIdPrefix() {\n        if (this.projectIdPrefix) {\n            return Promise.resolve(this.projectIdPrefix);\n        }\n        return utils.findProjectId(this.app)\n            .then((projectId) => {\n            if (!validator.isNonEmptyString(projectId)) {\n                throw new FirebaseRemoteConfigError('unknown-error', 'Failed to determine project ID. Initialize the SDK with service account credentials, or '\n                    + 'set project ID as an app option. Alternatively, set the GOOGLE_CLOUD_PROJECT '\n                    + 'environment variable.');\n            }\n            this.projectIdPrefix = `projects/${projectId}`;\n            return this.projectIdPrefix;\n        });\n    }\n    toFirebaseError(err) {\n        if (err instanceof error_1.PrefixedFirebaseError) {\n            return err;\n        }\n        const response = err.response;\n        if (!response.isJson()) {\n            return new FirebaseRemoteConfigError('unknown-error', `Unexpected response with status: ${response.status} and body: ${response.text}`);\n        }\n        const error = response.data.error || {};\n        let code = 'unknown-error';\n        if (error.status && error.status in ERROR_CODE_MAPPING) {\n            code = ERROR_CODE_MAPPING[error.status];\n        }\n        const message = error.message || `Unknown server error: ${response.text}`;\n        return new FirebaseRemoteConfigError(code, message);\n    }\n    /**\n     * Creates a RemoteConfigTemplate from the API response.\n     * If provided, customEtag is used instead of the etag returned in the API response.\n     *\n     * @param {HttpResponse} resp API response object.\n     * @param {string} customEtag A custom etag to replace the etag fom the API response (Optional).\n     */\n    toRemoteConfigTemplate(resp, customEtag) {\n        const etag = (typeof customEtag === 'undefined') ? resp.headers['etag'] : customEtag;\n        this.validateEtag(etag);\n        return {\n            conditions: resp.data.conditions,\n            parameters: resp.data.parameters,\n            parameterGroups: resp.data.parameterGroups,\n            etag,\n            version: resp.data.version,\n        };\n    }\n    /**\n     * Creates a RemoteConfigServerTemplate from the API response.\n     * If provided, customEtag is used instead of the etag returned in the API response.\n     *\n     * @param {HttpResponse} resp API response object.\n     * @param {string} customEtag A custom etag to replace the etag fom the API response (Optional).\n     */\n    toRemoteConfigServerTemplate(resp, customEtag) {\n        const etag = (typeof customEtag === 'undefined') ? resp.headers['etag'] : customEtag;\n        this.validateEtag(etag);\n        return {\n            conditions: resp.data.conditions,\n            parameters: resp.data.parameters,\n            etag,\n            version: resp.data.version,\n        };\n    }\n    /**\n     * Checks if the given RemoteConfigTemplate object is valid.\n     * The object must have valid parameters, parameter groups, conditions, and an etag.\n     * Removes output only properties from version metadata.\n     *\n     * @param {RemoteConfigTemplate} template A RemoteConfigTemplate object to be validated.\n     *\n     * @returns {RemoteConfigTemplate} The validated RemoteConfigTemplate object.\n     */\n    validateInputRemoteConfigTemplate(template) {\n        const templateCopy = (0, deep_copy_1.deepCopy)(template);\n        if (!validator.isNonNullObject(templateCopy)) {\n            throw new FirebaseRemoteConfigError('invalid-argument', `Invalid Remote Config template: ${JSON.stringify(templateCopy)}`);\n        }\n        if (!validator.isNonEmptyString(templateCopy.etag)) {\n            throw new FirebaseRemoteConfigError('invalid-argument', 'ETag must be a non-empty string.');\n        }\n        if (!validator.isNonNullObject(templateCopy.parameters)) {\n            throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameters must be a non-null object');\n        }\n        if (!validator.isNonNullObject(templateCopy.parameterGroups)) {\n            throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config parameter groups must be a non-null object');\n        }\n        if (!validator.isArray(templateCopy.conditions)) {\n            throw new FirebaseRemoteConfigError('invalid-argument', 'Remote Config conditions must be an array');\n        }\n        if (typeof templateCopy.version !== 'undefined') {\n            // exclude output only properties and keep the only input property: description\n            templateCopy.version = { description: templateCopy.version.description };\n        }\n        return templateCopy;\n    }\n    /**\n     * Checks if a given version number is valid.\n     * A version number must be an integer or a string in int64 format.\n     * If valid, returns the string representation of the provided version number.\n     *\n     * @param {string|number} versionNumber A version number to be validated.\n     *\n     * @returns {string} The validated version number as a string.\n     */\n    validateVersionNumber(versionNumber, propertyName = 'versionNumber') {\n        if (!validator.isNonEmptyString(versionNumber) &&\n            !validator.isNumber(versionNumber)) {\n            throw new FirebaseRemoteConfigError('invalid-argument', `${propertyName} must be a non-empty string in int64 format or a number`);\n        }\n        if (!Number.isInteger(Number(versionNumber))) {\n            throw new FirebaseRemoteConfigError('invalid-argument', `${propertyName} must be an integer or a string in int64 format`);\n        }\n        return versionNumber.toString();\n    }\n    validateEtag(etag) {\n        if (!validator.isNonEmptyString(etag)) {\n            throw new FirebaseRemoteConfigError('invalid-argument', 'ETag header is not present in the server response.');\n        }\n    }\n    /**\n     * Checks if a given `ListVersionsOptions` object is valid. If successful, creates a copy of the\n     * options object and convert `startTime` and `endTime` to RFC3339 UTC \"Zulu\" format, if present.\n     *\n     * @param {ListVersionsOptions} options An options object to be validated.\n     *\n     * @returns {ListVersionsOptions} A copy of the provided options object with timestamps converted\n     * to UTC Zulu format.\n     */\n    validateListVersionsOptions(options) {\n        const optionsCopy = (0, deep_copy_1.deepCopy)(options);\n        if (!validator.isNonNullObject(optionsCopy)) {\n            throw new FirebaseRemoteConfigError('invalid-argument', 'ListVersionsOptions must be a non-null object.');\n        }\n        if (typeof optionsCopy.pageSize !== 'undefined') {\n            if (!validator.isNumber(optionsCopy.pageSize)) {\n                throw new FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number.');\n            }\n            if (optionsCopy.pageSize < 1 || optionsCopy.pageSize > 300) {\n                throw new FirebaseRemoteConfigError('invalid-argument', 'pageSize must be a number between 1 and 300 (inclusive).');\n            }\n        }\n        if (typeof optionsCopy.pageToken !== 'undefined' && !validator.isNonEmptyString(optionsCopy.pageToken)) {\n            throw new FirebaseRemoteConfigError('invalid-argument', 'pageToken must be a string value.');\n        }\n        if (typeof optionsCopy.endVersionNumber !== 'undefined') {\n            optionsCopy.endVersionNumber = this.validateVersionNumber(optionsCopy.endVersionNumber, 'endVersionNumber');\n        }\n        if (typeof optionsCopy.startTime !== 'undefined') {\n            if (!(optionsCopy.startTime instanceof Date) && !validator.isUTCDateString(optionsCopy.startTime)) {\n                throw new FirebaseRemoteConfigError('invalid-argument', 'startTime must be a valid Date object or a UTC date string.');\n            }\n            // Convert startTime to RFC3339 UTC \"Zulu\" format.\n            if (optionsCopy.startTime instanceof Date) {\n                optionsCopy.startTime = optionsCopy.startTime.toISOString();\n            }\n            else {\n                optionsCopy.startTime = new Date(optionsCopy.startTime).toISOString();\n            }\n        }\n        if (typeof optionsCopy.endTime !== 'undefined') {\n            if (!(optionsCopy.endTime instanceof Date) && !validator.isUTCDateString(optionsCopy.endTime)) {\n                throw new FirebaseRemoteConfigError('invalid-argument', 'endTime must be a valid Date object or a UTC date string.');\n            }\n            // Convert endTime to RFC3339 UTC \"Zulu\" format.\n            if (optionsCopy.endTime instanceof Date) {\n                optionsCopy.endTime = optionsCopy.endTime.toISOString();\n            }\n            else {\n                optionsCopy.endTime = new Date(optionsCopy.endTime).toISOString();\n            }\n        }\n        // Remove undefined fields from optionsCopy\n        Object.keys(optionsCopy).forEach(key => (typeof optionsCopy[key] === 'undefined') && delete optionsCopy[key]);\n        return optionsCopy;\n    }\n}\nexports.RemoteConfigApiClient = RemoteConfigApiClient;\nconst ERROR_CODE_MAPPING = {\n    ABORTED: 'aborted',\n    ALREADY_EXISTS: 'already-exists',\n    INVALID_ARGUMENT: 'invalid-argument',\n    INTERNAL: 'internal-error',\n    FAILED_PRECONDITION: 'failed-precondition',\n    NOT_FOUND: 'not-found',\n    OUT_OF_RANGE: 'out-of-range',\n    PERMISSION_DENIED: 'permission-denied',\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\n    UNAUTHENTICATED: 'unauthenticated',\n    UNKNOWN: 'unknown-error',\n};\n/**\n * Firebase Remote Config error code structure. This extends PrefixedFirebaseError.\n *\n * @param {RemoteConfigErrorCode} code The error code.\n * @param {string} message The error message.\n * @constructor\n */\nclass FirebaseRemoteConfigError extends error_1.PrefixedFirebaseError {\n    constructor(code, message) {\n        super('remote-config', code, message);\n    }\n}\nexports.FirebaseRemoteConfigError = FirebaseRemoteConfigError;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}