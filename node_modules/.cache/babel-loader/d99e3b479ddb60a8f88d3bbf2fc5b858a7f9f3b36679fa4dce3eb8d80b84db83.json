{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClientBulkWriteOperation = void 0;\nconst beta_1 = require(\"../../beta\");\nconst responses_1 = require(\"../../cmap/wire_protocol/responses\");\nconst utils_1 = require(\"../../utils\");\nconst command_1 = require(\"../command\");\nconst operation_1 = require(\"../operation\");\n/**\n * Executes a single client bulk write operation within a potential batch.\n * @internal\n */\nclass ClientBulkWriteOperation extends command_1.CommandOperation {\n  get commandName() {\n    return 'bulkWrite';\n  }\n  constructor(commandBuilder, options) {\n    super(undefined, options);\n    this.commandBuilder = commandBuilder;\n    this.options = options;\n    this.ns = new utils_1.MongoDBNamespace('admin', '$cmd');\n  }\n  resetBatch() {\n    return this.commandBuilder.resetBatch();\n  }\n  get canRetryWrite() {\n    return this.commandBuilder.isBatchRetryable;\n  }\n  /**\n   * Execute the command. Superclass will handle write concern, etc.\n   * @param server - The server.\n   * @param session - The session.\n   * @returns The response.\n   */\n  async execute(server, session) {\n    let command;\n    if (server.description.type === beta_1.ServerType.LoadBalancer) {\n      if (session) {\n        let connection;\n        if (!session.pinnedConnection) {\n          // Checkout a connection to build the command.\n          connection = await server.pool.checkOut();\n          // Pin the connection to the session so it get used to execute the command and we do not\n          // perform a double check-in/check-out.\n          session.pin(connection);\n        } else {\n          connection = session.pinnedConnection;\n        }\n        command = this.commandBuilder.buildBatch(connection.hello?.maxMessageSizeBytes, connection.hello?.maxWriteBatchSize, connection.hello?.maxBsonObjectSize);\n      } else {\n        throw new beta_1.MongoClientBulkWriteExecutionError('Session provided to the client bulk write operation must be present.');\n      }\n    } else {\n      // At this point we have a server and the auto connect code has already\n      // run in executeOperation, so the server description will be populated.\n      // We can use that to build the command.\n      if (!server.description.maxWriteBatchSize || !server.description.maxMessageSizeBytes || !server.description.maxBsonObjectSize) {\n        throw new beta_1.MongoClientBulkWriteExecutionError('In order to execute a client bulk write, both maxWriteBatchSize, maxMessageSizeBytes and maxBsonObjectSize must be provided by the servers hello response.');\n      }\n      command = this.commandBuilder.buildBatch(server.description.maxMessageSizeBytes, server.description.maxWriteBatchSize, server.description.maxBsonObjectSize);\n    }\n    // Check after the batch is built if we cannot retry it and override the option.\n    if (!this.canRetryWrite) {\n      this.options.willRetryWrite = false;\n    }\n    return await super.executeCommand(server, session, command, responses_1.ClientBulkWriteCursorResponse);\n  }\n}\nexports.ClientBulkWriteOperation = ClientBulkWriteOperation;\n// Skipping the collation as it goes on the individual ops.\n(0, operation_1.defineAspects)(ClientBulkWriteOperation, [operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION, operation_1.Aspect.CURSOR_CREATING, operation_1.Aspect.RETRYABLE, operation_1.Aspect.COMMAND_BATCHING]);","map":{"version":3,"mappings":";;;;;;AAAA;AACA;AAGA;AACA;AACA;AAIA;;;;AAIA,MAAaA,wBAAyB,SAAQC,0BAA+C;EAI3F,IAAaC,WAAW;IACtB,OAAO,WAAoB;EAC7B;EAEAC,YAAYC,cAA6C,EAAEC,OAA+B;IACxF,KAAK,CAACC,SAAS,EAAED,OAAO,CAAC;IACzB,IAAI,CAACD,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACE,EAAE,GAAG,IAAIC,wBAAgB,CAAC,OAAO,EAAE,MAAM,CAAC;EACjD;EAESC,UAAU;IACjB,OAAO,IAAI,CAACL,cAAc,CAACK,UAAU,EAAE;EACzC;EAEA,IAAaC,aAAa;IACxB,OAAO,IAAI,CAACN,cAAc,CAACO,gBAAgB;EAC7C;EAEA;;;;;;EAMS,MAAMC,OAAO,CACpBC,MAAc,EACdC,OAAkC;IAElC,IAAIC,OAAO;IAEX,IAAIF,MAAM,CAACG,WAAW,CAACC,IAAI,KAAKC,iBAAU,CAACC,YAAY,EAAE;MACvD,IAAIL,OAAO,EAAE;QACX,IAAIM,UAAU;QACd,IAAI,CAACN,OAAO,CAACO,gBAAgB,EAAE;UAC7B;UACAD,UAAU,GAAG,MAAMP,MAAM,CAACS,IAAI,CAACC,QAAQ,EAAE;UACzC;UACA;UACAT,OAAO,CAACU,GAAG,CAACJ,UAAU,CAAC;QACzB,CAAC,MAAM;UACLA,UAAU,GAAGN,OAAO,CAACO,gBAAgB;QACvC;QACAN,OAAO,GAAG,IAAI,CAACX,cAAc,CAACqB,UAAU,CACtCL,UAAU,CAACM,KAAK,EAAEC,mBAAmB,EACrCP,UAAU,CAACM,KAAK,EAAEE,iBAAiB,EACnCR,UAAU,CAACM,KAAK,EAAEG,iBAAiB,CACpC;MACH,CAAC,MAAM;QACL,MAAM,IAAIX,yCAAkC,CAC1C,sEAAsE,CACvE;MACH;IACF,CAAC,MAAM;MACL;MACA;MACA;MACA,IACE,CAACL,MAAM,CAACG,WAAW,CAACY,iBAAiB,IACrC,CAACf,MAAM,CAACG,WAAW,CAACW,mBAAmB,IACvC,CAACd,MAAM,CAACG,WAAW,CAACa,iBAAiB,EACrC;QACA,MAAM,IAAIX,yCAAkC,CAC1C,4JAA4J,CAC7J;MACH;MACAH,OAAO,GAAG,IAAI,CAACX,cAAc,CAACqB,UAAU,CACtCZ,MAAM,CAACG,WAAW,CAACW,mBAAmB,EACtCd,MAAM,CAACG,WAAW,CAACY,iBAAiB,EACpCf,MAAM,CAACG,WAAW,CAACa,iBAAiB,CACrC;IACH;IAEA;IACA,IAAI,CAAC,IAAI,CAACnB,aAAa,EAAE;MACvB,IAAI,CAACL,OAAO,CAACyB,cAAc,GAAG,KAAK;IACrC;IACA,OAAO,MAAM,KAAK,CAACC,cAAc,CAAClB,MAAM,EAAEC,OAAO,EAAEC,OAAO,EAAEiB,yCAA6B,CAAC;EAC5F;;AAlFFC;AAqFA;AACA,6BAAa,EAACjC,wBAAwB,EAAE,CACtCkC,kBAAM,CAACC,eAAe,EACtBD,kBAAM,CAACE,cAAc,EACrBF,kBAAM,CAACG,eAAe,EACtBH,kBAAM,CAACI,SAAS,EAChBJ,kBAAM,CAACK,gBAAgB,CACxB,CAAC","names":["ClientBulkWriteOperation","command_1","commandName","constructor","commandBuilder","options","undefined","ns","utils_1","resetBatch","canRetryWrite","isBatchRetryable","execute","server","session","command","description","type","beta_1","LoadBalancer","connection","pinnedConnection","pool","checkOut","pin","buildBatch","hello","maxMessageSizeBytes","maxWriteBatchSize","maxBsonObjectSize","willRetryWrite","executeCommand","responses_1","exports","operation_1","WRITE_OPERATION","SKIP_COLLATION","CURSOR_CREATING","RETRYABLE","COMMAND_BATCHING"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/operations/client_bulk_write/client_bulk_write.ts"],"sourcesContent":["import { MongoClientBulkWriteExecutionError, ServerType } from '../../beta';\nimport { ClientBulkWriteCursorResponse } from '../../cmap/wire_protocol/responses';\nimport type { Server } from '../../sdam/server';\nimport type { ClientSession } from '../../sessions';\nimport { MongoDBNamespace } from '../../utils';\nimport { CommandOperation } from '../command';\nimport { Aspect, defineAspects } from '../operation';\nimport { type ClientBulkWriteCommandBuilder } from './command_builder';\nimport { type ClientBulkWriteOptions } from './common';\n\n/**\n * Executes a single client bulk write operation within a potential batch.\n * @internal\n */\nexport class ClientBulkWriteOperation extends CommandOperation<ClientBulkWriteCursorResponse> {\n  commandBuilder: ClientBulkWriteCommandBuilder;\n  override options: ClientBulkWriteOptions;\n\n  override get commandName() {\n    return 'bulkWrite' as const;\n  }\n\n  constructor(commandBuilder: ClientBulkWriteCommandBuilder, options: ClientBulkWriteOptions) {\n    super(undefined, options);\n    this.commandBuilder = commandBuilder;\n    this.options = options;\n    this.ns = new MongoDBNamespace('admin', '$cmd');\n  }\n\n  override resetBatch(): boolean {\n    return this.commandBuilder.resetBatch();\n  }\n\n  override get canRetryWrite(): boolean {\n    return this.commandBuilder.isBatchRetryable;\n  }\n\n  /**\n   * Execute the command. Superclass will handle write concern, etc.\n   * @param server - The server.\n   * @param session - The session.\n   * @returns The response.\n   */\n  override async execute(\n    server: Server,\n    session: ClientSession | undefined\n  ): Promise<ClientBulkWriteCursorResponse> {\n    let command;\n\n    if (server.description.type === ServerType.LoadBalancer) {\n      if (session) {\n        let connection;\n        if (!session.pinnedConnection) {\n          // Checkout a connection to build the command.\n          connection = await server.pool.checkOut();\n          // Pin the connection to the session so it get used to execute the command and we do not\n          // perform a double check-in/check-out.\n          session.pin(connection);\n        } else {\n          connection = session.pinnedConnection;\n        }\n        command = this.commandBuilder.buildBatch(\n          connection.hello?.maxMessageSizeBytes,\n          connection.hello?.maxWriteBatchSize,\n          connection.hello?.maxBsonObjectSize\n        );\n      } else {\n        throw new MongoClientBulkWriteExecutionError(\n          'Session provided to the client bulk write operation must be present.'\n        );\n      }\n    } else {\n      // At this point we have a server and the auto connect code has already\n      // run in executeOperation, so the server description will be populated.\n      // We can use that to build the command.\n      if (\n        !server.description.maxWriteBatchSize ||\n        !server.description.maxMessageSizeBytes ||\n        !server.description.maxBsonObjectSize\n      ) {\n        throw new MongoClientBulkWriteExecutionError(\n          'In order to execute a client bulk write, both maxWriteBatchSize, maxMessageSizeBytes and maxBsonObjectSize must be provided by the servers hello response.'\n        );\n      }\n      command = this.commandBuilder.buildBatch(\n        server.description.maxMessageSizeBytes,\n        server.description.maxWriteBatchSize,\n        server.description.maxBsonObjectSize\n      );\n    }\n\n    // Check after the batch is built if we cannot retry it and override the option.\n    if (!this.canRetryWrite) {\n      this.options.willRetryWrite = false;\n    }\n    return await super.executeCommand(server, session, command, ClientBulkWriteCursorResponse);\n  }\n}\n\n// Skipping the collation as it goes on the individual ops.\ndefineAspects(ClientBulkWriteOperation, [\n  Aspect.WRITE_OPERATION,\n  Aspect.SKIP_COLLATION,\n  Aspect.CURSOR_CREATING,\n  Aspect.RETRYABLE,\n  Aspect.COMMAND_BATCHING\n]);\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}