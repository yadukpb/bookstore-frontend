{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResourceStream = exports.paginator = exports.Paginator = void 0;\n/*!\n * @module common/paginator\n */\nconst arrify = require(\"arrify\");\nconst extend = require(\"extend\");\nconst resource_stream_1 = require(\"./resource-stream\");\nObject.defineProperty(exports, \"ResourceStream\", {\n  enumerable: true,\n  get: function () {\n    return resource_stream_1.ResourceStream;\n  }\n});\n/*! Developer Documentation\n *\n * paginator is used to auto-paginate `nextQuery` methods as well as\n * streamifying them.\n *\n * Before:\n *\n *   search.query('done=true', function(err, results, nextQuery) {\n *     search.query(nextQuery, function(err, results, nextQuery) {});\n *   });\n *\n * After:\n *\n *   search.query('done=true', function(err, results) {});\n *\n * Methods to extend should be written to accept callbacks and return a\n * `nextQuery`.\n */\nclass Paginator {\n  /**\n   * Cache the original method, then overwrite it on the Class's prototype.\n   *\n   * @param {function} Class - The parent class of the methods to extend.\n   * @param {string|string[]} methodNames - Name(s) of the methods to extend.\n   */\n  // tslint:disable-next-line:variable-name\n  extend(Class, methodNames) {\n    methodNames = arrify(methodNames);\n    methodNames.forEach(methodName => {\n      const originalMethod = Class.prototype[methodName];\n      // map the original method to a private member\n      Class.prototype[methodName + '_'] = originalMethod;\n      // overwrite the original to auto-paginate\n      /* eslint-disable  @typescript-eslint/no-explicit-any */\n      Class.prototype[methodName] = function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        const parsedArguments = paginator.parseArguments_(args);\n        return paginator.run_(parsedArguments, originalMethod.bind(this));\n      };\n    });\n  }\n  /**\n   * Wraps paginated API calls in a readable object stream.\n   *\n   * This method simply calls the nextQuery recursively, emitting results to a\n   * stream. The stream ends when `nextQuery` is null.\n   *\n   * `maxResults` will act as a cap for how many results are fetched and emitted\n   * to the stream.\n   *\n   * @param {string} methodName - Name of the method to streamify.\n   * @return {function} - Wrapped function.\n   */\n  /* eslint-disable  @typescript-eslint/no-explicit-any */\n  streamify(methodName) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      const parsedArguments = paginator.parseArguments_(args);\n      const originalMethod = this[methodName + '_'] || this[methodName];\n      return paginator.runAsStream_(parsedArguments, originalMethod.bind(this));\n    };\n  }\n  /**\n   * Parse a pseudo-array `arguments` for a query and callback.\n   *\n   * @param {array} args - The original `arguments` pseduo-array that the original\n   *     method received.\n   */\n  /* eslint-disable  @typescript-eslint/no-explicit-any */\n  parseArguments_(args) {\n    let query;\n    let autoPaginate = true;\n    let maxApiCalls = -1;\n    let maxResults = -1;\n    let callback;\n    const firstArgument = args[0];\n    const lastArgument = args[args.length - 1];\n    if (typeof firstArgument === 'function') {\n      callback = firstArgument;\n    } else {\n      query = firstArgument;\n    }\n    if (typeof lastArgument === 'function') {\n      callback = lastArgument;\n    }\n    if (typeof query === 'object') {\n      query = extend(true, {}, query);\n      // Check if the user only asked for a certain amount of results.\n      if (query.maxResults && typeof query.maxResults === 'number') {\n        // `maxResults` is used API-wide.\n        maxResults = query.maxResults;\n      } else if (typeof query.pageSize === 'number') {\n        // `pageSize` is Pub/Sub's `maxResults`.\n        maxResults = query.pageSize;\n      }\n      if (query.maxApiCalls && typeof query.maxApiCalls === 'number') {\n        maxApiCalls = query.maxApiCalls;\n        delete query.maxApiCalls;\n      }\n      // maxResults is the user specified limit.\n      if (maxResults !== -1 || query.autoPaginate === false) {\n        autoPaginate = false;\n      }\n    }\n    const parsedArguments = {\n      query: query || {},\n      autoPaginate,\n      maxApiCalls,\n      maxResults,\n      callback\n    };\n    parsedArguments.streamOptions = extend(true, {}, parsedArguments.query);\n    delete parsedArguments.streamOptions.autoPaginate;\n    delete parsedArguments.streamOptions.maxResults;\n    delete parsedArguments.streamOptions.pageSize;\n    return parsedArguments;\n  }\n  /**\n   * This simply checks to see if `autoPaginate` is set or not, if it's true\n   * then we buffer all results, otherwise simply call the original method.\n   *\n   * @param {array} parsedArguments - Parsed arguments from the original method\n   *     call.\n   * @param {object=|string=} parsedArguments.query - Query object. This is most\n   *     commonly an object, but to make the API more simple, it can also be a\n   *     string in some places.\n   * @param {function=} parsedArguments.callback - Callback function.\n   * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n   * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n   * @param {number} parsedArguments.maxResults - Maximum results to return.\n   * @param {function} originalMethod - The cached method that accepts a callback\n   *     and returns `nextQuery` to receive more results.\n   */\n  run_(parsedArguments, originalMethod) {\n    const query = parsedArguments.query;\n    const callback = parsedArguments.callback;\n    if (!parsedArguments.autoPaginate) {\n      return originalMethod(query, callback);\n    }\n    const results = new Array();\n    let otherArgs = [];\n    const promise = new Promise((resolve, reject) => {\n      const stream = paginator.runAsStream_(parsedArguments, originalMethod);\n      stream.on('error', reject).on('data', data => results.push(data)).on('end', () => {\n        otherArgs = stream._otherArgs || [];\n        resolve(results);\n      });\n    });\n    if (!callback) {\n      return promise.then(results => [results, query, ...otherArgs]);\n    }\n    promise.then(results => callback(null, results, query, ...otherArgs), err => callback(err));\n  }\n  /**\n   * This method simply calls the nextQuery recursively, emitting results to a\n   * stream. The stream ends when `nextQuery` is null.\n   *\n   * `maxResults` will act as a cap for how many results are fetched and emitted\n   * to the stream.\n   *\n   * @param {object=|string=} parsedArguments.query - Query object. This is most\n   *     commonly an object, but to make the API more simple, it can also be a\n   *     string in some places.\n   * @param {function=} parsedArguments.callback - Callback function.\n   * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n   * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n   * @param {number} parsedArguments.maxResults - Maximum results to return.\n   * @param {function} originalMethod - The cached method that accepts a callback\n   *     and returns `nextQuery` to receive more results.\n   * @return {stream} - Readable object stream.\n   */\n  /* eslint-disable  @typescript-eslint/no-explicit-any */\n  runAsStream_(parsedArguments, originalMethod) {\n    return new resource_stream_1.ResourceStream(parsedArguments, originalMethod);\n  }\n}\nexports.Paginator = Paginator;\nconst paginator = new Paginator();\nexports.paginator = paginator;","map":{"version":3,"names":["Object","defineProperty","exports","value","ResourceStream","paginator","Paginator","arrify","require","extend","resource_stream_1","enumerable","get","Class","methodNames","forEach","methodName","originalMethod","prototype","args","parsedArguments","parseArguments_","run_","bind","streamify","runAsStream_","query","autoPaginate","maxApiCalls","maxResults","callback","firstArgument","lastArgument","length","pageSize","streamOptions","results","Array","otherArgs","promise","Promise","resolve","reject","stream","on","data","push","_otherArgs","then","err"],"sources":["/home/yadu/Music/Gifty/node_modules/@google-cloud/paginator/build/src/index.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ResourceStream = exports.paginator = exports.Paginator = void 0;\n/*!\n * @module common/paginator\n */\nconst arrify = require(\"arrify\");\nconst extend = require(\"extend\");\nconst resource_stream_1 = require(\"./resource-stream\");\nObject.defineProperty(exports, \"ResourceStream\", { enumerable: true, get: function () { return resource_stream_1.ResourceStream; } });\n/*! Developer Documentation\n *\n * paginator is used to auto-paginate `nextQuery` methods as well as\n * streamifying them.\n *\n * Before:\n *\n *   search.query('done=true', function(err, results, nextQuery) {\n *     search.query(nextQuery, function(err, results, nextQuery) {});\n *   });\n *\n * After:\n *\n *   search.query('done=true', function(err, results) {});\n *\n * Methods to extend should be written to accept callbacks and return a\n * `nextQuery`.\n */\nclass Paginator {\n    /**\n     * Cache the original method, then overwrite it on the Class's prototype.\n     *\n     * @param {function} Class - The parent class of the methods to extend.\n     * @param {string|string[]} methodNames - Name(s) of the methods to extend.\n     */\n    // tslint:disable-next-line:variable-name\n    extend(Class, methodNames) {\n        methodNames = arrify(methodNames);\n        methodNames.forEach(methodName => {\n            const originalMethod = Class.prototype[methodName];\n            // map the original method to a private member\n            Class.prototype[methodName + '_'] = originalMethod;\n            // overwrite the original to auto-paginate\n            /* eslint-disable  @typescript-eslint/no-explicit-any */\n            Class.prototype[methodName] = function (...args) {\n                const parsedArguments = paginator.parseArguments_(args);\n                return paginator.run_(parsedArguments, originalMethod.bind(this));\n            };\n        });\n    }\n    /**\n     * Wraps paginated API calls in a readable object stream.\n     *\n     * This method simply calls the nextQuery recursively, emitting results to a\n     * stream. The stream ends when `nextQuery` is null.\n     *\n     * `maxResults` will act as a cap for how many results are fetched and emitted\n     * to the stream.\n     *\n     * @param {string} methodName - Name of the method to streamify.\n     * @return {function} - Wrapped function.\n     */\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    streamify(methodName) {\n        return function (\n        /* eslint-disable  @typescript-eslint/no-explicit-any */\n        ...args) {\n            const parsedArguments = paginator.parseArguments_(args);\n            const originalMethod = this[methodName + '_'] || this[methodName];\n            return paginator.runAsStream_(parsedArguments, originalMethod.bind(this));\n        };\n    }\n    /**\n     * Parse a pseudo-array `arguments` for a query and callback.\n     *\n     * @param {array} args - The original `arguments` pseduo-array that the original\n     *     method received.\n     */\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    parseArguments_(args) {\n        let query;\n        let autoPaginate = true;\n        let maxApiCalls = -1;\n        let maxResults = -1;\n        let callback;\n        const firstArgument = args[0];\n        const lastArgument = args[args.length - 1];\n        if (typeof firstArgument === 'function') {\n            callback = firstArgument;\n        }\n        else {\n            query = firstArgument;\n        }\n        if (typeof lastArgument === 'function') {\n            callback = lastArgument;\n        }\n        if (typeof query === 'object') {\n            query = extend(true, {}, query);\n            // Check if the user only asked for a certain amount of results.\n            if (query.maxResults && typeof query.maxResults === 'number') {\n                // `maxResults` is used API-wide.\n                maxResults = query.maxResults;\n            }\n            else if (typeof query.pageSize === 'number') {\n                // `pageSize` is Pub/Sub's `maxResults`.\n                maxResults = query.pageSize;\n            }\n            if (query.maxApiCalls && typeof query.maxApiCalls === 'number') {\n                maxApiCalls = query.maxApiCalls;\n                delete query.maxApiCalls;\n            }\n            // maxResults is the user specified limit.\n            if (maxResults !== -1 || query.autoPaginate === false) {\n                autoPaginate = false;\n            }\n        }\n        const parsedArguments = {\n            query: query || {},\n            autoPaginate,\n            maxApiCalls,\n            maxResults,\n            callback,\n        };\n        parsedArguments.streamOptions = extend(true, {}, parsedArguments.query);\n        delete parsedArguments.streamOptions.autoPaginate;\n        delete parsedArguments.streamOptions.maxResults;\n        delete parsedArguments.streamOptions.pageSize;\n        return parsedArguments;\n    }\n    /**\n     * This simply checks to see if `autoPaginate` is set or not, if it's true\n     * then we buffer all results, otherwise simply call the original method.\n     *\n     * @param {array} parsedArguments - Parsed arguments from the original method\n     *     call.\n     * @param {object=|string=} parsedArguments.query - Query object. This is most\n     *     commonly an object, but to make the API more simple, it can also be a\n     *     string in some places.\n     * @param {function=} parsedArguments.callback - Callback function.\n     * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n     * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n     * @param {number} parsedArguments.maxResults - Maximum results to return.\n     * @param {function} originalMethod - The cached method that accepts a callback\n     *     and returns `nextQuery` to receive more results.\n     */\n    run_(parsedArguments, originalMethod) {\n        const query = parsedArguments.query;\n        const callback = parsedArguments.callback;\n        if (!parsedArguments.autoPaginate) {\n            return originalMethod(query, callback);\n        }\n        const results = new Array();\n        let otherArgs = [];\n        const promise = new Promise((resolve, reject) => {\n            const stream = paginator.runAsStream_(parsedArguments, originalMethod);\n            stream\n                .on('error', reject)\n                .on('data', (data) => results.push(data))\n                .on('end', () => {\n                otherArgs = stream._otherArgs || [];\n                resolve(results);\n            });\n        });\n        if (!callback) {\n            return promise.then(results => [results, query, ...otherArgs]);\n        }\n        promise.then(results => callback(null, results, query, ...otherArgs), (err) => callback(err));\n    }\n    /**\n     * This method simply calls the nextQuery recursively, emitting results to a\n     * stream. The stream ends when `nextQuery` is null.\n     *\n     * `maxResults` will act as a cap for how many results are fetched and emitted\n     * to the stream.\n     *\n     * @param {object=|string=} parsedArguments.query - Query object. This is most\n     *     commonly an object, but to make the API more simple, it can also be a\n     *     string in some places.\n     * @param {function=} parsedArguments.callback - Callback function.\n     * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n     * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n     * @param {number} parsedArguments.maxResults - Maximum results to return.\n     * @param {function} originalMethod - The cached method that accepts a callback\n     *     and returns `nextQuery` to receive more results.\n     * @return {stream} - Readable object stream.\n     */\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    runAsStream_(parsedArguments, originalMethod) {\n        return new resource_stream_1.ResourceStream(parsedArguments, originalMethod);\n    }\n}\nexports.Paginator = Paginator;\nconst paginator = new Paginator();\nexports.paginator = paginator;\n//# sourceMappingURL=index.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}