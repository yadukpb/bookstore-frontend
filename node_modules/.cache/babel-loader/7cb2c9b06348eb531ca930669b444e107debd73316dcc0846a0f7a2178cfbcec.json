{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { validateKey, validateValue } from './tracestate-validators';\nvar MAX_TRACE_STATE_ITEMS = 32;\nvar MAX_TRACE_STATE_LEN = 512;\nvar LIST_MEMBERS_SEPARATOR = ',';\nvar LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\nvar TraceStateImpl = /** @class */function () {\n  function TraceStateImpl(rawTraceState) {\n    this._internalState = new Map();\n    if (rawTraceState) this._parse(rawTraceState);\n  }\n  TraceStateImpl.prototype.set = function (key, value) {\n    // TODO: Benchmark the different approaches(map vs list) and\n    // use the faster one.\n    var traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  };\n  TraceStateImpl.prototype.unset = function (key) {\n    var traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  };\n  TraceStateImpl.prototype.get = function (key) {\n    return this._internalState.get(key);\n  };\n  TraceStateImpl.prototype.serialize = function () {\n    var _this = this;\n    return this._keys().reduce(function (agg, key) {\n      agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));\n      return agg;\n    }, []).join(LIST_MEMBERS_SEPARATOR);\n  };\n  TraceStateImpl.prototype._parse = function (rawTraceState) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;\n    this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n    .reduce(function (agg, part) {\n      var listMember = part.trim(); // Optional Whitespace (OWS) handling\n      var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n      if (i !== -1) {\n        var key = listMember.slice(0, i);\n        var value = listMember.slice(i + 1, part.length);\n        if (validateKey(key) && validateValue(value)) {\n          agg.set(key, value);\n        } else {\n          // TODO: Consider to add warning log\n        }\n      }\n      return agg;\n    }, new Map());\n    // Because of the reverse() requirement, trunc must be done after map is created\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(Array.from(this._internalState.entries()).reverse() // Use reverse same as original tracestate parse chain\n      .slice(0, MAX_TRACE_STATE_ITEMS));\n    }\n  };\n  TraceStateImpl.prototype._keys = function () {\n    return Array.from(this._internalState.keys()).reverse();\n  };\n  TraceStateImpl.prototype._clone = function () {\n    var traceState = new TraceStateImpl();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  };\n  return TraceStateImpl;\n}();\nexport { TraceStateImpl };","map":{"version":3,"mappings":"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","names":["validateKey","validateValue","MAX_TRACE_STATE_ITEMS","MAX_TRACE_STATE_LEN","LIST_MEMBERS_SEPARATOR","LIST_MEMBER_KEY_VALUE_SPLITTER","rawTraceState","Map","_parse","TraceStateImpl","key","value","traceState","_clone","_internalState","has","delete","set","get","_keys","reduce","agg","push","_this","join","length","split","reverse","part","listMember","trim","i","indexOf","slice","size","Array","from","entries","keys"],"sources":["/home/yadu/Music/Gifty/node_modules/@opentelemetry/api/src/trace/internal/tracestate-impl.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { TraceState } from '../trace_state';\nimport { validateKey, validateValue } from './tracestate-validators';\n\nconst MAX_TRACE_STATE_ITEMS = 32;\nconst MAX_TRACE_STATE_LEN = 512;\nconst LIST_MEMBERS_SEPARATOR = ',';\nconst LIST_MEMBER_KEY_VALUE_SPLITTER = '=';\n\n/**\n * TraceState must be a class and not a simple object type because of the spec\n * requirement (https://www.w3.org/TR/trace-context/#tracestate-field).\n *\n * Here is the list of allowed mutations:\n * - New key-value pair should be added into the beginning of the list\n * - The value of any key can be updated. Modified keys MUST be moved to the\n * beginning of the list.\n */\nexport class TraceStateImpl implements TraceState {\n  private _internalState: Map<string, string> = new Map();\n\n  constructor(rawTraceState?: string) {\n    if (rawTraceState) this._parse(rawTraceState);\n  }\n\n  set(key: string, value: string): TraceStateImpl {\n    // TODO: Benchmark the different approaches(map vs list) and\n    // use the faster one.\n    const traceState = this._clone();\n    if (traceState._internalState.has(key)) {\n      traceState._internalState.delete(key);\n    }\n    traceState._internalState.set(key, value);\n    return traceState;\n  }\n\n  unset(key: string): TraceStateImpl {\n    const traceState = this._clone();\n    traceState._internalState.delete(key);\n    return traceState;\n  }\n\n  get(key: string): string | undefined {\n    return this._internalState.get(key);\n  }\n\n  serialize(): string {\n    return this._keys()\n      .reduce((agg: string[], key) => {\n        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));\n        return agg;\n      }, [])\n      .join(LIST_MEMBERS_SEPARATOR);\n  }\n\n  private _parse(rawTraceState: string) {\n    if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;\n    this._internalState = rawTraceState\n      .split(LIST_MEMBERS_SEPARATOR)\n      .reverse() // Store in reverse so new keys (.set(...)) will be placed at the beginning\n      .reduce((agg: Map<string, string>, part: string) => {\n        const listMember = part.trim(); // Optional Whitespace (OWS) handling\n        const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);\n        if (i !== -1) {\n          const key = listMember.slice(0, i);\n          const value = listMember.slice(i + 1, part.length);\n          if (validateKey(key) && validateValue(value)) {\n            agg.set(key, value);\n          } else {\n            // TODO: Consider to add warning log\n          }\n        }\n        return agg;\n      }, new Map());\n\n    // Because of the reverse() requirement, trunc must be done after map is created\n    if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {\n      this._internalState = new Map(\n        Array.from(this._internalState.entries())\n          .reverse() // Use reverse same as original tracestate parse chain\n          .slice(0, MAX_TRACE_STATE_ITEMS)\n      );\n    }\n  }\n\n  private _keys(): string[] {\n    return Array.from(this._internalState.keys()).reverse();\n  }\n\n  private _clone(): TraceStateImpl {\n    const traceState = new TraceStateImpl();\n    traceState._internalState = new Map(this._internalState);\n    return traceState;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}