{"ast":null,"code":"const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n  let indentation = \"\";\n  if (options.format && options.indentBy.length > 0) {\n    indentation = EOL;\n  }\n  return arrToStr(jArray, options, \"\", indentation);\n}\nfunction arrToStr(arr, options, jPath, indentation) {\n  let xmlStr = \"\";\n  let isPreviousElementTag = false;\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const tagName = propName(tagObj);\n    if (tagName === undefined) continue;\n    let newJPath = \"\";\n    if (jPath.length === 0) newJPath = tagName;else newJPath = `${jPath}.${tagName}`;\n    if (tagName === options.textNodeName) {\n      let tagText = tagObj[tagName];\n      if (!isStopNode(newJPath, options)) {\n        tagText = options.tagValueProcessor(tagName, tagText);\n        tagText = replaceEntitiesValue(tagText, options);\n      }\n      if (isPreviousElementTag) {\n        xmlStr += indentation;\n      }\n      xmlStr += tagText;\n      isPreviousElementTag = false;\n      continue;\n    } else if (tagName === options.cdataPropName) {\n      if (isPreviousElementTag) {\n        xmlStr += indentation;\n      }\n      xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n      isPreviousElementTag = false;\n      continue;\n    } else if (tagName === options.commentPropName) {\n      xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n      isPreviousElementTag = true;\n      continue;\n    } else if (tagName[0] === \"?\") {\n      const attStr = attr_to_str(tagObj[\":@\"], options);\n      const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n      let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n      piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n      xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n      isPreviousElementTag = true;\n      continue;\n    }\n    let newIdentation = indentation;\n    if (newIdentation !== \"\") {\n      newIdentation += options.indentBy;\n    }\n    const attStr = attr_to_str(tagObj[\":@\"], options);\n    const tagStart = indentation + `<${tagName}${attStr}`;\n    const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n    if (options.unpairedTags.indexOf(tagName) !== -1) {\n      if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";else xmlStr += tagStart + \"/>\";\n    } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n      xmlStr += tagStart + \"/>\";\n    } else if (tagValue && tagValue.endsWith(\">\")) {\n      xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n    } else {\n      xmlStr += tagStart + \">\";\n      if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n        xmlStr += indentation + options.indentBy + tagValue + indentation;\n      } else {\n        xmlStr += tagValue;\n      }\n      xmlStr += `</${tagName}>`;\n    }\n    isPreviousElementTag = true;\n  }\n  return xmlStr;\n}\nfunction propName(obj) {\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (!obj.hasOwnProperty(key)) continue;\n    if (key !== \":@\") return key;\n  }\n}\nfunction attr_to_str(attrMap, options) {\n  let attrStr = \"\";\n  if (attrMap && !options.ignoreAttributes) {\n    for (let attr in attrMap) {\n      if (!attrMap.hasOwnProperty(attr)) continue;\n      let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n      attrVal = replaceEntitiesValue(attrVal, options);\n      if (attrVal === true && options.suppressBooleanAttributes) {\n        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n      } else {\n        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n      }\n    }\n  }\n  return attrStr;\n}\nfunction isStopNode(jPath, options) {\n  jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n  let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n  for (let index in options.stopNodes) {\n    if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n  }\n  return false;\n}\nfunction replaceEntitiesValue(textValue, options) {\n  if (textValue && textValue.length > 0 && options.processEntities) {\n    for (let i = 0; i < options.entities.length; i++) {\n      const entity = options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\nmodule.exports = toXml;","map":{"version":3,"names":["EOL","toXml","jArray","options","indentation","format","indentBy","length","arrToStr","arr","jPath","xmlStr","isPreviousElementTag","i","tagObj","tagName","propName","undefined","newJPath","textNodeName","tagText","isStopNode","tagValueProcessor","replaceEntitiesValue","cdataPropName","commentPropName","attStr","attr_to_str","tempInd","piTextNodeName","newIdentation","tagStart","tagValue","unpairedTags","indexOf","suppressUnpairedNode","suppressEmptyNode","endsWith","includes","obj","keys","Object","key","hasOwnProperty","attrMap","attrStr","ignoreAttributes","attr","attrVal","attributeValueProcessor","suppressBooleanAttributes","substr","attributeNamePrefix","lastIndexOf","index","stopNodes","textValue","processEntities","entities","entity","replace","regex","val","module","exports"],"sources":["/home/yadu/Music/Gifty/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"],"sourcesContent":["const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if(tagName === undefined) continue;\n\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if(!obj.hasOwnProperty(key)) continue;\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            if(!attrMap.hasOwnProperty(attr)) continue;\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}