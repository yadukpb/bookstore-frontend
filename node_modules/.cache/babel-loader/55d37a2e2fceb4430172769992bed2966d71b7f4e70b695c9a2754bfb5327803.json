{"ast":null,"code":"/*! firebase-admin v12.7.0 */\n\"use strict\";\n\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Messaging = void 0;\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst error_1 = require(\"../utils/error\");\nconst utils = require(\"../utils\");\nconst validator = require(\"../utils/validator\");\nconst messaging_internal_1 = require(\"./messaging-internal\");\nconst messaging_api_request_internal_1 = require(\"./messaging-api-request-internal\");\nconst api_request_1 = require(\"../utils/api-request\");\n// FCM endpoints\nconst FCM_SEND_HOST = 'fcm.googleapis.com';\nconst FCM_SEND_PATH = '/fcm/send';\nconst FCM_TOPIC_MANAGEMENT_HOST = 'iid.googleapis.com';\nconst FCM_TOPIC_MANAGEMENT_ADD_PATH = '/iid/v1:batchAdd';\nconst FCM_TOPIC_MANAGEMENT_REMOVE_PATH = '/iid/v1:batchRemove';\n// Maximum messages that can be included in a batch request.\nconst FCM_MAX_BATCH_SIZE = 500;\n// Key renames for the messaging notification payload object.\nconst CAMELCASED_NOTIFICATION_PAYLOAD_KEYS_MAP = {\n  bodyLocArgs: 'body_loc_args',\n  bodyLocKey: 'body_loc_key',\n  clickAction: 'click_action',\n  titleLocArgs: 'title_loc_args',\n  titleLocKey: 'title_loc_key'\n};\n// Key renames for the messaging options object.\nconst CAMELCASE_OPTIONS_KEYS_MAP = {\n  dryRun: 'dry_run',\n  timeToLive: 'time_to_live',\n  collapseKey: 'collapse_key',\n  mutableContent: 'mutable_content',\n  contentAvailable: 'content_available',\n  restrictedPackageName: 'restricted_package_name'\n};\n// Key renames for the MessagingDeviceResult object.\nconst MESSAGING_DEVICE_RESULT_KEYS_MAP = {\n  message_id: 'messageId',\n  registration_id: 'canonicalRegistrationToken'\n};\n// Key renames for the MessagingDevicesResponse object.\nconst MESSAGING_DEVICES_RESPONSE_KEYS_MAP = {\n  canonical_ids: 'canonicalRegistrationTokenCount',\n  failure: 'failureCount',\n  success: 'successCount',\n  multicast_id: 'multicastId'\n};\n// Key renames for the MessagingDeviceGroupResponse object.\nconst MESSAGING_DEVICE_GROUP_RESPONSE_KEYS_MAP = {\n  success: 'successCount',\n  failure: 'failureCount',\n  failed_registration_ids: 'failedRegistrationTokens'\n};\n// Key renames for the MessagingTopicResponse object.\nconst MESSAGING_TOPIC_RESPONSE_KEYS_MAP = {\n  message_id: 'messageId'\n};\n// Key renames for the MessagingConditionResponse object.\nconst MESSAGING_CONDITION_RESPONSE_KEYS_MAP = {\n  message_id: 'messageId'\n};\n/**\n * Maps a raw FCM server response to a `MessagingDevicesResponse` object.\n *\n * @param response - The raw FCM server response to map.\n *\n * @returns The mapped `MessagingDevicesResponse` object.\n */\nfunction mapRawResponseToDevicesResponse(response) {\n  // Rename properties on the server response\n  utils.renameProperties(response, MESSAGING_DEVICES_RESPONSE_KEYS_MAP);\n  if ('results' in response) {\n    response.results.forEach(messagingDeviceResult => {\n      utils.renameProperties(messagingDeviceResult, MESSAGING_DEVICE_RESULT_KEYS_MAP);\n      // Map the FCM server's error strings to actual error objects.\n      if ('error' in messagingDeviceResult) {\n        const newError = error_1.FirebaseMessagingError.fromServerError(messagingDeviceResult.error, /* message */undefined, messagingDeviceResult.error);\n        messagingDeviceResult.error = newError;\n      }\n    });\n  }\n  return response;\n}\n/**\n * Maps a raw FCM server response to a `MessagingDeviceGroupResponse` object.\n *\n * @param response - The raw FCM server response to map.\n *\n * @returns The mapped `MessagingDeviceGroupResponse` object.\n */\nfunction mapRawResponseToDeviceGroupResponse(response) {\n  // Rename properties on the server response\n  utils.renameProperties(response, MESSAGING_DEVICE_GROUP_RESPONSE_KEYS_MAP);\n  // Add the 'failedRegistrationTokens' property if it does not exist on the response, which\n  // it won't when the 'failureCount' property has a value of 0)\n  response.failedRegistrationTokens = response.failedRegistrationTokens || [];\n  return response;\n}\n/**\n * Maps a raw FCM server response to a `MessagingTopicManagementResponse` object.\n *\n * @param {object} response The raw FCM server response to map.\n *\n * @returns {MessagingTopicManagementResponse} The mapped `MessagingTopicManagementResponse` object.\n */\nfunction mapRawResponseToTopicManagementResponse(response) {\n  // Add the success and failure counts.\n  const result = {\n    successCount: 0,\n    failureCount: 0,\n    errors: []\n  };\n  if ('results' in response) {\n    response.results.forEach((tokenManagementResult, index) => {\n      // Map the FCM server's error strings to actual error objects.\n      if ('error' in tokenManagementResult) {\n        result.failureCount += 1;\n        const newError = error_1.FirebaseMessagingError.fromTopicManagementServerError(tokenManagementResult.error, /* message */undefined, tokenManagementResult.error);\n        result.errors.push({\n          index,\n          error: newError\n        });\n      } else {\n        result.successCount += 1;\n      }\n    });\n  }\n  return result;\n}\n/**\n * Messaging service bound to the provided app.\n */\nclass Messaging {\n  /**\n   * @internal\n   */\n  constructor(app) {\n    this.useLegacyTransport = false;\n    if (!validator.isNonNullObject(app) || !('options' in app)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.messaging() must be a valid Firebase app instance.');\n    }\n    this.appInternal = app;\n    this.messagingRequestHandler = new messaging_api_request_internal_1.FirebaseMessagingRequestHandler(app);\n  }\n  /**\n   * The {@link firebase-admin.app#App} associated with the current `Messaging` service\n   * instance.\n   *\n   * @example\n   * ```javascript\n   * var app = messaging.app;\n   * ```\n   */\n  get app() {\n    return this.appInternal;\n  }\n  /**\n   * Enables the use of legacy HTTP/1.1 transport for `sendEach()` and `sendEachForMulticast()`.\n   *\n   * @example\n   * ```javascript\n   * const messaging = getMessaging(app);\n   * messaging.enableLegacyTransport();\n   * messaging.sendEach(messages);\n   * ```\n   *\n   * @deprecated This will be removed when the HTTP/2 transport implementation reaches the same\n   * stability as the legacy HTTP/1.1 implementation.\n   */\n  enableLegacyHttpTransport() {\n    this.useLegacyTransport = true;\n  }\n  /**\n   * Sends the given message via FCM.\n   *\n   * @param message - The message payload.\n   * @param dryRun - Whether to send the message in the dry-run\n   *   (validation only) mode.\n   * @returns A promise fulfilled with a unique message ID\n   *   string after the message has been successfully handed off to the FCM\n   *   service for delivery.\n   */\n  send(message, dryRun) {\n    const copy = (0, deep_copy_1.deepCopy)(message);\n    (0, messaging_internal_1.validateMessage)(copy);\n    if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');\n    }\n    return this.getUrlPath().then(urlPath => {\n      const request = {\n        message: copy\n      };\n      if (dryRun) {\n        request.validate_only = true;\n      }\n      return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, urlPath, request);\n    }).then(response => {\n      return response.name;\n    });\n  }\n  /**\n  * Sends each message in the given array via Firebase Cloud Messaging.\n  *\n  * Unlike {@link Messaging.sendAll}, this method makes a single RPC call for each message\n  * in the given array.\n  *\n  * The responses list obtained from the return value corresponds to the order of `messages`.\n  * An error from this method or a `BatchResponse` with all failures indicates a total failure,\n  * meaning that none of the messages in the list could be sent. Partial failures or no\n  * failures are only indicated by a `BatchResponse` return value.\n  *\n  * @param messages - A non-empty array\n  *   containing up to 500 messages.\n  * @param dryRun - Whether to send the messages in the dry-run\n  *   (validation only) mode.\n  * @returns A Promise fulfilled with an object representing the result of the\n  *   send operation.\n  */\n  sendEach(messages, dryRun) {\n    if (validator.isArray(messages) && messages.constructor !== Array) {\n      // In more recent JS specs, an array-like object might have a constructor that is not of\n      // Array type. Our deepCopy() method doesn't handle them properly. Convert such objects to\n      // a regular array here before calling deepCopy(). See issue #566 for details.\n      messages = Array.from(messages);\n    }\n    const copy = (0, deep_copy_1.deepCopy)(messages);\n    if (!validator.isNonEmptyArray(copy)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'messages must be a non-empty array');\n    }\n    if (copy.length > FCM_MAX_BATCH_SIZE) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `messages list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);\n    }\n    if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');\n    }\n    const http2SessionHandler = this.useLegacyTransport ? undefined : new api_request_1.Http2SessionHandler(`https://${FCM_SEND_HOST}`);\n    return this.getUrlPath().then(urlPath => {\n      const requests = copy.map(async message => {\n        (0, messaging_internal_1.validateMessage)(message);\n        const request = {\n          message\n        };\n        if (dryRun) {\n          request.validate_only = true;\n        }\n        if (http2SessionHandler) {\n          return this.messagingRequestHandler.invokeHttp2RequestHandlerForSendResponse(FCM_SEND_HOST, urlPath, request, http2SessionHandler);\n        }\n        return this.messagingRequestHandler.invokeHttpRequestHandlerForSendResponse(FCM_SEND_HOST, urlPath, request);\n      });\n      return Promise.allSettled(requests);\n    }).then(results => {\n      const responses = [];\n      results.forEach(result => {\n        if (result.status === 'fulfilled') {\n          responses.push(result.value);\n        } else {\n          // rejected\n          responses.push({\n            success: false,\n            error: result.reason\n          });\n        }\n      });\n      const successCount = responses.filter(resp => resp.success).length;\n      return {\n        responses,\n        successCount,\n        failureCount: responses.length - successCount\n      };\n    }).finally(() => {\n      if (http2SessionHandler) {\n        http2SessionHandler.close();\n      }\n    });\n  }\n  /**\n   * Sends the given multicast message to all the FCM registration tokens\n   * specified in it.\n   *\n   * This method uses the {@link Messaging.sendEach} API under the hood to send the given\n   * message to all the target recipients. The responses list obtained from the\n   * return value corresponds to the order of tokens in the `MulticastMessage`.\n   * An error from this method or a `BatchResponse` with all failures indicates a total\n   * failure, meaning that the messages in the list could be sent. Partial failures or\n   * failures are only indicated by a `BatchResponse` return value.\n   *\n   * @param message - A multicast message\n   *   containing up to 500 tokens.\n   * @param dryRun - Whether to send the message in the dry-run\n   *   (validation only) mode.\n   * @returns A Promise fulfilled with an object representing the result of the\n   *   send operation.\n   */\n  sendEachForMulticast(message, dryRun) {\n    const copy = (0, deep_copy_1.deepCopy)(message);\n    if (!validator.isNonNullObject(copy)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'MulticastMessage must be a non-null object');\n    }\n    if (!validator.isNonEmptyArray(copy.tokens)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'tokens must be a non-empty array');\n    }\n    if (copy.tokens.length > FCM_MAX_BATCH_SIZE) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `tokens list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);\n    }\n    const messages = copy.tokens.map(token => {\n      return {\n        token,\n        android: copy.android,\n        apns: copy.apns,\n        data: copy.data,\n        notification: copy.notification,\n        webpush: copy.webpush,\n        fcmOptions: copy.fcmOptions\n      };\n    });\n    return this.sendEach(messages, dryRun);\n  }\n  /**\n   * Sends all the messages in the given array via Firebase Cloud Messaging.\n   * Employs batching to send the entire list as a single RPC call. Compared\n   * to the `send()` method, this method is a significantly more efficient way\n   * to send multiple messages.\n   *\n   * The responses list obtained from the return value\n   * corresponds to the order of tokens in the `MulticastMessage`. An error\n   * from this method indicates a total failure, meaning that none of the messages\n   * in the list could be sent. Partial failures are indicated by a `BatchResponse`\n   * return value.\n   *\n   * @param messages - A non-empty array\n   *   containing up to 500 messages.\n   * @param dryRun - Whether to send the messages in the dry-run\n   *   (validation only) mode.\n   * @returns A Promise fulfilled with an object representing the result of the\n   *   send operation.\n   *\n   * @deprecated Use {@link Messaging.sendEach} instead.\n   */\n  sendAll(messages, dryRun) {\n    if (validator.isArray(messages) && messages.constructor !== Array) {\n      // In more recent JS specs, an array-like object might have a constructor that is not of\n      // Array type. Our deepCopy() method doesn't handle them properly. Convert such objects to\n      // a regular array here before calling deepCopy(). See issue #566 for details.\n      messages = Array.from(messages);\n    }\n    const copy = (0, deep_copy_1.deepCopy)(messages);\n    if (!validator.isNonEmptyArray(copy)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'messages must be a non-empty array');\n    }\n    if (copy.length > FCM_MAX_BATCH_SIZE) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `messages list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);\n    }\n    if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');\n    }\n    return this.getUrlPath().then(urlPath => {\n      const requests = copy.map(message => {\n        (0, messaging_internal_1.validateMessage)(message);\n        const request = {\n          message\n        };\n        if (dryRun) {\n          request.validate_only = true;\n        }\n        return {\n          url: `https://${FCM_SEND_HOST}${urlPath}`,\n          body: request\n        };\n      });\n      return this.messagingRequestHandler.sendBatchRequest(requests);\n    });\n  }\n  /**\n   * Sends the given multicast message to all the FCM registration tokens\n   * specified in it.\n   *\n   * This method uses the `sendAll()` API under the hood to send the given\n   * message to all the target recipients. The responses list obtained from the\n   * return value corresponds to the order of tokens in the `MulticastMessage`.\n   * An error from this method indicates a total failure, meaning that the message\n   * was not sent to any of the tokens in the list. Partial failures are indicated\n   * by a `BatchResponse` return value.\n   *\n   * @param message - A multicast message\n   *   containing up to 500 tokens.\n   * @param dryRun - Whether to send the message in the dry-run\n   *   (validation only) mode.\n   * @returns A Promise fulfilled with an object representing the result of the\n   *   send operation.\n   *\n   * @deprecated Use {@link Messaging.sendEachForMulticast} instead.\n   */\n  sendMulticast(message, dryRun) {\n    const copy = (0, deep_copy_1.deepCopy)(message);\n    if (!validator.isNonNullObject(copy)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'MulticastMessage must be a non-null object');\n    }\n    if (!validator.isNonEmptyArray(copy.tokens)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'tokens must be a non-empty array');\n    }\n    if (copy.tokens.length > FCM_MAX_BATCH_SIZE) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `tokens list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);\n    }\n    const messages = copy.tokens.map(token => {\n      return {\n        token,\n        android: copy.android,\n        apns: copy.apns,\n        data: copy.data,\n        notification: copy.notification,\n        webpush: copy.webpush,\n        fcmOptions: copy.fcmOptions\n      };\n    });\n    return this.sendAll(messages, dryRun);\n  }\n  /**\n   * Sends an FCM message to a single device corresponding to the provided\n   * registration token.\n   *\n   * See {@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_individual_devices |\n   * Send to individual devices}\n   * for code samples and detailed documentation. Takes either a\n   * `registrationToken` to send to a single device or a\n   * `registrationTokens` parameter containing an array of tokens to send\n   * to multiple devices.\n   *\n   * @param registrationToken - A device registration token or an array of\n   *   device registration tokens to which the message should be sent.\n   * @param payload - The message payload.\n   * @param options - Optional options to\n   *   alter the message.\n   *\n   * @returns A promise fulfilled with the server's response after the message\n   *   has been sent.\n   *\n   * @deprecated Use {@link Messaging.send} instead.\n   */\n  sendToDevice(registrationTokenOrTokens, payload) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // Validate the input argument types. Since these are common developer errors when getting\n    // started, throw an error instead of returning a rejected promise.\n    this.validateRegistrationTokensType(registrationTokenOrTokens, 'sendToDevice', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n    this.validateMessagingPayloadAndOptionsTypes(payload, options);\n    return Promise.resolve().then(() => {\n      // Validate the contents of the input arguments. Because we are now in a promise, any thrown\n      // error will cause this method to return a rejected promise.\n      this.validateRegistrationTokens(registrationTokenOrTokens, 'sendToDevice', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n      const payloadCopy = this.validateMessagingPayload(payload);\n      const optionsCopy = this.validateMessagingOptions(options);\n      const request = (0, deep_copy_1.deepCopy)(payloadCopy);\n      (0, deep_copy_1.deepExtend)(request, optionsCopy);\n      if (validator.isString(registrationTokenOrTokens)) {\n        request.to = registrationTokenOrTokens;\n      } else {\n        request.registration_ids = registrationTokenOrTokens;\n      }\n      return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n    }).then(response => {\n      // The sendToDevice() and sendToDeviceGroup() methods both set the `to` query parameter in\n      // the underlying FCM request. If the provided registration token argument is actually a\n      // valid notification key, the response from the FCM server will be a device group response.\n      // If that is the case, we map the response to a MessagingDeviceGroupResponse.\n      // See b/35394951 for more context.\n      if ('multicast_id' in response) {\n        return mapRawResponseToDevicesResponse(response);\n      } else {\n        const groupResponse = mapRawResponseToDeviceGroupResponse(response);\n        return {\n          ...groupResponse,\n          canonicalRegistrationTokenCount: -1,\n          multicastId: -1,\n          results: []\n        };\n      }\n    });\n  }\n  /**\n   * Sends an FCM message to a device group corresponding to the provided\n   * notification key.\n   *\n   * See {@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_a_device_group |\n   * Send to a device group} for code samples and detailed documentation.\n   *\n   * @param notificationKey - The notification key for the device group to\n   *   which to send the message.\n   * @param payload - The message payload.\n   * @param options - Optional options to\n   *   alter the message.\n   *\n   * @returns A promise fulfilled with the server's response after the message\n   *   has been sent.\n   *\n   * @deprecated Use {@link Messaging.send} instead.\n   */\n  sendToDeviceGroup(notificationKey, payload) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!validator.isNonEmptyString(notificationKey)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() must be a non-empty string.');\n    } else if (notificationKey.indexOf(':') !== -1) {\n      // It is possible the developer provides a registration token instead of a notification key\n      // to this method. We can detect some of those cases by checking to see if the string contains\n      // a colon. Not all registration tokens will contain a colon (only newer ones will), but no\n      // notification keys will contain a colon, so we can use it as a rough heuristic.\n      // See b/35394951 for more context.\n      return Promise.reject(new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() has the format of a registration token. ' + 'You should use sendToDevice() instead.'));\n    }\n    // Validate the types of the payload and options arguments. Since these are common developer\n    // errors, throw an error instead of returning a rejected promise.\n    this.validateMessagingPayloadAndOptionsTypes(payload, options);\n    return Promise.resolve().then(() => {\n      // Validate the contents of the payload and options objects. Because we are now in a\n      // promise, any thrown error will cause this method to return a rejected promise.\n      const payloadCopy = this.validateMessagingPayload(payload);\n      const optionsCopy = this.validateMessagingOptions(options);\n      const request = (0, deep_copy_1.deepCopy)(payloadCopy);\n      (0, deep_copy_1.deepExtend)(request, optionsCopy);\n      request.to = notificationKey;\n      return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n    }).then(response => {\n      // The sendToDevice() and sendToDeviceGroup() methods both set the `to` query parameter in\n      // the underlying FCM request. If the provided notification key argument has an invalid\n      // format (that is, it is either a registration token or some random string), the response\n      // from the FCM server will default to a devices response (which we detect by looking for\n      // the `multicast_id` property). If that is the case, we either throw an error saying the\n      // provided notification key is invalid (if the message failed to send) or map the response\n      // to a MessagingDevicesResponse (if the message succeeded).\n      // See b/35394951 for more context.\n      if ('multicast_id' in response) {\n        if (response.success === 0) {\n          throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() is invalid.');\n        } else {\n          const devicesResponse = mapRawResponseToDevicesResponse(response);\n          return {\n            ...devicesResponse,\n            failedRegistrationTokens: []\n          };\n        }\n      }\n      return mapRawResponseToDeviceGroupResponse(response);\n    });\n  }\n  /**\n   * Sends an FCM message to a topic.\n   *\n   * See {@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_a_topic |\n   * Send to a topic} for code samples and detailed documentation.\n   *\n   * @param topic - The topic to which to send the message.\n   * @param payload - The message payload.\n   * @param options - Optional options to\n   *   alter the message.\n   *\n   * @returns A promise fulfilled with the server's response after the message\n   *   has been sent.\n   *\n   * @deprecated Use {@link Messaging.send} instead.\n   */\n  sendToTopic(topic, payload) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // Validate the input argument types. Since these are common developer errors when getting\n    // started, throw an error instead of returning a rejected promise.\n    this.validateTopicType(topic, 'sendToTopic', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n    this.validateMessagingPayloadAndOptionsTypes(payload, options);\n    // Prepend the topic with /topics/ if necessary.\n    topic = this.normalizeTopic(topic);\n    return Promise.resolve().then(() => {\n      // Validate the contents of the payload and options objects. Because we are now in a\n      // promise, any thrown error will cause this method to return a rejected promise.\n      const payloadCopy = this.validateMessagingPayload(payload);\n      const optionsCopy = this.validateMessagingOptions(options);\n      this.validateTopic(topic, 'sendToTopic', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n      const request = (0, deep_copy_1.deepCopy)(payloadCopy);\n      (0, deep_copy_1.deepExtend)(request, optionsCopy);\n      request.to = topic;\n      return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n    }).then(response => {\n      // Rename properties on the server response\n      utils.renameProperties(response, MESSAGING_TOPIC_RESPONSE_KEYS_MAP);\n      return response;\n    });\n  }\n  /**\n   * Sends an FCM message to a condition.\n   *\n   * See {@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_a_condition |\n   * Send to a condition}\n   * for code samples and detailed documentation.\n   *\n   * @param condition - The condition determining to which topics to send\n   *   the message.\n   * @param payload - The message payload.\n   * @param options - Optional options to\n   *   alter the message.\n   *\n   * @returns A promise fulfilled with the server's response after the message\n   *   has been sent.\n   *\n   * @deprecated Use {@link Messaging.send} instead.\n   */\n  sendToCondition(condition, payload) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!validator.isNonEmptyString(condition)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Condition provided to sendToCondition() must be a non-empty string.');\n    }\n    // Validate the types of the payload and options arguments. Since these are common developer\n    // errors, throw an error instead of returning a rejected promise.\n    this.validateMessagingPayloadAndOptionsTypes(payload, options);\n    // The FCM server rejects conditions which are surrounded in single quotes. When the condition\n    // is stringified over the wire, double quotes in it get converted to \\\" which the FCM server\n    // does not properly handle. We can get around this by replacing internal double quotes with\n    // single quotes.\n    condition = condition.replace(/\"/g, '\\'');\n    return Promise.resolve().then(() => {\n      // Validate the contents of the payload and options objects. Because we are now in a\n      // promise, any thrown error will cause this method to return a rejected promise.\n      const payloadCopy = this.validateMessagingPayload(payload);\n      const optionsCopy = this.validateMessagingOptions(options);\n      const request = (0, deep_copy_1.deepCopy)(payloadCopy);\n      (0, deep_copy_1.deepExtend)(request, optionsCopy);\n      request.condition = condition;\n      return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n    }).then(response => {\n      // Rename properties on the server response\n      utils.renameProperties(response, MESSAGING_CONDITION_RESPONSE_KEYS_MAP);\n      return response;\n    });\n  }\n  /**\n   * Subscribes a device to an FCM topic.\n   *\n   * See {@link https://firebase.google.com/docs/cloud-messaging/manage-topics#suscribe_and_unsubscribe_using_the |\n   * Subscribe to a topic}\n   * for code samples and detailed documentation. Optionally, you can provide an\n   * array of tokens to subscribe multiple devices.\n   *\n   * @param registrationTokens - A token or array of registration tokens\n   *   for the devices to subscribe to the topic.\n   * @param topic - The topic to which to subscribe.\n   *\n   * @returns A promise fulfilled with the server's response after the device has been\n   *   subscribed to the topic.\n   */\n  subscribeToTopic(registrationTokenOrTokens, topic) {\n    return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'subscribeToTopic', FCM_TOPIC_MANAGEMENT_ADD_PATH);\n  }\n  /**\n   * Unsubscribes a device from an FCM topic.\n   *\n   * See {@link https://firebase.google.com/docs/cloud-messaging/admin/manage-topic-subscriptions#unsubscribe_from_a_topic |\n   * Unsubscribe from a topic}\n   * for code samples and detailed documentation.  Optionally, you can provide an\n   * array of tokens to unsubscribe multiple devices.\n   *\n   * @param registrationTokens - A device registration token or an array of\n   *   device registration tokens to unsubscribe from the topic.\n   * @param topic - The topic from which to unsubscribe.\n   *\n   * @returns A promise fulfilled with the server's response after the device has been\n   *   unsubscribed from the topic.\n   */\n  unsubscribeFromTopic(registrationTokenOrTokens, topic) {\n    return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'unsubscribeFromTopic', FCM_TOPIC_MANAGEMENT_REMOVE_PATH);\n  }\n  getUrlPath() {\n    if (this.urlPath) {\n      return Promise.resolve(this.urlPath);\n    }\n    return utils.findProjectId(this.app).then(projectId => {\n      if (!validator.isNonEmptyString(projectId)) {\n        // Assert for an explicit project ID (either via AppOptions or the cert itself).\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'Failed to determine project ID for Messaging. Initialize the ' + 'SDK with service account credentials or set project ID as an app option. ' + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');\n      }\n      this.urlPath = `/v1/projects/${projectId}/messages:send`;\n      return this.urlPath;\n    });\n  }\n  /**\n   * Helper method which sends and handles topic subscription management requests.\n   *\n   * @param registrationTokenOrTokens - The registration token or an array of\n   *     registration tokens to unsubscribe from the topic.\n   * @param topic - The topic to which to subscribe.\n   * @param methodName - The name of the original method called.\n   * @param path - The endpoint path to use for the request.\n   *\n   * @returns A Promise fulfilled with the parsed server\n   *   response.\n   */\n  sendTopicManagementRequest(registrationTokenOrTokens, topic, methodName, path) {\n    this.validateRegistrationTokensType(registrationTokenOrTokens, methodName);\n    this.validateTopicType(topic, methodName);\n    // Prepend the topic with /topics/ if necessary.\n    topic = this.normalizeTopic(topic);\n    return Promise.resolve().then(() => {\n      // Validate the contents of the input arguments. Because we are now in a promise, any thrown\n      // error will cause this method to return a rejected promise.\n      this.validateRegistrationTokens(registrationTokenOrTokens, methodName);\n      this.validateTopic(topic, methodName);\n      // Ensure the registration token(s) input argument is an array.\n      let registrationTokensArray = registrationTokenOrTokens;\n      if (validator.isString(registrationTokenOrTokens)) {\n        registrationTokensArray = [registrationTokenOrTokens];\n      }\n      const request = {\n        to: topic,\n        registration_tokens: registrationTokensArray\n      };\n      return this.messagingRequestHandler.invokeRequestHandler(FCM_TOPIC_MANAGEMENT_HOST, path, request);\n    }).then(response => {\n      return mapRawResponseToTopicManagementResponse(response);\n    });\n  }\n  /**\n   * Validates the types of the messaging payload and options. If invalid, an error will be thrown.\n   *\n   * @param payload - The messaging payload to validate.\n   * @param options - The messaging options to validate.\n   */\n  validateMessagingPayloadAndOptionsTypes(payload, options) {\n    // Validate the payload is an object\n    if (!validator.isNonNullObject(payload)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Messaging payload must be an object with at least one of the \"data\" or \"notification\" properties.');\n    }\n    // Validate the options argument is an object\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, 'Messaging options must be an object.');\n    }\n  }\n  /**\n   * Validates the messaging payload. If invalid, an error will be thrown.\n   *\n   * @param payload - The messaging payload to validate.\n   *\n   * @returns A copy of the provided payload with whitelisted properties switched\n   *     from camelCase to underscore_case.\n   */\n  validateMessagingPayload(payload) {\n    const payloadCopy = (0, deep_copy_1.deepCopy)(payload);\n    const payloadKeys = Object.keys(payloadCopy);\n    const validPayloadKeys = ['data', 'notification'];\n    let containsDataOrNotificationKey = false;\n    payloadKeys.forEach(payloadKey => {\n      // Validate the payload does not contain any invalid keys\n      if (validPayloadKeys.indexOf(payloadKey) === -1) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains an invalid \"${payloadKey}\" property. Valid properties are ` + '\"data\" and \"notification\".');\n      } else {\n        containsDataOrNotificationKey = true;\n      }\n    });\n    // Validate the payload contains at least one of the \"data\" and \"notification\" keys\n    if (!containsDataOrNotificationKey) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Messaging payload must contain at least one of the \"data\" or \"notification\" properties.');\n    }\n    const validatePayload = (payloadKey, value) => {\n      // Validate each top-level key in the payload is an object\n      if (!validator.isNonNullObject(value)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains an invalid value for the \"${payloadKey}\" property. ` + 'Value must be an object.');\n      }\n      Object.keys(value).forEach(subKey => {\n        if (!validator.isString(value[subKey])) {\n          // Validate all sub-keys have a string value\n          throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains an invalid value for the \"${payloadKey}.${subKey}\" ` + 'property. Values must be strings.');\n        } else if (payloadKey === 'data' && /^google\\./.test(subKey)) {\n          // Validate the data payload does not contain keys which start with 'google.'.\n          throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains the blacklisted \"data.${subKey}\" property.`);\n        }\n      });\n    };\n    if (payloadCopy.data !== undefined) {\n      validatePayload('data', payloadCopy.data);\n    }\n    if (payloadCopy.notification !== undefined) {\n      validatePayload('notification', payloadCopy.notification);\n    }\n    // Validate the data payload object does not contain blacklisted properties\n    if ('data' in payloadCopy) {\n      messaging_internal_1.BLACKLISTED_DATA_PAYLOAD_KEYS.forEach(blacklistedKey => {\n        if (blacklistedKey in payloadCopy.data) {\n          throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains the blacklisted \"data.${blacklistedKey}\" property.`);\n        }\n      });\n    }\n    // Convert whitelisted camelCase keys to underscore_case\n    if (payloadCopy.notification) {\n      utils.renameProperties(payloadCopy.notification, CAMELCASED_NOTIFICATION_PAYLOAD_KEYS_MAP);\n    }\n    return payloadCopy;\n  }\n  /**\n   * Validates the messaging options. If invalid, an error will be thrown.\n   *\n   * @param options - The messaging options to validate.\n   *\n   * @returns A copy of the provided options with whitelisted properties switched\n   *   from camelCase to underscore_case.\n   */\n  validateMessagingOptions(options) {\n    const optionsCopy = (0, deep_copy_1.deepCopy)(options);\n    // Validate the options object does not contain blacklisted properties\n    messaging_internal_1.BLACKLISTED_OPTIONS_KEYS.forEach(blacklistedKey => {\n      if (blacklistedKey in optionsCopy) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains the blacklisted \"${blacklistedKey}\" property.`);\n      }\n    });\n    // Convert whitelisted camelCase keys to underscore_case\n    utils.renameProperties(optionsCopy, CAMELCASE_OPTIONS_KEYS_MAP);\n    // Validate the options object contains valid values for whitelisted properties\n    if ('collapse_key' in optionsCopy && !validator.isNonEmptyString(optionsCopy.collapse_key)) {\n      const keyName = 'collapseKey' in options ? 'collapseKey' : 'collapse_key';\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the \"${keyName}\" property. Value must ` + 'be a non-empty string.');\n    } else if ('dry_run' in optionsCopy && !validator.isBoolean(optionsCopy.dry_run)) {\n      const keyName = 'dryRun' in options ? 'dryRun' : 'dry_run';\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the \"${keyName}\" property. Value must ` + 'be a boolean.');\n    } else if ('priority' in optionsCopy && !validator.isNonEmptyString(optionsCopy.priority)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, 'Messaging options contains an invalid value for the \"priority\" property. Value must ' + 'be a non-empty string.');\n    } else if ('restricted_package_name' in optionsCopy && !validator.isNonEmptyString(optionsCopy.restricted_package_name)) {\n      const keyName = 'restrictedPackageName' in options ? 'restrictedPackageName' : 'restricted_package_name';\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the \"${keyName}\" property. Value must ` + 'be a non-empty string.');\n    } else if ('time_to_live' in optionsCopy && !validator.isNumber(optionsCopy.time_to_live)) {\n      const keyName = 'timeToLive' in options ? 'timeToLive' : 'time_to_live';\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the \"${keyName}\" property. Value must ` + 'be a number.');\n    } else if ('content_available' in optionsCopy && !validator.isBoolean(optionsCopy.content_available)) {\n      const keyName = 'contentAvailable' in options ? 'contentAvailable' : 'content_available';\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the \"${keyName}\" property. Value must ` + 'be a boolean.');\n    } else if ('mutable_content' in optionsCopy && !validator.isBoolean(optionsCopy.mutable_content)) {\n      const keyName = 'mutableContent' in options ? 'mutableContent' : 'mutable_content';\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the \"${keyName}\" property. Value must ` + 'be a boolean.');\n    }\n    return optionsCopy;\n  }\n  /**\n   * Validates the type of the provided registration token(s). If invalid, an error will be thrown.\n   *\n   * @param registrationTokenOrTokens - The registration token(s) to validate.\n   * @param method - The method name to use in error messages.\n   * @param errorInfo - The error info to use if the registration tokens are invalid.\n   */\n  validateRegistrationTokensType(registrationTokenOrTokens, methodName) {\n    let errorInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : error_1.MessagingClientErrorCode.INVALID_ARGUMENT;\n    if (!validator.isNonEmptyArray(registrationTokenOrTokens) && !validator.isNonEmptyString(registrationTokenOrTokens)) {\n      throw new error_1.FirebaseMessagingError(errorInfo, `Registration token(s) provided to ${methodName}() must be a non-empty string or a ` + 'non-empty array.');\n    }\n  }\n  /**\n   * Validates the provided registration tokens. If invalid, an error will be thrown.\n   *\n   * @param registrationTokenOrTokens - The registration token or an array of\n   *     registration tokens to validate.\n   * @param method - The method name to use in error messages.\n   * @param errorInfo - The error info to use if the registration tokens are invalid.\n   */\n  validateRegistrationTokens(registrationTokenOrTokens, methodName) {\n    let errorInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : error_1.MessagingClientErrorCode.INVALID_ARGUMENT;\n    if (validator.isArray(registrationTokenOrTokens)) {\n      // Validate the array contains no more than 1,000 registration tokens.\n      if (registrationTokenOrTokens.length > 1000) {\n        throw new error_1.FirebaseMessagingError(errorInfo, `Too many registration tokens provided in a single request to ${methodName}(). Batch ` + 'your requests to contain no more than 1,000 registration tokens per request.');\n      }\n      // Validate the array contains registration tokens which are non-empty strings.\n      registrationTokenOrTokens.forEach((registrationToken, index) => {\n        if (!validator.isNonEmptyString(registrationToken)) {\n          throw new error_1.FirebaseMessagingError(errorInfo, `Registration token provided to ${methodName}() at index ${index} must be a ` + 'non-empty string.');\n        }\n      });\n    }\n  }\n  /**\n   * Validates the type of the provided topic. If invalid, an error will be thrown.\n   *\n   * @param topic - The topic to validate.\n   * @param method - The method name to use in error messages.\n   * @param errorInfo - The error info to use if the topic is invalid.\n   */\n  validateTopicType(topic, methodName) {\n    let errorInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : error_1.MessagingClientErrorCode.INVALID_ARGUMENT;\n    if (!validator.isNonEmptyString(topic)) {\n      throw new error_1.FirebaseMessagingError(errorInfo, `Topic provided to ${methodName}() must be a string which matches the format ` + '\"/topics/[a-zA-Z0-9-_.~%]+\".');\n    }\n  }\n  /**\n   * Validates the provided topic. If invalid, an error will be thrown.\n   *\n   * @param topic - The topic to validate.\n   * @param method - The method name to use in error messages.\n   * @param errorInfo - The error info to use if the topic is invalid.\n   */\n  validateTopic(topic, methodName) {\n    let errorInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : error_1.MessagingClientErrorCode.INVALID_ARGUMENT;\n    if (!validator.isTopic(topic)) {\n      throw new error_1.FirebaseMessagingError(errorInfo, `Topic provided to ${methodName}() must be a string which matches the format ` + '\"/topics/[a-zA-Z0-9-_.~%]+\".');\n    }\n  }\n  /**\n   * Normalizes the provided topic name by prepending it with '/topics/', if necessary.\n   *\n   * @param topic - The topic name to normalize.\n   *\n   * @returns The normalized topic name.\n   */\n  normalizeTopic(topic) {\n    if (!/^\\/topics\\//.test(topic)) {\n      topic = `/topics/${topic}`;\n    }\n    return topic;\n  }\n}\nexports.Messaging = Messaging;","map":{"version":3,"names":["Object","defineProperty","exports","value","Messaging","deep_copy_1","require","error_1","utils","validator","messaging_internal_1","messaging_api_request_internal_1","api_request_1","FCM_SEND_HOST","FCM_SEND_PATH","FCM_TOPIC_MANAGEMENT_HOST","FCM_TOPIC_MANAGEMENT_ADD_PATH","FCM_TOPIC_MANAGEMENT_REMOVE_PATH","FCM_MAX_BATCH_SIZE","CAMELCASED_NOTIFICATION_PAYLOAD_KEYS_MAP","bodyLocArgs","bodyLocKey","clickAction","titleLocArgs","titleLocKey","CAMELCASE_OPTIONS_KEYS_MAP","dryRun","timeToLive","collapseKey","mutableContent","contentAvailable","restrictedPackageName","MESSAGING_DEVICE_RESULT_KEYS_MAP","message_id","registration_id","MESSAGING_DEVICES_RESPONSE_KEYS_MAP","canonical_ids","failure","success","multicast_id","MESSAGING_DEVICE_GROUP_RESPONSE_KEYS_MAP","failed_registration_ids","MESSAGING_TOPIC_RESPONSE_KEYS_MAP","MESSAGING_CONDITION_RESPONSE_KEYS_MAP","mapRawResponseToDevicesResponse","response","renameProperties","results","forEach","messagingDeviceResult","newError","FirebaseMessagingError","fromServerError","error","undefined","mapRawResponseToDeviceGroupResponse","failedRegistrationTokens","mapRawResponseToTopicManagementResponse","result","successCount","failureCount","errors","tokenManagementResult","index","fromTopicManagementServerError","push","constructor","app","useLegacyTransport","isNonNullObject","MessagingClientErrorCode","INVALID_ARGUMENT","appInternal","messagingRequestHandler","FirebaseMessagingRequestHandler","enableLegacyHttpTransport","send","message","copy","deepCopy","validateMessage","isBoolean","getUrlPath","then","urlPath","request","validate_only","invokeRequestHandler","name","sendEach","messages","isArray","Array","from","isNonEmptyArray","length","http2SessionHandler","Http2SessionHandler","requests","map","invokeHttp2RequestHandlerForSendResponse","invokeHttpRequestHandlerForSendResponse","Promise","allSettled","responses","status","reason","filter","resp","finally","close","sendEachForMulticast","tokens","token","android","apns","data","notification","webpush","fcmOptions","sendAll","url","body","sendBatchRequest","sendMulticast","sendToDevice","registrationTokenOrTokens","payload","options","validateRegistrationTokensType","INVALID_RECIPIENT","validateMessagingPayloadAndOptionsTypes","resolve","validateRegistrationTokens","payloadCopy","validateMessagingPayload","optionsCopy","validateMessagingOptions","deepExtend","isString","to","registration_ids","groupResponse","canonicalRegistrationTokenCount","multicastId","sendToDeviceGroup","notificationKey","isNonEmptyString","indexOf","reject","devicesResponse","sendToTopic","topic","validateTopicType","normalizeTopic","validateTopic","sendToCondition","condition","replace","subscribeToTopic","sendTopicManagementRequest","unsubscribeFromTopic","findProjectId","projectId","methodName","path","registrationTokensArray","registration_tokens","INVALID_PAYLOAD","INVALID_OPTIONS","payloadKeys","keys","validPayloadKeys","containsDataOrNotificationKey","payloadKey","validatePayload","subKey","test","BLACKLISTED_DATA_PAYLOAD_KEYS","blacklistedKey","BLACKLISTED_OPTIONS_KEYS","collapse_key","keyName","dry_run","priority","restricted_package_name","isNumber","time_to_live","content_available","mutable_content","errorInfo","registrationToken","isTopic"],"sources":["/home/yadu/Music/Gifty/node_modules/firebase-admin/lib/messaging/messaging.js"],"sourcesContent":["/*! firebase-admin v12.7.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Messaging = void 0;\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst error_1 = require(\"../utils/error\");\nconst utils = require(\"../utils\");\nconst validator = require(\"../utils/validator\");\nconst messaging_internal_1 = require(\"./messaging-internal\");\nconst messaging_api_request_internal_1 = require(\"./messaging-api-request-internal\");\nconst api_request_1 = require(\"../utils/api-request\");\n// FCM endpoints\nconst FCM_SEND_HOST = 'fcm.googleapis.com';\nconst FCM_SEND_PATH = '/fcm/send';\nconst FCM_TOPIC_MANAGEMENT_HOST = 'iid.googleapis.com';\nconst FCM_TOPIC_MANAGEMENT_ADD_PATH = '/iid/v1:batchAdd';\nconst FCM_TOPIC_MANAGEMENT_REMOVE_PATH = '/iid/v1:batchRemove';\n// Maximum messages that can be included in a batch request.\nconst FCM_MAX_BATCH_SIZE = 500;\n// Key renames for the messaging notification payload object.\nconst CAMELCASED_NOTIFICATION_PAYLOAD_KEYS_MAP = {\n    bodyLocArgs: 'body_loc_args',\n    bodyLocKey: 'body_loc_key',\n    clickAction: 'click_action',\n    titleLocArgs: 'title_loc_args',\n    titleLocKey: 'title_loc_key',\n};\n// Key renames for the messaging options object.\nconst CAMELCASE_OPTIONS_KEYS_MAP = {\n    dryRun: 'dry_run',\n    timeToLive: 'time_to_live',\n    collapseKey: 'collapse_key',\n    mutableContent: 'mutable_content',\n    contentAvailable: 'content_available',\n    restrictedPackageName: 'restricted_package_name',\n};\n// Key renames for the MessagingDeviceResult object.\nconst MESSAGING_DEVICE_RESULT_KEYS_MAP = {\n    message_id: 'messageId',\n    registration_id: 'canonicalRegistrationToken',\n};\n// Key renames for the MessagingDevicesResponse object.\nconst MESSAGING_DEVICES_RESPONSE_KEYS_MAP = {\n    canonical_ids: 'canonicalRegistrationTokenCount',\n    failure: 'failureCount',\n    success: 'successCount',\n    multicast_id: 'multicastId',\n};\n// Key renames for the MessagingDeviceGroupResponse object.\nconst MESSAGING_DEVICE_GROUP_RESPONSE_KEYS_MAP = {\n    success: 'successCount',\n    failure: 'failureCount',\n    failed_registration_ids: 'failedRegistrationTokens',\n};\n// Key renames for the MessagingTopicResponse object.\nconst MESSAGING_TOPIC_RESPONSE_KEYS_MAP = {\n    message_id: 'messageId',\n};\n// Key renames for the MessagingConditionResponse object.\nconst MESSAGING_CONDITION_RESPONSE_KEYS_MAP = {\n    message_id: 'messageId',\n};\n/**\n * Maps a raw FCM server response to a `MessagingDevicesResponse` object.\n *\n * @param response - The raw FCM server response to map.\n *\n * @returns The mapped `MessagingDevicesResponse` object.\n */\nfunction mapRawResponseToDevicesResponse(response) {\n    // Rename properties on the server response\n    utils.renameProperties(response, MESSAGING_DEVICES_RESPONSE_KEYS_MAP);\n    if ('results' in response) {\n        response.results.forEach((messagingDeviceResult) => {\n            utils.renameProperties(messagingDeviceResult, MESSAGING_DEVICE_RESULT_KEYS_MAP);\n            // Map the FCM server's error strings to actual error objects.\n            if ('error' in messagingDeviceResult) {\n                const newError = error_1.FirebaseMessagingError.fromServerError(messagingDeviceResult.error, /* message */ undefined, messagingDeviceResult.error);\n                messagingDeviceResult.error = newError;\n            }\n        });\n    }\n    return response;\n}\n/**\n * Maps a raw FCM server response to a `MessagingDeviceGroupResponse` object.\n *\n * @param response - The raw FCM server response to map.\n *\n * @returns The mapped `MessagingDeviceGroupResponse` object.\n */\nfunction mapRawResponseToDeviceGroupResponse(response) {\n    // Rename properties on the server response\n    utils.renameProperties(response, MESSAGING_DEVICE_GROUP_RESPONSE_KEYS_MAP);\n    // Add the 'failedRegistrationTokens' property if it does not exist on the response, which\n    // it won't when the 'failureCount' property has a value of 0)\n    response.failedRegistrationTokens = response.failedRegistrationTokens || [];\n    return response;\n}\n/**\n * Maps a raw FCM server response to a `MessagingTopicManagementResponse` object.\n *\n * @param {object} response The raw FCM server response to map.\n *\n * @returns {MessagingTopicManagementResponse} The mapped `MessagingTopicManagementResponse` object.\n */\nfunction mapRawResponseToTopicManagementResponse(response) {\n    // Add the success and failure counts.\n    const result = {\n        successCount: 0,\n        failureCount: 0,\n        errors: [],\n    };\n    if ('results' in response) {\n        response.results.forEach((tokenManagementResult, index) => {\n            // Map the FCM server's error strings to actual error objects.\n            if ('error' in tokenManagementResult) {\n                result.failureCount += 1;\n                const newError = error_1.FirebaseMessagingError.fromTopicManagementServerError(tokenManagementResult.error, /* message */ undefined, tokenManagementResult.error);\n                result.errors.push({\n                    index,\n                    error: newError,\n                });\n            }\n            else {\n                result.successCount += 1;\n            }\n        });\n    }\n    return result;\n}\n/**\n * Messaging service bound to the provided app.\n */\nclass Messaging {\n    /**\n     * @internal\n     */\n    constructor(app) {\n        this.useLegacyTransport = false;\n        if (!validator.isNonNullObject(app) || !('options' in app)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.messaging() must be a valid Firebase app instance.');\n        }\n        this.appInternal = app;\n        this.messagingRequestHandler = new messaging_api_request_internal_1.FirebaseMessagingRequestHandler(app);\n    }\n    /**\n     * The {@link firebase-admin.app#App} associated with the current `Messaging` service\n     * instance.\n     *\n     * @example\n     * ```javascript\n     * var app = messaging.app;\n     * ```\n     */\n    get app() {\n        return this.appInternal;\n    }\n    /**\n     * Enables the use of legacy HTTP/1.1 transport for `sendEach()` and `sendEachForMulticast()`.\n     *\n     * @example\n     * ```javascript\n     * const messaging = getMessaging(app);\n     * messaging.enableLegacyTransport();\n     * messaging.sendEach(messages);\n     * ```\n     *\n     * @deprecated This will be removed when the HTTP/2 transport implementation reaches the same\n     * stability as the legacy HTTP/1.1 implementation.\n     */\n    enableLegacyHttpTransport() {\n        this.useLegacyTransport = true;\n    }\n    /**\n     * Sends the given message via FCM.\n     *\n     * @param message - The message payload.\n     * @param dryRun - Whether to send the message in the dry-run\n     *   (validation only) mode.\n     * @returns A promise fulfilled with a unique message ID\n     *   string after the message has been successfully handed off to the FCM\n     *   service for delivery.\n     */\n    send(message, dryRun) {\n        const copy = (0, deep_copy_1.deepCopy)(message);\n        (0, messaging_internal_1.validateMessage)(copy);\n        if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');\n        }\n        return this.getUrlPath()\n            .then((urlPath) => {\n            const request = { message: copy };\n            if (dryRun) {\n                request.validate_only = true;\n            }\n            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, urlPath, request);\n        })\n            .then((response) => {\n            return response.name;\n        });\n    }\n    /**\n    * Sends each message in the given array via Firebase Cloud Messaging.\n    *\n    * Unlike {@link Messaging.sendAll}, this method makes a single RPC call for each message\n    * in the given array.\n    *\n    * The responses list obtained from the return value corresponds to the order of `messages`.\n    * An error from this method or a `BatchResponse` with all failures indicates a total failure,\n    * meaning that none of the messages in the list could be sent. Partial failures or no\n    * failures are only indicated by a `BatchResponse` return value.\n    *\n    * @param messages - A non-empty array\n    *   containing up to 500 messages.\n    * @param dryRun - Whether to send the messages in the dry-run\n    *   (validation only) mode.\n    * @returns A Promise fulfilled with an object representing the result of the\n    *   send operation.\n    */\n    sendEach(messages, dryRun) {\n        if (validator.isArray(messages) && messages.constructor !== Array) {\n            // In more recent JS specs, an array-like object might have a constructor that is not of\n            // Array type. Our deepCopy() method doesn't handle them properly. Convert such objects to\n            // a regular array here before calling deepCopy(). See issue #566 for details.\n            messages = Array.from(messages);\n        }\n        const copy = (0, deep_copy_1.deepCopy)(messages);\n        if (!validator.isNonEmptyArray(copy)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'messages must be a non-empty array');\n        }\n        if (copy.length > FCM_MAX_BATCH_SIZE) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `messages list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);\n        }\n        if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');\n        }\n        const http2SessionHandler = this.useLegacyTransport ? undefined : new api_request_1.Http2SessionHandler(`https://${FCM_SEND_HOST}`);\n        return this.getUrlPath()\n            .then((urlPath) => {\n            const requests = copy.map(async (message) => {\n                (0, messaging_internal_1.validateMessage)(message);\n                const request = { message };\n                if (dryRun) {\n                    request.validate_only = true;\n                }\n                if (http2SessionHandler) {\n                    return this.messagingRequestHandler.invokeHttp2RequestHandlerForSendResponse(FCM_SEND_HOST, urlPath, request, http2SessionHandler);\n                }\n                return this.messagingRequestHandler.invokeHttpRequestHandlerForSendResponse(FCM_SEND_HOST, urlPath, request);\n            });\n            return Promise.allSettled(requests);\n        })\n            .then((results) => {\n            const responses = [];\n            results.forEach(result => {\n                if (result.status === 'fulfilled') {\n                    responses.push(result.value);\n                }\n                else { // rejected\n                    responses.push({ success: false, error: result.reason });\n                }\n            });\n            const successCount = responses.filter((resp) => resp.success).length;\n            return {\n                responses,\n                successCount,\n                failureCount: responses.length - successCount,\n            };\n        })\n            .finally(() => {\n            if (http2SessionHandler) {\n                http2SessionHandler.close();\n            }\n        });\n    }\n    /**\n     * Sends the given multicast message to all the FCM registration tokens\n     * specified in it.\n     *\n     * This method uses the {@link Messaging.sendEach} API under the hood to send the given\n     * message to all the target recipients. The responses list obtained from the\n     * return value corresponds to the order of tokens in the `MulticastMessage`.\n     * An error from this method or a `BatchResponse` with all failures indicates a total\n     * failure, meaning that the messages in the list could be sent. Partial failures or\n     * failures are only indicated by a `BatchResponse` return value.\n     *\n     * @param message - A multicast message\n     *   containing up to 500 tokens.\n     * @param dryRun - Whether to send the message in the dry-run\n     *   (validation only) mode.\n     * @returns A Promise fulfilled with an object representing the result of the\n     *   send operation.\n     */\n    sendEachForMulticast(message, dryRun) {\n        const copy = (0, deep_copy_1.deepCopy)(message);\n        if (!validator.isNonNullObject(copy)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'MulticastMessage must be a non-null object');\n        }\n        if (!validator.isNonEmptyArray(copy.tokens)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'tokens must be a non-empty array');\n        }\n        if (copy.tokens.length > FCM_MAX_BATCH_SIZE) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `tokens list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);\n        }\n        const messages = copy.tokens.map((token) => {\n            return {\n                token,\n                android: copy.android,\n                apns: copy.apns,\n                data: copy.data,\n                notification: copy.notification,\n                webpush: copy.webpush,\n                fcmOptions: copy.fcmOptions,\n            };\n        });\n        return this.sendEach(messages, dryRun);\n    }\n    /**\n     * Sends all the messages in the given array via Firebase Cloud Messaging.\n     * Employs batching to send the entire list as a single RPC call. Compared\n     * to the `send()` method, this method is a significantly more efficient way\n     * to send multiple messages.\n     *\n     * The responses list obtained from the return value\n     * corresponds to the order of tokens in the `MulticastMessage`. An error\n     * from this method indicates a total failure, meaning that none of the messages\n     * in the list could be sent. Partial failures are indicated by a `BatchResponse`\n     * return value.\n     *\n     * @param messages - A non-empty array\n     *   containing up to 500 messages.\n     * @param dryRun - Whether to send the messages in the dry-run\n     *   (validation only) mode.\n     * @returns A Promise fulfilled with an object representing the result of the\n     *   send operation.\n     *\n     * @deprecated Use {@link Messaging.sendEach} instead.\n     */\n    sendAll(messages, dryRun) {\n        if (validator.isArray(messages) && messages.constructor !== Array) {\n            // In more recent JS specs, an array-like object might have a constructor that is not of\n            // Array type. Our deepCopy() method doesn't handle them properly. Convert such objects to\n            // a regular array here before calling deepCopy(). See issue #566 for details.\n            messages = Array.from(messages);\n        }\n        const copy = (0, deep_copy_1.deepCopy)(messages);\n        if (!validator.isNonEmptyArray(copy)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'messages must be a non-empty array');\n        }\n        if (copy.length > FCM_MAX_BATCH_SIZE) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `messages list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);\n        }\n        if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');\n        }\n        return this.getUrlPath()\n            .then((urlPath) => {\n            const requests = copy.map((message) => {\n                (0, messaging_internal_1.validateMessage)(message);\n                const request = { message };\n                if (dryRun) {\n                    request.validate_only = true;\n                }\n                return {\n                    url: `https://${FCM_SEND_HOST}${urlPath}`,\n                    body: request,\n                };\n            });\n            return this.messagingRequestHandler.sendBatchRequest(requests);\n        });\n    }\n    /**\n     * Sends the given multicast message to all the FCM registration tokens\n     * specified in it.\n     *\n     * This method uses the `sendAll()` API under the hood to send the given\n     * message to all the target recipients. The responses list obtained from the\n     * return value corresponds to the order of tokens in the `MulticastMessage`.\n     * An error from this method indicates a total failure, meaning that the message\n     * was not sent to any of the tokens in the list. Partial failures are indicated\n     * by a `BatchResponse` return value.\n     *\n     * @param message - A multicast message\n     *   containing up to 500 tokens.\n     * @param dryRun - Whether to send the message in the dry-run\n     *   (validation only) mode.\n     * @returns A Promise fulfilled with an object representing the result of the\n     *   send operation.\n     *\n     * @deprecated Use {@link Messaging.sendEachForMulticast} instead.\n     */\n    sendMulticast(message, dryRun) {\n        const copy = (0, deep_copy_1.deepCopy)(message);\n        if (!validator.isNonNullObject(copy)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'MulticastMessage must be a non-null object');\n        }\n        if (!validator.isNonEmptyArray(copy.tokens)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'tokens must be a non-empty array');\n        }\n        if (copy.tokens.length > FCM_MAX_BATCH_SIZE) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, `tokens list must not contain more than ${FCM_MAX_BATCH_SIZE} items`);\n        }\n        const messages = copy.tokens.map((token) => {\n            return {\n                token,\n                android: copy.android,\n                apns: copy.apns,\n                data: copy.data,\n                notification: copy.notification,\n                webpush: copy.webpush,\n                fcmOptions: copy.fcmOptions,\n            };\n        });\n        return this.sendAll(messages, dryRun);\n    }\n    /**\n     * Sends an FCM message to a single device corresponding to the provided\n     * registration token.\n     *\n     * See {@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_individual_devices |\n     * Send to individual devices}\n     * for code samples and detailed documentation. Takes either a\n     * `registrationToken` to send to a single device or a\n     * `registrationTokens` parameter containing an array of tokens to send\n     * to multiple devices.\n     *\n     * @param registrationToken - A device registration token or an array of\n     *   device registration tokens to which the message should be sent.\n     * @param payload - The message payload.\n     * @param options - Optional options to\n     *   alter the message.\n     *\n     * @returns A promise fulfilled with the server's response after the message\n     *   has been sent.\n     *\n     * @deprecated Use {@link Messaging.send} instead.\n     */\n    sendToDevice(registrationTokenOrTokens, payload, options = {}) {\n        // Validate the input argument types. Since these are common developer errors when getting\n        // started, throw an error instead of returning a rejected promise.\n        this.validateRegistrationTokensType(registrationTokenOrTokens, 'sendToDevice', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n        this.validateMessagingPayloadAndOptionsTypes(payload, options);\n        return Promise.resolve()\n            .then(() => {\n            // Validate the contents of the input arguments. Because we are now in a promise, any thrown\n            // error will cause this method to return a rejected promise.\n            this.validateRegistrationTokens(registrationTokenOrTokens, 'sendToDevice', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n            const payloadCopy = this.validateMessagingPayload(payload);\n            const optionsCopy = this.validateMessagingOptions(options);\n            const request = (0, deep_copy_1.deepCopy)(payloadCopy);\n            (0, deep_copy_1.deepExtend)(request, optionsCopy);\n            if (validator.isString(registrationTokenOrTokens)) {\n                request.to = registrationTokenOrTokens;\n            }\n            else {\n                request.registration_ids = registrationTokenOrTokens;\n            }\n            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n        })\n            .then((response) => {\n            // The sendToDevice() and sendToDeviceGroup() methods both set the `to` query parameter in\n            // the underlying FCM request. If the provided registration token argument is actually a\n            // valid notification key, the response from the FCM server will be a device group response.\n            // If that is the case, we map the response to a MessagingDeviceGroupResponse.\n            // See b/35394951 for more context.\n            if ('multicast_id' in response) {\n                return mapRawResponseToDevicesResponse(response);\n            }\n            else {\n                const groupResponse = mapRawResponseToDeviceGroupResponse(response);\n                return {\n                    ...groupResponse,\n                    canonicalRegistrationTokenCount: -1,\n                    multicastId: -1,\n                    results: [],\n                };\n            }\n        });\n    }\n    /**\n     * Sends an FCM message to a device group corresponding to the provided\n     * notification key.\n     *\n     * See {@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_a_device_group |\n     * Send to a device group} for code samples and detailed documentation.\n     *\n     * @param notificationKey - The notification key for the device group to\n     *   which to send the message.\n     * @param payload - The message payload.\n     * @param options - Optional options to\n     *   alter the message.\n     *\n     * @returns A promise fulfilled with the server's response after the message\n     *   has been sent.\n     *\n     * @deprecated Use {@link Messaging.send} instead.\n     */\n    sendToDeviceGroup(notificationKey, payload, options = {}) {\n        if (!validator.isNonEmptyString(notificationKey)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() must be a non-empty string.');\n        }\n        else if (notificationKey.indexOf(':') !== -1) {\n            // It is possible the developer provides a registration token instead of a notification key\n            // to this method. We can detect some of those cases by checking to see if the string contains\n            // a colon. Not all registration tokens will contain a colon (only newer ones will), but no\n            // notification keys will contain a colon, so we can use it as a rough heuristic.\n            // See b/35394951 for more context.\n            return Promise.reject(new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() has the format of a registration token. ' +\n                'You should use sendToDevice() instead.'));\n        }\n        // Validate the types of the payload and options arguments. Since these are common developer\n        // errors, throw an error instead of returning a rejected promise.\n        this.validateMessagingPayloadAndOptionsTypes(payload, options);\n        return Promise.resolve()\n            .then(() => {\n            // Validate the contents of the payload and options objects. Because we are now in a\n            // promise, any thrown error will cause this method to return a rejected promise.\n            const payloadCopy = this.validateMessagingPayload(payload);\n            const optionsCopy = this.validateMessagingOptions(options);\n            const request = (0, deep_copy_1.deepCopy)(payloadCopy);\n            (0, deep_copy_1.deepExtend)(request, optionsCopy);\n            request.to = notificationKey;\n            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n        })\n            .then((response) => {\n            // The sendToDevice() and sendToDeviceGroup() methods both set the `to` query parameter in\n            // the underlying FCM request. If the provided notification key argument has an invalid\n            // format (that is, it is either a registration token or some random string), the response\n            // from the FCM server will default to a devices response (which we detect by looking for\n            // the `multicast_id` property). If that is the case, we either throw an error saying the\n            // provided notification key is invalid (if the message failed to send) or map the response\n            // to a MessagingDevicesResponse (if the message succeeded).\n            // See b/35394951 for more context.\n            if ('multicast_id' in response) {\n                if (response.success === 0) {\n                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() is invalid.');\n                }\n                else {\n                    const devicesResponse = mapRawResponseToDevicesResponse(response);\n                    return {\n                        ...devicesResponse,\n                        failedRegistrationTokens: [],\n                    };\n                }\n            }\n            return mapRawResponseToDeviceGroupResponse(response);\n        });\n    }\n    /**\n     * Sends an FCM message to a topic.\n     *\n     * See {@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_a_topic |\n     * Send to a topic} for code samples and detailed documentation.\n     *\n     * @param topic - The topic to which to send the message.\n     * @param payload - The message payload.\n     * @param options - Optional options to\n     *   alter the message.\n     *\n     * @returns A promise fulfilled with the server's response after the message\n     *   has been sent.\n     *\n     * @deprecated Use {@link Messaging.send} instead.\n     */\n    sendToTopic(topic, payload, options = {}) {\n        // Validate the input argument types. Since these are common developer errors when getting\n        // started, throw an error instead of returning a rejected promise.\n        this.validateTopicType(topic, 'sendToTopic', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n        this.validateMessagingPayloadAndOptionsTypes(payload, options);\n        // Prepend the topic with /topics/ if necessary.\n        topic = this.normalizeTopic(topic);\n        return Promise.resolve()\n            .then(() => {\n            // Validate the contents of the payload and options objects. Because we are now in a\n            // promise, any thrown error will cause this method to return a rejected promise.\n            const payloadCopy = this.validateMessagingPayload(payload);\n            const optionsCopy = this.validateMessagingOptions(options);\n            this.validateTopic(topic, 'sendToTopic', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n            const request = (0, deep_copy_1.deepCopy)(payloadCopy);\n            (0, deep_copy_1.deepExtend)(request, optionsCopy);\n            request.to = topic;\n            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n        })\n            .then((response) => {\n            // Rename properties on the server response\n            utils.renameProperties(response, MESSAGING_TOPIC_RESPONSE_KEYS_MAP);\n            return response;\n        });\n    }\n    /**\n     * Sends an FCM message to a condition.\n     *\n     * See {@link https://firebase.google.com/docs/cloud-messaging/admin/legacy-fcm#send_to_a_condition |\n     * Send to a condition}\n     * for code samples and detailed documentation.\n     *\n     * @param condition - The condition determining to which topics to send\n     *   the message.\n     * @param payload - The message payload.\n     * @param options - Optional options to\n     *   alter the message.\n     *\n     * @returns A promise fulfilled with the server's response after the message\n     *   has been sent.\n     *\n     * @deprecated Use {@link Messaging.send} instead.\n     */\n    sendToCondition(condition, payload, options = {}) {\n        if (!validator.isNonEmptyString(condition)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Condition provided to sendToCondition() must be a non-empty string.');\n        }\n        // Validate the types of the payload and options arguments. Since these are common developer\n        // errors, throw an error instead of returning a rejected promise.\n        this.validateMessagingPayloadAndOptionsTypes(payload, options);\n        // The FCM server rejects conditions which are surrounded in single quotes. When the condition\n        // is stringified over the wire, double quotes in it get converted to \\\" which the FCM server\n        // does not properly handle. We can get around this by replacing internal double quotes with\n        // single quotes.\n        condition = condition.replace(/\"/g, '\\'');\n        return Promise.resolve()\n            .then(() => {\n            // Validate the contents of the payload and options objects. Because we are now in a\n            // promise, any thrown error will cause this method to return a rejected promise.\n            const payloadCopy = this.validateMessagingPayload(payload);\n            const optionsCopy = this.validateMessagingOptions(options);\n            const request = (0, deep_copy_1.deepCopy)(payloadCopy);\n            (0, deep_copy_1.deepExtend)(request, optionsCopy);\n            request.condition = condition;\n            return this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n        })\n            .then((response) => {\n            // Rename properties on the server response\n            utils.renameProperties(response, MESSAGING_CONDITION_RESPONSE_KEYS_MAP);\n            return response;\n        });\n    }\n    /**\n     * Subscribes a device to an FCM topic.\n     *\n     * See {@link https://firebase.google.com/docs/cloud-messaging/manage-topics#suscribe_and_unsubscribe_using_the |\n     * Subscribe to a topic}\n     * for code samples and detailed documentation. Optionally, you can provide an\n     * array of tokens to subscribe multiple devices.\n     *\n     * @param registrationTokens - A token or array of registration tokens\n     *   for the devices to subscribe to the topic.\n     * @param topic - The topic to which to subscribe.\n     *\n     * @returns A promise fulfilled with the server's response after the device has been\n     *   subscribed to the topic.\n     */\n    subscribeToTopic(registrationTokenOrTokens, topic) {\n        return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'subscribeToTopic', FCM_TOPIC_MANAGEMENT_ADD_PATH);\n    }\n    /**\n     * Unsubscribes a device from an FCM topic.\n     *\n     * See {@link https://firebase.google.com/docs/cloud-messaging/admin/manage-topic-subscriptions#unsubscribe_from_a_topic |\n     * Unsubscribe from a topic}\n     * for code samples and detailed documentation.  Optionally, you can provide an\n     * array of tokens to unsubscribe multiple devices.\n     *\n     * @param registrationTokens - A device registration token or an array of\n     *   device registration tokens to unsubscribe from the topic.\n     * @param topic - The topic from which to unsubscribe.\n     *\n     * @returns A promise fulfilled with the server's response after the device has been\n     *   unsubscribed from the topic.\n     */\n    unsubscribeFromTopic(registrationTokenOrTokens, topic) {\n        return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'unsubscribeFromTopic', FCM_TOPIC_MANAGEMENT_REMOVE_PATH);\n    }\n    getUrlPath() {\n        if (this.urlPath) {\n            return Promise.resolve(this.urlPath);\n        }\n        return utils.findProjectId(this.app)\n            .then((projectId) => {\n            if (!validator.isNonEmptyString(projectId)) {\n                // Assert for an explicit project ID (either via AppOptions or the cert itself).\n                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'Failed to determine project ID for Messaging. Initialize the '\n                    + 'SDK with service account credentials or set project ID as an app option. '\n                    + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');\n            }\n            this.urlPath = `/v1/projects/${projectId}/messages:send`;\n            return this.urlPath;\n        });\n    }\n    /**\n     * Helper method which sends and handles topic subscription management requests.\n     *\n     * @param registrationTokenOrTokens - The registration token or an array of\n     *     registration tokens to unsubscribe from the topic.\n     * @param topic - The topic to which to subscribe.\n     * @param methodName - The name of the original method called.\n     * @param path - The endpoint path to use for the request.\n     *\n     * @returns A Promise fulfilled with the parsed server\n     *   response.\n     */\n    sendTopicManagementRequest(registrationTokenOrTokens, topic, methodName, path) {\n        this.validateRegistrationTokensType(registrationTokenOrTokens, methodName);\n        this.validateTopicType(topic, methodName);\n        // Prepend the topic with /topics/ if necessary.\n        topic = this.normalizeTopic(topic);\n        return Promise.resolve()\n            .then(() => {\n            // Validate the contents of the input arguments. Because we are now in a promise, any thrown\n            // error will cause this method to return a rejected promise.\n            this.validateRegistrationTokens(registrationTokenOrTokens, methodName);\n            this.validateTopic(topic, methodName);\n            // Ensure the registration token(s) input argument is an array.\n            let registrationTokensArray = registrationTokenOrTokens;\n            if (validator.isString(registrationTokenOrTokens)) {\n                registrationTokensArray = [registrationTokenOrTokens];\n            }\n            const request = {\n                to: topic,\n                registration_tokens: registrationTokensArray,\n            };\n            return this.messagingRequestHandler.invokeRequestHandler(FCM_TOPIC_MANAGEMENT_HOST, path, request);\n        })\n            .then((response) => {\n            return mapRawResponseToTopicManagementResponse(response);\n        });\n    }\n    /**\n     * Validates the types of the messaging payload and options. If invalid, an error will be thrown.\n     *\n     * @param payload - The messaging payload to validate.\n     * @param options - The messaging options to validate.\n     */\n    validateMessagingPayloadAndOptionsTypes(payload, options) {\n        // Validate the payload is an object\n        if (!validator.isNonNullObject(payload)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Messaging payload must be an object with at least one of the \"data\" or \"notification\" properties.');\n        }\n        // Validate the options argument is an object\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, 'Messaging options must be an object.');\n        }\n    }\n    /**\n     * Validates the messaging payload. If invalid, an error will be thrown.\n     *\n     * @param payload - The messaging payload to validate.\n     *\n     * @returns A copy of the provided payload with whitelisted properties switched\n     *     from camelCase to underscore_case.\n     */\n    validateMessagingPayload(payload) {\n        const payloadCopy = (0, deep_copy_1.deepCopy)(payload);\n        const payloadKeys = Object.keys(payloadCopy);\n        const validPayloadKeys = ['data', 'notification'];\n        let containsDataOrNotificationKey = false;\n        payloadKeys.forEach((payloadKey) => {\n            // Validate the payload does not contain any invalid keys\n            if (validPayloadKeys.indexOf(payloadKey) === -1) {\n                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains an invalid \"${payloadKey}\" property. Valid properties are ` +\n                    '\"data\" and \"notification\".');\n            }\n            else {\n                containsDataOrNotificationKey = true;\n            }\n        });\n        // Validate the payload contains at least one of the \"data\" and \"notification\" keys\n        if (!containsDataOrNotificationKey) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Messaging payload must contain at least one of the \"data\" or \"notification\" properties.');\n        }\n        const validatePayload = (payloadKey, value) => {\n            // Validate each top-level key in the payload is an object\n            if (!validator.isNonNullObject(value)) {\n                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains an invalid value for the \"${payloadKey}\" property. ` +\n                    'Value must be an object.');\n            }\n            Object.keys(value).forEach((subKey) => {\n                if (!validator.isString(value[subKey])) {\n                    // Validate all sub-keys have a string value\n                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains an invalid value for the \"${payloadKey}.${subKey}\" ` +\n                        'property. Values must be strings.');\n                }\n                else if (payloadKey === 'data' && /^google\\./.test(subKey)) {\n                    // Validate the data payload does not contain keys which start with 'google.'.\n                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains the blacklisted \"data.${subKey}\" property.`);\n                }\n            });\n        };\n        if (payloadCopy.data !== undefined) {\n            validatePayload('data', payloadCopy.data);\n        }\n        if (payloadCopy.notification !== undefined) {\n            validatePayload('notification', payloadCopy.notification);\n        }\n        // Validate the data payload object does not contain blacklisted properties\n        if ('data' in payloadCopy) {\n            messaging_internal_1.BLACKLISTED_DATA_PAYLOAD_KEYS.forEach((blacklistedKey) => {\n                if (blacklistedKey in payloadCopy.data) {\n                    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, `Messaging payload contains the blacklisted \"data.${blacklistedKey}\" property.`);\n                }\n            });\n        }\n        // Convert whitelisted camelCase keys to underscore_case\n        if (payloadCopy.notification) {\n            utils.renameProperties(payloadCopy.notification, CAMELCASED_NOTIFICATION_PAYLOAD_KEYS_MAP);\n        }\n        return payloadCopy;\n    }\n    /**\n     * Validates the messaging options. If invalid, an error will be thrown.\n     *\n     * @param options - The messaging options to validate.\n     *\n     * @returns A copy of the provided options with whitelisted properties switched\n     *   from camelCase to underscore_case.\n     */\n    validateMessagingOptions(options) {\n        const optionsCopy = (0, deep_copy_1.deepCopy)(options);\n        // Validate the options object does not contain blacklisted properties\n        messaging_internal_1.BLACKLISTED_OPTIONS_KEYS.forEach((blacklistedKey) => {\n            if (blacklistedKey in optionsCopy) {\n                throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains the blacklisted \"${blacklistedKey}\" property.`);\n            }\n        });\n        // Convert whitelisted camelCase keys to underscore_case\n        utils.renameProperties(optionsCopy, CAMELCASE_OPTIONS_KEYS_MAP);\n        // Validate the options object contains valid values for whitelisted properties\n        if ('collapse_key' in optionsCopy && !validator.isNonEmptyString(optionsCopy.collapse_key)) {\n            const keyName = ('collapseKey' in options) ? 'collapseKey' : 'collapse_key';\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the \"${keyName}\" property. Value must ` +\n                'be a non-empty string.');\n        }\n        else if ('dry_run' in optionsCopy && !validator.isBoolean(optionsCopy.dry_run)) {\n            const keyName = ('dryRun' in options) ? 'dryRun' : 'dry_run';\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the \"${keyName}\" property. Value must ` +\n                'be a boolean.');\n        }\n        else if ('priority' in optionsCopy && !validator.isNonEmptyString(optionsCopy.priority)) {\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, 'Messaging options contains an invalid value for the \"priority\" property. Value must ' +\n                'be a non-empty string.');\n        }\n        else if ('restricted_package_name' in optionsCopy &&\n            !validator.isNonEmptyString(optionsCopy.restricted_package_name)) {\n            const keyName = ('restrictedPackageName' in options) ? 'restrictedPackageName' : 'restricted_package_name';\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the \"${keyName}\" property. Value must ` +\n                'be a non-empty string.');\n        }\n        else if ('time_to_live' in optionsCopy && !validator.isNumber(optionsCopy.time_to_live)) {\n            const keyName = ('timeToLive' in options) ? 'timeToLive' : 'time_to_live';\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the \"${keyName}\" property. Value must ` +\n                'be a number.');\n        }\n        else if ('content_available' in optionsCopy && !validator.isBoolean(optionsCopy.content_available)) {\n            const keyName = ('contentAvailable' in options) ? 'contentAvailable' : 'content_available';\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the \"${keyName}\" property. Value must ` +\n                'be a boolean.');\n        }\n        else if ('mutable_content' in optionsCopy && !validator.isBoolean(optionsCopy.mutable_content)) {\n            const keyName = ('mutableContent' in options) ? 'mutableContent' : 'mutable_content';\n            throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, `Messaging options contains an invalid value for the \"${keyName}\" property. Value must ` +\n                'be a boolean.');\n        }\n        return optionsCopy;\n    }\n    /**\n     * Validates the type of the provided registration token(s). If invalid, an error will be thrown.\n     *\n     * @param registrationTokenOrTokens - The registration token(s) to validate.\n     * @param method - The method name to use in error messages.\n     * @param errorInfo - The error info to use if the registration tokens are invalid.\n     */\n    validateRegistrationTokensType(registrationTokenOrTokens, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {\n        if (!validator.isNonEmptyArray(registrationTokenOrTokens) &&\n            !validator.isNonEmptyString(registrationTokenOrTokens)) {\n            throw new error_1.FirebaseMessagingError(errorInfo, `Registration token(s) provided to ${methodName}() must be a non-empty string or a ` +\n                'non-empty array.');\n        }\n    }\n    /**\n     * Validates the provided registration tokens. If invalid, an error will be thrown.\n     *\n     * @param registrationTokenOrTokens - The registration token or an array of\n     *     registration tokens to validate.\n     * @param method - The method name to use in error messages.\n     * @param errorInfo - The error info to use if the registration tokens are invalid.\n     */\n    validateRegistrationTokens(registrationTokenOrTokens, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {\n        if (validator.isArray(registrationTokenOrTokens)) {\n            // Validate the array contains no more than 1,000 registration tokens.\n            if (registrationTokenOrTokens.length > 1000) {\n                throw new error_1.FirebaseMessagingError(errorInfo, `Too many registration tokens provided in a single request to ${methodName}(). Batch ` +\n                    'your requests to contain no more than 1,000 registration tokens per request.');\n            }\n            // Validate the array contains registration tokens which are non-empty strings.\n            registrationTokenOrTokens.forEach((registrationToken, index) => {\n                if (!validator.isNonEmptyString(registrationToken)) {\n                    throw new error_1.FirebaseMessagingError(errorInfo, `Registration token provided to ${methodName}() at index ${index} must be a ` +\n                        'non-empty string.');\n                }\n            });\n        }\n    }\n    /**\n     * Validates the type of the provided topic. If invalid, an error will be thrown.\n     *\n     * @param topic - The topic to validate.\n     * @param method - The method name to use in error messages.\n     * @param errorInfo - The error info to use if the topic is invalid.\n     */\n    validateTopicType(topic, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {\n        if (!validator.isNonEmptyString(topic)) {\n            throw new error_1.FirebaseMessagingError(errorInfo, `Topic provided to ${methodName}() must be a string which matches the format ` +\n                '\"/topics/[a-zA-Z0-9-_.~%]+\".');\n        }\n    }\n    /**\n     * Validates the provided topic. If invalid, an error will be thrown.\n     *\n     * @param topic - The topic to validate.\n     * @param method - The method name to use in error messages.\n     * @param errorInfo - The error info to use if the topic is invalid.\n     */\n    validateTopic(topic, methodName, errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT) {\n        if (!validator.isTopic(topic)) {\n            throw new error_1.FirebaseMessagingError(errorInfo, `Topic provided to ${methodName}() must be a string which matches the format ` +\n                '\"/topics/[a-zA-Z0-9-_.~%]+\".');\n        }\n    }\n    /**\n     * Normalizes the provided topic name by prepending it with '/topics/', if necessary.\n     *\n     * @param topic - The topic name to normalize.\n     *\n     * @returns The normalized topic name.\n     */\n    normalizeTopic(topic) {\n        if (!/^\\/topics\\//.test(topic)) {\n            topic = `/topics/${topic}`;\n        }\n        return topic;\n    }\n}\nexports.Messaging = Messaging;\n"],"mappings":"AAAA;AACA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,SAAS,GAAG,KAAK,CAAC;AAC1B,MAAMC,WAAW,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AACjD,MAAMC,OAAO,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AACzC,MAAME,KAAK,GAAGF,OAAO,CAAC,UAAU,CAAC;AACjC,MAAMG,SAAS,GAAGH,OAAO,CAAC,oBAAoB,CAAC;AAC/C,MAAMI,oBAAoB,GAAGJ,OAAO,CAAC,sBAAsB,CAAC;AAC5D,MAAMK,gCAAgC,GAAGL,OAAO,CAAC,kCAAkC,CAAC;AACpF,MAAMM,aAAa,GAAGN,OAAO,CAAC,sBAAsB,CAAC;AACrD;AACA,MAAMO,aAAa,GAAG,oBAAoB;AAC1C,MAAMC,aAAa,GAAG,WAAW;AACjC,MAAMC,yBAAyB,GAAG,oBAAoB;AACtD,MAAMC,6BAA6B,GAAG,kBAAkB;AACxD,MAAMC,gCAAgC,GAAG,qBAAqB;AAC9D;AACA,MAAMC,kBAAkB,GAAG,GAAG;AAC9B;AACA,MAAMC,wCAAwC,GAAG;EAC7CC,WAAW,EAAE,eAAe;EAC5BC,UAAU,EAAE,cAAc;EAC1BC,WAAW,EAAE,cAAc;EAC3BC,YAAY,EAAE,gBAAgB;EAC9BC,WAAW,EAAE;AACjB,CAAC;AACD;AACA,MAAMC,0BAA0B,GAAG;EAC/BC,MAAM,EAAE,SAAS;EACjBC,UAAU,EAAE,cAAc;EAC1BC,WAAW,EAAE,cAAc;EAC3BC,cAAc,EAAE,iBAAiB;EACjCC,gBAAgB,EAAE,mBAAmB;EACrCC,qBAAqB,EAAE;AAC3B,CAAC;AACD;AACA,MAAMC,gCAAgC,GAAG;EACrCC,UAAU,EAAE,WAAW;EACvBC,eAAe,EAAE;AACrB,CAAC;AACD;AACA,MAAMC,mCAAmC,GAAG;EACxCC,aAAa,EAAE,iCAAiC;EAChDC,OAAO,EAAE,cAAc;EACvBC,OAAO,EAAE,cAAc;EACvBC,YAAY,EAAE;AAClB,CAAC;AACD;AACA,MAAMC,wCAAwC,GAAG;EAC7CF,OAAO,EAAE,cAAc;EACvBD,OAAO,EAAE,cAAc;EACvBI,uBAAuB,EAAE;AAC7B,CAAC;AACD;AACA,MAAMC,iCAAiC,GAAG;EACtCT,UAAU,EAAE;AAChB,CAAC;AACD;AACA,MAAMU,qCAAqC,GAAG;EAC1CV,UAAU,EAAE;AAChB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASW,+BAA+B,CAACC,QAAQ,EAAE;EAC/C;EACArC,KAAK,CAACsC,gBAAgB,CAACD,QAAQ,EAAEV,mCAAmC,CAAC;EACrE,IAAI,SAAS,IAAIU,QAAQ,EAAE;IACvBA,QAAQ,CAACE,OAAO,CAACC,OAAO,CAAEC,qBAAqB,IAAK;MAChDzC,KAAK,CAACsC,gBAAgB,CAACG,qBAAqB,EAAEjB,gCAAgC,CAAC;MAC/E;MACA,IAAI,OAAO,IAAIiB,qBAAqB,EAAE;QAClC,MAAMC,QAAQ,GAAG3C,OAAO,CAAC4C,sBAAsB,CAACC,eAAe,CAACH,qBAAqB,CAACI,KAAK,EAAE,aAAcC,SAAS,EAAEL,qBAAqB,CAACI,KAAK,CAAC;QAClJJ,qBAAqB,CAACI,KAAK,GAAGH,QAAQ;MAC1C;IACJ,CAAC,CAAC;EACN;EACA,OAAOL,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASU,mCAAmC,CAACV,QAAQ,EAAE;EACnD;EACArC,KAAK,CAACsC,gBAAgB,CAACD,QAAQ,EAAEL,wCAAwC,CAAC;EAC1E;EACA;EACAK,QAAQ,CAACW,wBAAwB,GAAGX,QAAQ,CAACW,wBAAwB,IAAI,EAAE;EAC3E,OAAOX,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASY,uCAAuC,CAACZ,QAAQ,EAAE;EACvD;EACA,MAAMa,MAAM,GAAG;IACXC,YAAY,EAAE,CAAC;IACfC,YAAY,EAAE,CAAC;IACfC,MAAM,EAAE;EACZ,CAAC;EACD,IAAI,SAAS,IAAIhB,QAAQ,EAAE;IACvBA,QAAQ,CAACE,OAAO,CAACC,OAAO,CAAC,CAACc,qBAAqB,EAAEC,KAAK,KAAK;MACvD;MACA,IAAI,OAAO,IAAID,qBAAqB,EAAE;QAClCJ,MAAM,CAACE,YAAY,IAAI,CAAC;QACxB,MAAMV,QAAQ,GAAG3C,OAAO,CAAC4C,sBAAsB,CAACa,8BAA8B,CAACF,qBAAqB,CAACT,KAAK,EAAE,aAAcC,SAAS,EAAEQ,qBAAqB,CAACT,KAAK,CAAC;QACjKK,MAAM,CAACG,MAAM,CAACI,IAAI,CAAC;UACfF,KAAK;UACLV,KAAK,EAAEH;QACX,CAAC,CAAC;MACN,CAAC,MACI;QACDQ,MAAM,CAACC,YAAY,IAAI,CAAC;MAC5B;IACJ,CAAC,CAAC;EACN;EACA,OAAOD,MAAM;AACjB;AACA;AACA;AACA;AACA,MAAMtD,SAAS,CAAC;EACZ;AACJ;AACA;EACI8D,WAAW,CAACC,GAAG,EAAE;IACb,IAAI,CAACC,kBAAkB,GAAG,KAAK;IAC/B,IAAI,CAAC3D,SAAS,CAAC4D,eAAe,CAACF,GAAG,CAAC,IAAI,EAAE,SAAS,IAAIA,GAAG,CAAC,EAAE;MACxD,MAAM,IAAI5D,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAE,mFAAmF,CAAC;IACpL;IACA,IAAI,CAACC,WAAW,GAAGL,GAAG;IACtB,IAAI,CAACM,uBAAuB,GAAG,IAAI9D,gCAAgC,CAAC+D,+BAA+B,CAACP,GAAG,CAAC;EAC5G;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIA,GAAG,GAAG;IACN,OAAO,IAAI,CAACK,WAAW;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,yBAAyB,GAAG;IACxB,IAAI,CAACP,kBAAkB,GAAG,IAAI;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIQ,IAAI,CAACC,OAAO,EAAEnD,MAAM,EAAE;IAClB,MAAMoD,IAAI,GAAG,CAAC,CAAC,EAAEzE,WAAW,CAAC0E,QAAQ,EAAEF,OAAO,CAAC;IAC/C,CAAC,CAAC,EAAEnE,oBAAoB,CAACsE,eAAe,EAAEF,IAAI,CAAC;IAC/C,IAAI,OAAOpD,MAAM,KAAK,WAAW,IAAI,CAACjB,SAAS,CAACwE,SAAS,CAACvD,MAAM,CAAC,EAAE;MAC/D,MAAM,IAAInB,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAE,0BAA0B,CAAC;IAC3H;IACA,OAAO,IAAI,CAACW,UAAU,EAAE,CACnBC,IAAI,CAAEC,OAAO,IAAK;MACnB,MAAMC,OAAO,GAAG;QAAER,OAAO,EAAEC;MAAK,CAAC;MACjC,IAAIpD,MAAM,EAAE;QACR2D,OAAO,CAACC,aAAa,GAAG,IAAI;MAChC;MACA,OAAO,IAAI,CAACb,uBAAuB,CAACc,oBAAoB,CAAC1E,aAAa,EAAEuE,OAAO,EAAEC,OAAO,CAAC;IAC7F,CAAC,CAAC,CACGF,IAAI,CAAEtC,QAAQ,IAAK;MACpB,OAAOA,QAAQ,CAAC2C,IAAI;IACxB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,QAAQ,CAACC,QAAQ,EAAEhE,MAAM,EAAE;IACvB,IAAIjB,SAAS,CAACkF,OAAO,CAACD,QAAQ,CAAC,IAAIA,QAAQ,CAACxB,WAAW,KAAK0B,KAAK,EAAE;MAC/D;MACA;MACA;MACAF,QAAQ,GAAGE,KAAK,CAACC,IAAI,CAACH,QAAQ,CAAC;IACnC;IACA,MAAMZ,IAAI,GAAG,CAAC,CAAC,EAAEzE,WAAW,CAAC0E,QAAQ,EAAEW,QAAQ,CAAC;IAChD,IAAI,CAACjF,SAAS,CAACqF,eAAe,CAAChB,IAAI,CAAC,EAAE;MAClC,MAAM,IAAIvE,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAE,oCAAoC,CAAC;IACrI;IACA,IAAIO,IAAI,CAACiB,MAAM,GAAG7E,kBAAkB,EAAE;MAClC,MAAM,IAAIX,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAG,4CAA2CrD,kBAAmB,QAAO,CAAC;IACvK;IACA,IAAI,OAAOQ,MAAM,KAAK,WAAW,IAAI,CAACjB,SAAS,CAACwE,SAAS,CAACvD,MAAM,CAAC,EAAE;MAC/D,MAAM,IAAInB,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAE,0BAA0B,CAAC;IAC3H;IACA,MAAMyB,mBAAmB,GAAG,IAAI,CAAC5B,kBAAkB,GAAGd,SAAS,GAAG,IAAI1C,aAAa,CAACqF,mBAAmB,CAAE,WAAUpF,aAAc,EAAC,CAAC;IACnI,OAAO,IAAI,CAACqE,UAAU,EAAE,CACnBC,IAAI,CAAEC,OAAO,IAAK;MACnB,MAAMc,QAAQ,GAAGpB,IAAI,CAACqB,GAAG,CAAC,MAAOtB,OAAO,IAAK;QACzC,CAAC,CAAC,EAAEnE,oBAAoB,CAACsE,eAAe,EAAEH,OAAO,CAAC;QAClD,MAAMQ,OAAO,GAAG;UAAER;QAAQ,CAAC;QAC3B,IAAInD,MAAM,EAAE;UACR2D,OAAO,CAACC,aAAa,GAAG,IAAI;QAChC;QACA,IAAIU,mBAAmB,EAAE;UACrB,OAAO,IAAI,CAACvB,uBAAuB,CAAC2B,wCAAwC,CAACvF,aAAa,EAAEuE,OAAO,EAAEC,OAAO,EAAEW,mBAAmB,CAAC;QACtI;QACA,OAAO,IAAI,CAACvB,uBAAuB,CAAC4B,uCAAuC,CAACxF,aAAa,EAAEuE,OAAO,EAAEC,OAAO,CAAC;MAChH,CAAC,CAAC;MACF,OAAOiB,OAAO,CAACC,UAAU,CAACL,QAAQ,CAAC;IACvC,CAAC,CAAC,CACGf,IAAI,CAAEpC,OAAO,IAAK;MACnB,MAAMyD,SAAS,GAAG,EAAE;MACpBzD,OAAO,CAACC,OAAO,CAACU,MAAM,IAAI;QACtB,IAAIA,MAAM,CAAC+C,MAAM,KAAK,WAAW,EAAE;UAC/BD,SAAS,CAACvC,IAAI,CAACP,MAAM,CAACvD,KAAK,CAAC;QAChC,CAAC,MACI;UAAE;UACHqG,SAAS,CAACvC,IAAI,CAAC;YAAE3B,OAAO,EAAE,KAAK;YAAEe,KAAK,EAAEK,MAAM,CAACgD;UAAO,CAAC,CAAC;QAC5D;MACJ,CAAC,CAAC;MACF,MAAM/C,YAAY,GAAG6C,SAAS,CAACG,MAAM,CAAEC,IAAI,IAAKA,IAAI,CAACtE,OAAO,CAAC,CAACyD,MAAM;MACpE,OAAO;QACHS,SAAS;QACT7C,YAAY;QACZC,YAAY,EAAE4C,SAAS,CAACT,MAAM,GAAGpC;MACrC,CAAC;IACL,CAAC,CAAC,CACGkD,OAAO,CAAC,MAAM;MACf,IAAIb,mBAAmB,EAAE;QACrBA,mBAAmB,CAACc,KAAK,EAAE;MAC/B;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,oBAAoB,CAAClC,OAAO,EAAEnD,MAAM,EAAE;IAClC,MAAMoD,IAAI,GAAG,CAAC,CAAC,EAAEzE,WAAW,CAAC0E,QAAQ,EAAEF,OAAO,CAAC;IAC/C,IAAI,CAACpE,SAAS,CAAC4D,eAAe,CAACS,IAAI,CAAC,EAAE;MAClC,MAAM,IAAIvE,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAE,4CAA4C,CAAC;IAC7I;IACA,IAAI,CAAC9D,SAAS,CAACqF,eAAe,CAAChB,IAAI,CAACkC,MAAM,CAAC,EAAE;MACzC,MAAM,IAAIzG,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAE,kCAAkC,CAAC;IACnI;IACA,IAAIO,IAAI,CAACkC,MAAM,CAACjB,MAAM,GAAG7E,kBAAkB,EAAE;MACzC,MAAM,IAAIX,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAG,0CAAyCrD,kBAAmB,QAAO,CAAC;IACrK;IACA,MAAMwE,QAAQ,GAAGZ,IAAI,CAACkC,MAAM,CAACb,GAAG,CAAEc,KAAK,IAAK;MACxC,OAAO;QACHA,KAAK;QACLC,OAAO,EAAEpC,IAAI,CAACoC,OAAO;QACrBC,IAAI,EAAErC,IAAI,CAACqC,IAAI;QACfC,IAAI,EAAEtC,IAAI,CAACsC,IAAI;QACfC,YAAY,EAAEvC,IAAI,CAACuC,YAAY;QAC/BC,OAAO,EAAExC,IAAI,CAACwC,OAAO;QACrBC,UAAU,EAAEzC,IAAI,CAACyC;MACrB,CAAC;IACL,CAAC,CAAC;IACF,OAAO,IAAI,CAAC9B,QAAQ,CAACC,QAAQ,EAAEhE,MAAM,CAAC;EAC1C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI8F,OAAO,CAAC9B,QAAQ,EAAEhE,MAAM,EAAE;IACtB,IAAIjB,SAAS,CAACkF,OAAO,CAACD,QAAQ,CAAC,IAAIA,QAAQ,CAACxB,WAAW,KAAK0B,KAAK,EAAE;MAC/D;MACA;MACA;MACAF,QAAQ,GAAGE,KAAK,CAACC,IAAI,CAACH,QAAQ,CAAC;IACnC;IACA,MAAMZ,IAAI,GAAG,CAAC,CAAC,EAAEzE,WAAW,CAAC0E,QAAQ,EAAEW,QAAQ,CAAC;IAChD,IAAI,CAACjF,SAAS,CAACqF,eAAe,CAAChB,IAAI,CAAC,EAAE;MAClC,MAAM,IAAIvE,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAE,oCAAoC,CAAC;IACrI;IACA,IAAIO,IAAI,CAACiB,MAAM,GAAG7E,kBAAkB,EAAE;MAClC,MAAM,IAAIX,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAG,4CAA2CrD,kBAAmB,QAAO,CAAC;IACvK;IACA,IAAI,OAAOQ,MAAM,KAAK,WAAW,IAAI,CAACjB,SAAS,CAACwE,SAAS,CAACvD,MAAM,CAAC,EAAE;MAC/D,MAAM,IAAInB,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAE,0BAA0B,CAAC;IAC3H;IACA,OAAO,IAAI,CAACW,UAAU,EAAE,CACnBC,IAAI,CAAEC,OAAO,IAAK;MACnB,MAAMc,QAAQ,GAAGpB,IAAI,CAACqB,GAAG,CAAEtB,OAAO,IAAK;QACnC,CAAC,CAAC,EAAEnE,oBAAoB,CAACsE,eAAe,EAAEH,OAAO,CAAC;QAClD,MAAMQ,OAAO,GAAG;UAAER;QAAQ,CAAC;QAC3B,IAAInD,MAAM,EAAE;UACR2D,OAAO,CAACC,aAAa,GAAG,IAAI;QAChC;QACA,OAAO;UACHmC,GAAG,EAAG,WAAU5G,aAAc,GAAEuE,OAAQ,EAAC;UACzCsC,IAAI,EAAErC;QACV,CAAC;MACL,CAAC,CAAC;MACF,OAAO,IAAI,CAACZ,uBAAuB,CAACkD,gBAAgB,CAACzB,QAAQ,CAAC;IAClE,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI0B,aAAa,CAAC/C,OAAO,EAAEnD,MAAM,EAAE;IAC3B,MAAMoD,IAAI,GAAG,CAAC,CAAC,EAAEzE,WAAW,CAAC0E,QAAQ,EAAEF,OAAO,CAAC;IAC/C,IAAI,CAACpE,SAAS,CAAC4D,eAAe,CAACS,IAAI,CAAC,EAAE;MAClC,MAAM,IAAIvE,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAE,4CAA4C,CAAC;IAC7I;IACA,IAAI,CAAC9D,SAAS,CAACqF,eAAe,CAAChB,IAAI,CAACkC,MAAM,CAAC,EAAE;MACzC,MAAM,IAAIzG,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAE,kCAAkC,CAAC;IACnI;IACA,IAAIO,IAAI,CAACkC,MAAM,CAACjB,MAAM,GAAG7E,kBAAkB,EAAE;MACzC,MAAM,IAAIX,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAG,0CAAyCrD,kBAAmB,QAAO,CAAC;IACrK;IACA,MAAMwE,QAAQ,GAAGZ,IAAI,CAACkC,MAAM,CAACb,GAAG,CAAEc,KAAK,IAAK;MACxC,OAAO;QACHA,KAAK;QACLC,OAAO,EAAEpC,IAAI,CAACoC,OAAO;QACrBC,IAAI,EAAErC,IAAI,CAACqC,IAAI;QACfC,IAAI,EAAEtC,IAAI,CAACsC,IAAI;QACfC,YAAY,EAAEvC,IAAI,CAACuC,YAAY;QAC/BC,OAAO,EAAExC,IAAI,CAACwC,OAAO;QACrBC,UAAU,EAAEzC,IAAI,CAACyC;MACrB,CAAC;IACL,CAAC,CAAC;IACF,OAAO,IAAI,CAACC,OAAO,CAAC9B,QAAQ,EAAEhE,MAAM,CAAC;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACImG,YAAY,CAACC,yBAAyB,EAAEC,OAAO,EAAgB;IAAA,IAAdC,OAAO,uEAAG,CAAC,CAAC;IACzD;IACA;IACA,IAAI,CAACC,8BAA8B,CAACH,yBAAyB,EAAE,cAAc,EAAEvH,OAAO,CAAC+D,wBAAwB,CAAC4D,iBAAiB,CAAC;IAClI,IAAI,CAACC,uCAAuC,CAACJ,OAAO,EAAEC,OAAO,CAAC;IAC9D,OAAO1B,OAAO,CAAC8B,OAAO,EAAE,CACnBjD,IAAI,CAAC,MAAM;MACZ;MACA;MACA,IAAI,CAACkD,0BAA0B,CAACP,yBAAyB,EAAE,cAAc,EAAEvH,OAAO,CAAC+D,wBAAwB,CAAC4D,iBAAiB,CAAC;MAC9H,MAAMI,WAAW,GAAG,IAAI,CAACC,wBAAwB,CAACR,OAAO,CAAC;MAC1D,MAAMS,WAAW,GAAG,IAAI,CAACC,wBAAwB,CAACT,OAAO,CAAC;MAC1D,MAAM3C,OAAO,GAAG,CAAC,CAAC,EAAEhF,WAAW,CAAC0E,QAAQ,EAAEuD,WAAW,CAAC;MACtD,CAAC,CAAC,EAAEjI,WAAW,CAACqI,UAAU,EAAErD,OAAO,EAAEmD,WAAW,CAAC;MACjD,IAAI/H,SAAS,CAACkI,QAAQ,CAACb,yBAAyB,CAAC,EAAE;QAC/CzC,OAAO,CAACuD,EAAE,GAAGd,yBAAyB;MAC1C,CAAC,MACI;QACDzC,OAAO,CAACwD,gBAAgB,GAAGf,yBAAyB;MACxD;MACA,OAAO,IAAI,CAACrD,uBAAuB,CAACc,oBAAoB,CAAC1E,aAAa,EAAEC,aAAa,EAAEuE,OAAO,CAAC;IACnG,CAAC,CAAC,CACGF,IAAI,CAAEtC,QAAQ,IAAK;MACpB;MACA;MACA;MACA;MACA;MACA,IAAI,cAAc,IAAIA,QAAQ,EAAE;QAC5B,OAAOD,+BAA+B,CAACC,QAAQ,CAAC;MACpD,CAAC,MACI;QACD,MAAMiG,aAAa,GAAGvF,mCAAmC,CAACV,QAAQ,CAAC;QACnE,OAAO;UACH,GAAGiG,aAAa;UAChBC,+BAA+B,EAAE,CAAC,CAAC;UACnCC,WAAW,EAAE,CAAC,CAAC;UACfjG,OAAO,EAAE;QACb,CAAC;MACL;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIkG,iBAAiB,CAACC,eAAe,EAAEnB,OAAO,EAAgB;IAAA,IAAdC,OAAO,uEAAG,CAAC,CAAC;IACpD,IAAI,CAACvH,SAAS,CAAC0I,gBAAgB,CAACD,eAAe,CAAC,EAAE;MAC9C,MAAM,IAAI3I,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAAC4D,iBAAiB,EAAE,8EAA8E,CAAC;IAChL,CAAC,MACI,IAAIgB,eAAe,CAACE,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;MAC1C;MACA;MACA;MACA;MACA;MACA,OAAO9C,OAAO,CAAC+C,MAAM,CAAC,IAAI9I,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAAC4D,iBAAiB,EAAE,2FAA2F,GACpM,wCAAwC,CAAC,CAAC;IAClD;IACA;IACA;IACA,IAAI,CAACC,uCAAuC,CAACJ,OAAO,EAAEC,OAAO,CAAC;IAC9D,OAAO1B,OAAO,CAAC8B,OAAO,EAAE,CACnBjD,IAAI,CAAC,MAAM;MACZ;MACA;MACA,MAAMmD,WAAW,GAAG,IAAI,CAACC,wBAAwB,CAACR,OAAO,CAAC;MAC1D,MAAMS,WAAW,GAAG,IAAI,CAACC,wBAAwB,CAACT,OAAO,CAAC;MAC1D,MAAM3C,OAAO,GAAG,CAAC,CAAC,EAAEhF,WAAW,CAAC0E,QAAQ,EAAEuD,WAAW,CAAC;MACtD,CAAC,CAAC,EAAEjI,WAAW,CAACqI,UAAU,EAAErD,OAAO,EAAEmD,WAAW,CAAC;MACjDnD,OAAO,CAACuD,EAAE,GAAGM,eAAe;MAC5B,OAAO,IAAI,CAACzE,uBAAuB,CAACc,oBAAoB,CAAC1E,aAAa,EAAEC,aAAa,EAAEuE,OAAO,CAAC;IACnG,CAAC,CAAC,CACGF,IAAI,CAAEtC,QAAQ,IAAK;MACpB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAI,cAAc,IAAIA,QAAQ,EAAE;QAC5B,IAAIA,QAAQ,CAACP,OAAO,KAAK,CAAC,EAAE;UACxB,MAAM,IAAI/B,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAAC4D,iBAAiB,EAAE,8DAA8D,CAAC;QAChK,CAAC,MACI;UACD,MAAMoB,eAAe,GAAG1G,+BAA+B,CAACC,QAAQ,CAAC;UACjE,OAAO;YACH,GAAGyG,eAAe;YAClB9F,wBAAwB,EAAE;UAC9B,CAAC;QACL;MACJ;MACA,OAAOD,mCAAmC,CAACV,QAAQ,CAAC;IACxD,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI0G,WAAW,CAACC,KAAK,EAAEzB,OAAO,EAAgB;IAAA,IAAdC,OAAO,uEAAG,CAAC,CAAC;IACpC;IACA;IACA,IAAI,CAACyB,iBAAiB,CAACD,KAAK,EAAE,aAAa,EAAEjJ,OAAO,CAAC+D,wBAAwB,CAAC4D,iBAAiB,CAAC;IAChG,IAAI,CAACC,uCAAuC,CAACJ,OAAO,EAAEC,OAAO,CAAC;IAC9D;IACAwB,KAAK,GAAG,IAAI,CAACE,cAAc,CAACF,KAAK,CAAC;IAClC,OAAOlD,OAAO,CAAC8B,OAAO,EAAE,CACnBjD,IAAI,CAAC,MAAM;MACZ;MACA;MACA,MAAMmD,WAAW,GAAG,IAAI,CAACC,wBAAwB,CAACR,OAAO,CAAC;MAC1D,MAAMS,WAAW,GAAG,IAAI,CAACC,wBAAwB,CAACT,OAAO,CAAC;MAC1D,IAAI,CAAC2B,aAAa,CAACH,KAAK,EAAE,aAAa,EAAEjJ,OAAO,CAAC+D,wBAAwB,CAAC4D,iBAAiB,CAAC;MAC5F,MAAM7C,OAAO,GAAG,CAAC,CAAC,EAAEhF,WAAW,CAAC0E,QAAQ,EAAEuD,WAAW,CAAC;MACtD,CAAC,CAAC,EAAEjI,WAAW,CAACqI,UAAU,EAAErD,OAAO,EAAEmD,WAAW,CAAC;MACjDnD,OAAO,CAACuD,EAAE,GAAGY,KAAK;MAClB,OAAO,IAAI,CAAC/E,uBAAuB,CAACc,oBAAoB,CAAC1E,aAAa,EAAEC,aAAa,EAAEuE,OAAO,CAAC;IACnG,CAAC,CAAC,CACGF,IAAI,CAAEtC,QAAQ,IAAK;MACpB;MACArC,KAAK,CAACsC,gBAAgB,CAACD,QAAQ,EAAEH,iCAAiC,CAAC;MACnE,OAAOG,QAAQ;IACnB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI+G,eAAe,CAACC,SAAS,EAAE9B,OAAO,EAAgB;IAAA,IAAdC,OAAO,uEAAG,CAAC,CAAC;IAC5C,IAAI,CAACvH,SAAS,CAAC0I,gBAAgB,CAACU,SAAS,CAAC,EAAE;MACxC,MAAM,IAAItJ,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAAC4D,iBAAiB,EAAE,qEAAqE,CAAC;IACvK;IACA;IACA;IACA,IAAI,CAACC,uCAAuC,CAACJ,OAAO,EAAEC,OAAO,CAAC;IAC9D;IACA;IACA;IACA;IACA6B,SAAS,GAAGA,SAAS,CAACC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC;IACzC,OAAOxD,OAAO,CAAC8B,OAAO,EAAE,CACnBjD,IAAI,CAAC,MAAM;MACZ;MACA;MACA,MAAMmD,WAAW,GAAG,IAAI,CAACC,wBAAwB,CAACR,OAAO,CAAC;MAC1D,MAAMS,WAAW,GAAG,IAAI,CAACC,wBAAwB,CAACT,OAAO,CAAC;MAC1D,MAAM3C,OAAO,GAAG,CAAC,CAAC,EAAEhF,WAAW,CAAC0E,QAAQ,EAAEuD,WAAW,CAAC;MACtD,CAAC,CAAC,EAAEjI,WAAW,CAACqI,UAAU,EAAErD,OAAO,EAAEmD,WAAW,CAAC;MACjDnD,OAAO,CAACwE,SAAS,GAAGA,SAAS;MAC7B,OAAO,IAAI,CAACpF,uBAAuB,CAACc,oBAAoB,CAAC1E,aAAa,EAAEC,aAAa,EAAEuE,OAAO,CAAC;IACnG,CAAC,CAAC,CACGF,IAAI,CAAEtC,QAAQ,IAAK;MACpB;MACArC,KAAK,CAACsC,gBAAgB,CAACD,QAAQ,EAAEF,qCAAqC,CAAC;MACvE,OAAOE,QAAQ;IACnB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIkH,gBAAgB,CAACjC,yBAAyB,EAAE0B,KAAK,EAAE;IAC/C,OAAO,IAAI,CAACQ,0BAA0B,CAAClC,yBAAyB,EAAE0B,KAAK,EAAE,kBAAkB,EAAExI,6BAA6B,CAAC;EAC/H;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIiJ,oBAAoB,CAACnC,yBAAyB,EAAE0B,KAAK,EAAE;IACnD,OAAO,IAAI,CAACQ,0BAA0B,CAAClC,yBAAyB,EAAE0B,KAAK,EAAE,sBAAsB,EAAEvI,gCAAgC,CAAC;EACtI;EACAiE,UAAU,GAAG;IACT,IAAI,IAAI,CAACE,OAAO,EAAE;MACd,OAAOkB,OAAO,CAAC8B,OAAO,CAAC,IAAI,CAAChD,OAAO,CAAC;IACxC;IACA,OAAO5E,KAAK,CAAC0J,aAAa,CAAC,IAAI,CAAC/F,GAAG,CAAC,CAC/BgB,IAAI,CAAEgF,SAAS,IAAK;MACrB,IAAI,CAAC1J,SAAS,CAAC0I,gBAAgB,CAACgB,SAAS,CAAC,EAAE;QACxC;QACA,MAAM,IAAI5J,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB,EAAE,+DAA+D,GACrJ,2EAA2E,GAC3E,kEAAkE,CAAC;MAC7E;MACA,IAAI,CAACa,OAAO,GAAI,gBAAe+E,SAAU,gBAAe;MACxD,OAAO,IAAI,CAAC/E,OAAO;IACvB,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI4E,0BAA0B,CAAClC,yBAAyB,EAAE0B,KAAK,EAAEY,UAAU,EAAEC,IAAI,EAAE;IAC3E,IAAI,CAACpC,8BAA8B,CAACH,yBAAyB,EAAEsC,UAAU,CAAC;IAC1E,IAAI,CAACX,iBAAiB,CAACD,KAAK,EAAEY,UAAU,CAAC;IACzC;IACAZ,KAAK,GAAG,IAAI,CAACE,cAAc,CAACF,KAAK,CAAC;IAClC,OAAOlD,OAAO,CAAC8B,OAAO,EAAE,CACnBjD,IAAI,CAAC,MAAM;MACZ;MACA;MACA,IAAI,CAACkD,0BAA0B,CAACP,yBAAyB,EAAEsC,UAAU,CAAC;MACtE,IAAI,CAACT,aAAa,CAACH,KAAK,EAAEY,UAAU,CAAC;MACrC;MACA,IAAIE,uBAAuB,GAAGxC,yBAAyB;MACvD,IAAIrH,SAAS,CAACkI,QAAQ,CAACb,yBAAyB,CAAC,EAAE;QAC/CwC,uBAAuB,GAAG,CAACxC,yBAAyB,CAAC;MACzD;MACA,MAAMzC,OAAO,GAAG;QACZuD,EAAE,EAAEY,KAAK;QACTe,mBAAmB,EAAED;MACzB,CAAC;MACD,OAAO,IAAI,CAAC7F,uBAAuB,CAACc,oBAAoB,CAACxE,yBAAyB,EAAEsJ,IAAI,EAAEhF,OAAO,CAAC;IACtG,CAAC,CAAC,CACGF,IAAI,CAAEtC,QAAQ,IAAK;MACpB,OAAOY,uCAAuC,CAACZ,QAAQ,CAAC;IAC5D,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;EACIsF,uCAAuC,CAACJ,OAAO,EAAEC,OAAO,EAAE;IACtD;IACA,IAAI,CAACvH,SAAS,CAAC4D,eAAe,CAAC0D,OAAO,CAAC,EAAE;MACrC,MAAM,IAAIxH,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACkG,eAAe,EAAE,mGAAmG,CAAC;IACnM;IACA;IACA,IAAI,CAAC/J,SAAS,CAAC4D,eAAe,CAAC2D,OAAO,CAAC,EAAE;MACrC,MAAM,IAAIzH,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACmG,eAAe,EAAE,sCAAsC,CAAC;IACtI;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIlC,wBAAwB,CAACR,OAAO,EAAE;IAC9B,MAAMO,WAAW,GAAG,CAAC,CAAC,EAAEjI,WAAW,CAAC0E,QAAQ,EAAEgD,OAAO,CAAC;IACtD,MAAM2C,WAAW,GAAG1K,MAAM,CAAC2K,IAAI,CAACrC,WAAW,CAAC;IAC5C,MAAMsC,gBAAgB,GAAG,CAAC,MAAM,EAAE,cAAc,CAAC;IACjD,IAAIC,6BAA6B,GAAG,KAAK;IACzCH,WAAW,CAAC1H,OAAO,CAAE8H,UAAU,IAAK;MAChC;MACA,IAAIF,gBAAgB,CAACxB,OAAO,CAAC0B,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE;QAC7C,MAAM,IAAIvK,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACkG,eAAe,EAAG,0CAAyCM,UAAW,mCAAkC,GAC9K,4BAA4B,CAAC;MACrC,CAAC,MACI;QACDD,6BAA6B,GAAG,IAAI;MACxC;IACJ,CAAC,CAAC;IACF;IACA,IAAI,CAACA,6BAA6B,EAAE;MAChC,MAAM,IAAItK,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACkG,eAAe,EAAE,yFAAyF,CAAC;IACzL;IACA,MAAMO,eAAe,GAAG,CAACD,UAAU,EAAE3K,KAAK,KAAK;MAC3C;MACA,IAAI,CAACM,SAAS,CAAC4D,eAAe,CAAClE,KAAK,CAAC,EAAE;QACnC,MAAM,IAAII,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACkG,eAAe,EAAG,wDAAuDM,UAAW,cAAa,GACvK,0BAA0B,CAAC;MACnC;MACA9K,MAAM,CAAC2K,IAAI,CAACxK,KAAK,CAAC,CAAC6C,OAAO,CAAEgI,MAAM,IAAK;QACnC,IAAI,CAACvK,SAAS,CAACkI,QAAQ,CAACxI,KAAK,CAAC6K,MAAM,CAAC,CAAC,EAAE;UACpC;UACA,MAAM,IAAIzK,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACkG,eAAe,EAAG,wDAAuDM,UAAW,IAAGE,MAAO,IAAG,GACvK,mCAAmC,CAAC;QAC5C,CAAC,MACI,IAAIF,UAAU,KAAK,MAAM,IAAI,WAAW,CAACG,IAAI,CAACD,MAAM,CAAC,EAAE;UACxD;UACA,MAAM,IAAIzK,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACkG,eAAe,EAAG,oDAAmDQ,MAAO,aAAY,CAAC;QACvK;MACJ,CAAC,CAAC;IACN,CAAC;IACD,IAAI1C,WAAW,CAAClB,IAAI,KAAK9D,SAAS,EAAE;MAChCyH,eAAe,CAAC,MAAM,EAAEzC,WAAW,CAAClB,IAAI,CAAC;IAC7C;IACA,IAAIkB,WAAW,CAACjB,YAAY,KAAK/D,SAAS,EAAE;MACxCyH,eAAe,CAAC,cAAc,EAAEzC,WAAW,CAACjB,YAAY,CAAC;IAC7D;IACA;IACA,IAAI,MAAM,IAAIiB,WAAW,EAAE;MACvB5H,oBAAoB,CAACwK,6BAA6B,CAAClI,OAAO,CAAEmI,cAAc,IAAK;QAC3E,IAAIA,cAAc,IAAI7C,WAAW,CAAClB,IAAI,EAAE;UACpC,MAAM,IAAI7G,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACkG,eAAe,EAAG,oDAAmDW,cAAe,aAAY,CAAC;QAC/K;MACJ,CAAC,CAAC;IACN;IACA;IACA,IAAI7C,WAAW,CAACjB,YAAY,EAAE;MAC1B7G,KAAK,CAACsC,gBAAgB,CAACwF,WAAW,CAACjB,YAAY,EAAElG,wCAAwC,CAAC;IAC9F;IACA,OAAOmH,WAAW;EACtB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,wBAAwB,CAACT,OAAO,EAAE;IAC9B,MAAMQ,WAAW,GAAG,CAAC,CAAC,EAAEnI,WAAW,CAAC0E,QAAQ,EAAEiD,OAAO,CAAC;IACtD;IACAtH,oBAAoB,CAAC0K,wBAAwB,CAACpI,OAAO,CAAEmI,cAAc,IAAK;MACtE,IAAIA,cAAc,IAAI3C,WAAW,EAAE;QAC/B,MAAM,IAAIjI,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACmG,eAAe,EAAG,+CAA8CU,cAAe,aAAY,CAAC;MAC1K;IACJ,CAAC,CAAC;IACF;IACA3K,KAAK,CAACsC,gBAAgB,CAAC0F,WAAW,EAAE/G,0BAA0B,CAAC;IAC/D;IACA,IAAI,cAAc,IAAI+G,WAAW,IAAI,CAAC/H,SAAS,CAAC0I,gBAAgB,CAACX,WAAW,CAAC6C,YAAY,CAAC,EAAE;MACxF,MAAMC,OAAO,GAAI,aAAa,IAAItD,OAAO,GAAI,aAAa,GAAG,cAAc;MAC3E,MAAM,IAAIzH,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACmG,eAAe,EAAG,wDAAuDa,OAAQ,yBAAwB,GAC/K,wBAAwB,CAAC;IACjC,CAAC,MACI,IAAI,SAAS,IAAI9C,WAAW,IAAI,CAAC/H,SAAS,CAACwE,SAAS,CAACuD,WAAW,CAAC+C,OAAO,CAAC,EAAE;MAC5E,MAAMD,OAAO,GAAI,QAAQ,IAAItD,OAAO,GAAI,QAAQ,GAAG,SAAS;MAC5D,MAAM,IAAIzH,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACmG,eAAe,EAAG,wDAAuDa,OAAQ,yBAAwB,GAC/K,eAAe,CAAC;IACxB,CAAC,MACI,IAAI,UAAU,IAAI9C,WAAW,IAAI,CAAC/H,SAAS,CAAC0I,gBAAgB,CAACX,WAAW,CAACgD,QAAQ,CAAC,EAAE;MACrF,MAAM,IAAIjL,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACmG,eAAe,EAAE,sFAAsF,GAC7K,wBAAwB,CAAC;IACjC,CAAC,MACI,IAAI,yBAAyB,IAAIjC,WAAW,IAC7C,CAAC/H,SAAS,CAAC0I,gBAAgB,CAACX,WAAW,CAACiD,uBAAuB,CAAC,EAAE;MAClE,MAAMH,OAAO,GAAI,uBAAuB,IAAItD,OAAO,GAAI,uBAAuB,GAAG,yBAAyB;MAC1G,MAAM,IAAIzH,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACmG,eAAe,EAAG,wDAAuDa,OAAQ,yBAAwB,GAC/K,wBAAwB,CAAC;IACjC,CAAC,MACI,IAAI,cAAc,IAAI9C,WAAW,IAAI,CAAC/H,SAAS,CAACiL,QAAQ,CAAClD,WAAW,CAACmD,YAAY,CAAC,EAAE;MACrF,MAAML,OAAO,GAAI,YAAY,IAAItD,OAAO,GAAI,YAAY,GAAG,cAAc;MACzE,MAAM,IAAIzH,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACmG,eAAe,EAAG,wDAAuDa,OAAQ,yBAAwB,GAC/K,cAAc,CAAC;IACvB,CAAC,MACI,IAAI,mBAAmB,IAAI9C,WAAW,IAAI,CAAC/H,SAAS,CAACwE,SAAS,CAACuD,WAAW,CAACoD,iBAAiB,CAAC,EAAE;MAChG,MAAMN,OAAO,GAAI,kBAAkB,IAAItD,OAAO,GAAI,kBAAkB,GAAG,mBAAmB;MAC1F,MAAM,IAAIzH,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACmG,eAAe,EAAG,wDAAuDa,OAAQ,yBAAwB,GAC/K,eAAe,CAAC;IACxB,CAAC,MACI,IAAI,iBAAiB,IAAI9C,WAAW,IAAI,CAAC/H,SAAS,CAACwE,SAAS,CAACuD,WAAW,CAACqD,eAAe,CAAC,EAAE;MAC5F,MAAMP,OAAO,GAAI,gBAAgB,IAAItD,OAAO,GAAI,gBAAgB,GAAG,iBAAiB;MACpF,MAAM,IAAIzH,OAAO,CAAC4C,sBAAsB,CAAC5C,OAAO,CAAC+D,wBAAwB,CAACmG,eAAe,EAAG,wDAAuDa,OAAQ,yBAAwB,GAC/K,eAAe,CAAC;IACxB;IACA,OAAO9C,WAAW;EACtB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIP,8BAA8B,CAACH,yBAAyB,EAAEsC,UAAU,EAAiE;IAAA,IAA/D0B,SAAS,uEAAGvL,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB;IAC/H,IAAI,CAAC9D,SAAS,CAACqF,eAAe,CAACgC,yBAAyB,CAAC,IACrD,CAACrH,SAAS,CAAC0I,gBAAgB,CAACrB,yBAAyB,CAAC,EAAE;MACxD,MAAM,IAAIvH,OAAO,CAAC4C,sBAAsB,CAAC2I,SAAS,EAAG,qCAAoC1B,UAAW,qCAAoC,GACpI,kBAAkB,CAAC;IAC3B;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI/B,0BAA0B,CAACP,yBAAyB,EAAEsC,UAAU,EAAiE;IAAA,IAA/D0B,SAAS,uEAAGvL,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB;IAC3H,IAAI9D,SAAS,CAACkF,OAAO,CAACmC,yBAAyB,CAAC,EAAE;MAC9C;MACA,IAAIA,yBAAyB,CAAC/B,MAAM,GAAG,IAAI,EAAE;QACzC,MAAM,IAAIxF,OAAO,CAAC4C,sBAAsB,CAAC2I,SAAS,EAAG,gEAA+D1B,UAAW,YAAW,GACtI,8EAA8E,CAAC;MACvF;MACA;MACAtC,yBAAyB,CAAC9E,OAAO,CAAC,CAAC+I,iBAAiB,EAAEhI,KAAK,KAAK;QAC5D,IAAI,CAACtD,SAAS,CAAC0I,gBAAgB,CAAC4C,iBAAiB,CAAC,EAAE;UAChD,MAAM,IAAIxL,OAAO,CAAC4C,sBAAsB,CAAC2I,SAAS,EAAG,kCAAiC1B,UAAW,eAAcrG,KAAM,aAAY,GAC7H,mBAAmB,CAAC;QAC5B;MACJ,CAAC,CAAC;IACN;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI0F,iBAAiB,CAACD,KAAK,EAAEY,UAAU,EAAiE;IAAA,IAA/D0B,SAAS,uEAAGvL,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB;IAC9F,IAAI,CAAC9D,SAAS,CAAC0I,gBAAgB,CAACK,KAAK,CAAC,EAAE;MACpC,MAAM,IAAIjJ,OAAO,CAAC4C,sBAAsB,CAAC2I,SAAS,EAAG,qBAAoB1B,UAAW,+CAA8C,GAC9H,8BAA8B,CAAC;IACvC;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIT,aAAa,CAACH,KAAK,EAAEY,UAAU,EAAiE;IAAA,IAA/D0B,SAAS,uEAAGvL,OAAO,CAAC+D,wBAAwB,CAACC,gBAAgB;IAC1F,IAAI,CAAC9D,SAAS,CAACuL,OAAO,CAACxC,KAAK,CAAC,EAAE;MAC3B,MAAM,IAAIjJ,OAAO,CAAC4C,sBAAsB,CAAC2I,SAAS,EAAG,qBAAoB1B,UAAW,+CAA8C,GAC9H,8BAA8B,CAAC;IACvC;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIV,cAAc,CAACF,KAAK,EAAE;IAClB,IAAI,CAAC,aAAa,CAACyB,IAAI,CAACzB,KAAK,CAAC,EAAE;MAC5BA,KAAK,GAAI,WAAUA,KAAM,EAAC;IAC9B;IACA,OAAOA,KAAK;EAChB;AACJ;AACAtJ,OAAO,CAACE,SAAS,GAAGA,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}