{"ast":null,"code":"/*! firebase-admin v12.7.0 */\n\"use strict\";\n\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FirebaseApp = exports.FirebaseAppInternals = void 0;\nconst credential_internal_1 = require(\"./credential-internal\");\nconst validator = require(\"../utils/validator\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst error_1 = require(\"../utils/error\");\nconst TOKEN_EXPIRY_THRESHOLD_MILLIS = 5 * 60 * 1000;\n/**\n * Internals of a FirebaseApp instance.\n */\nclass FirebaseAppInternals {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  constructor(credential_) {\n    this.credential_ = credential_;\n    this.tokenListeners_ = [];\n    this.isRefreshing = false;\n  }\n  getToken() {\n    let forceRefresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (forceRefresh || this.shouldRefresh()) {\n      this.promiseToCachedToken_ = this.refreshToken();\n    }\n    return this.promiseToCachedToken_;\n  }\n  getCachedToken() {\n    return this.cachedToken_ || null;\n  }\n  refreshToken() {\n    this.isRefreshing = true;\n    return Promise.resolve(this.credential_.getAccessToken()).then(result => {\n      // Since the developer can provide the credential implementation, we want to weakly verify\n      // the return type until the type is properly exported.\n      if (!validator.isNonNullObject(result) || typeof result.expires_in !== 'number' || typeof result.access_token !== 'string') {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Invalid access token generated: \"${JSON.stringify(result)}\". Valid access ` + 'tokens must be an object with the \"expires_in\" (number) and \"access_token\" ' + '(string) properties.');\n      }\n      const token = {\n        accessToken: result.access_token,\n        expirationTime: Date.now() + result.expires_in * 1000\n      };\n      if (!this.cachedToken_ || this.cachedToken_.accessToken !== token.accessToken || this.cachedToken_.expirationTime !== token.expirationTime) {\n        // Update the cache before firing listeners. Listeners may directly query the\n        // cached token state.\n        this.cachedToken_ = token;\n        this.tokenListeners_.forEach(listener => {\n          listener(token.accessToken);\n        });\n      }\n      return token;\n    }).catch(error => {\n      let errorMessage = typeof error === 'string' ? error : error.message;\n      errorMessage = 'Credential implementation provided to initializeApp() via the ' + '\"credential\" property failed to fetch a valid Google OAuth2 access token with the ' + `following error: \"${errorMessage}\".`;\n      if (errorMessage.indexOf('invalid_grant') !== -1) {\n        errorMessage += ' There are two likely causes: (1) your server time is not properly ' + 'synced or (2) your certificate key file has been revoked. To solve (1), re-sync the ' + 'time on your server. To solve (2), make sure the key ID for your key file is still ' + 'present at https://console.firebase.google.com/iam-admin/serviceaccounts/project. If ' + 'not, generate a new key file at ' + 'https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk.';\n      }\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }).finally(() => {\n      this.isRefreshing = false;\n    });\n  }\n  shouldRefresh() {\n    return (!this.cachedToken_ || this.cachedToken_.expirationTime - Date.now() <= TOKEN_EXPIRY_THRESHOLD_MILLIS) && !this.isRefreshing;\n  }\n  /**\n   * Adds a listener that is called each time a token changes.\n   *\n   * @param listener - The listener that will be called with each new token.\n   */\n  addAuthTokenListener(listener) {\n    this.tokenListeners_.push(listener);\n    if (this.cachedToken_) {\n      listener(this.cachedToken_.accessToken);\n    }\n  }\n  /**\n   * Removes a token listener.\n   *\n   * @param listener - The listener to remove.\n   */\n  removeAuthTokenListener(listener) {\n    this.tokenListeners_ = this.tokenListeners_.filter(other => other !== listener);\n  }\n}\nexports.FirebaseAppInternals = FirebaseAppInternals;\n/**\n * Global context object for a collection of services using a shared authentication state.\n *\n * @internal\n */\nclass FirebaseApp {\n  constructor(options, name, appStore) {\n    this.appStore = appStore;\n    this.services_ = {};\n    this.isDeleted_ = false;\n    this.name_ = name;\n    this.options_ = (0, deep_copy_1.deepCopy)(options);\n    if (!validator.isNonNullObject(this.options_)) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Invalid Firebase app options passed as the first argument to initializeApp() for the ' + `app named \"${this.name_}\". Options must be a non-null object.`);\n    }\n    const hasCredential = ('credential' in this.options_);\n    if (!hasCredential) {\n      this.options_.credential = (0, credential_internal_1.getApplicationDefault)(this.options_.httpAgent);\n    }\n    const credential = this.options_.credential;\n    if (typeof credential !== 'object' || credential === null || typeof credential.getAccessToken !== 'function') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Invalid Firebase app options passed as the first argument to initializeApp() for the ' + `app named \"${this.name_}\". The \"credential\" property must be an object which implements ` + 'the Credential interface.');\n    }\n    this.INTERNAL = new FirebaseAppInternals(credential);\n  }\n  /**\n   * Returns the name of the FirebaseApp instance.\n   *\n   * @returns The name of the FirebaseApp instance.\n   */\n  get name() {\n    this.checkDestroyed_();\n    return this.name_;\n  }\n  /**\n   * Returns the options for the FirebaseApp instance.\n   *\n   * @returns The options for the FirebaseApp instance.\n   */\n  get options() {\n    this.checkDestroyed_();\n    return (0, deep_copy_1.deepCopy)(this.options_);\n  }\n  /**\n   * @internal\n   */\n  getOrInitService(name, init) {\n    return this.ensureService_(name, () => init(this));\n  }\n  /**\n   * Deletes the FirebaseApp instance.\n   *\n   * @returns An empty Promise fulfilled once the FirebaseApp instance is deleted.\n   */\n  delete() {\n    this.checkDestroyed_();\n    // Also remove the instance from the AppStore. This is needed to support the existing\n    // app.delete() use case. In the future we can remove this API, and deleteApp() will\n    // become the only way to tear down an App.\n    this.appStore?.removeApp(this.name);\n    return Promise.all(Object.keys(this.services_).map(serviceName => {\n      const service = this.services_[serviceName];\n      if (isStateful(service)) {\n        return service.delete();\n      }\n      return Promise.resolve();\n    })).then(() => {\n      this.services_ = {};\n      this.isDeleted_ = true;\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ensureService_(serviceName, initializer) {\n    this.checkDestroyed_();\n    if (!(serviceName in this.services_)) {\n      this.services_[serviceName] = initializer();\n    }\n    return this.services_[serviceName];\n  }\n  /**\n   * Throws an Error if the FirebaseApp instance has already been deleted.\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  checkDestroyed_() {\n    if (this.isDeleted_) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.APP_DELETED, `Firebase app named \"${this.name_}\" has already been deleted.`);\n    }\n  }\n}\nexports.FirebaseApp = FirebaseApp;\nfunction isStateful(service) {\n  return typeof service.delete === 'function';\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","FirebaseApp","FirebaseAppInternals","credential_internal_1","require","validator","deep_copy_1","error_1","TOKEN_EXPIRY_THRESHOLD_MILLIS","constructor","credential_","tokenListeners_","isRefreshing","getToken","forceRefresh","shouldRefresh","promiseToCachedToken_","refreshToken","getCachedToken","cachedToken_","Promise","resolve","getAccessToken","then","result","isNonNullObject","expires_in","access_token","FirebaseAppError","AppErrorCodes","INVALID_CREDENTIAL","JSON","stringify","token","accessToken","expirationTime","Date","now","forEach","listener","catch","error","errorMessage","message","indexOf","finally","addAuthTokenListener","push","removeAuthTokenListener","filter","other","options","name","appStore","services_","isDeleted_","name_","options_","deepCopy","INVALID_APP_OPTIONS","hasCredential","credential","getApplicationDefault","httpAgent","INTERNAL","checkDestroyed_","getOrInitService","init","ensureService_","delete","removeApp","all","keys","map","serviceName","service","isStateful","initializer","APP_DELETED"],"sources":["/home/yadu/Music/Gifty/node_modules/firebase-admin/lib/app/firebase-app.js"],"sourcesContent":["/*! firebase-admin v12.7.0 */\n\"use strict\";\n/*!\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FirebaseApp = exports.FirebaseAppInternals = void 0;\nconst credential_internal_1 = require(\"./credential-internal\");\nconst validator = require(\"../utils/validator\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst error_1 = require(\"../utils/error\");\nconst TOKEN_EXPIRY_THRESHOLD_MILLIS = 5 * 60 * 1000;\n/**\n * Internals of a FirebaseApp instance.\n */\nclass FirebaseAppInternals {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    constructor(credential_) {\n        this.credential_ = credential_;\n        this.tokenListeners_ = [];\n        this.isRefreshing = false;\n    }\n    getToken(forceRefresh = false) {\n        if (forceRefresh || this.shouldRefresh()) {\n            this.promiseToCachedToken_ = this.refreshToken();\n        }\n        return this.promiseToCachedToken_;\n    }\n    getCachedToken() {\n        return this.cachedToken_ || null;\n    }\n    refreshToken() {\n        this.isRefreshing = true;\n        return Promise.resolve(this.credential_.getAccessToken())\n            .then((result) => {\n            // Since the developer can provide the credential implementation, we want to weakly verify\n            // the return type until the type is properly exported.\n            if (!validator.isNonNullObject(result) ||\n                typeof result.expires_in !== 'number' ||\n                typeof result.access_token !== 'string') {\n                throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Invalid access token generated: \"${JSON.stringify(result)}\". Valid access ` +\n                    'tokens must be an object with the \"expires_in\" (number) and \"access_token\" ' +\n                    '(string) properties.');\n            }\n            const token = {\n                accessToken: result.access_token,\n                expirationTime: Date.now() + (result.expires_in * 1000),\n            };\n            if (!this.cachedToken_\n                || this.cachedToken_.accessToken !== token.accessToken\n                || this.cachedToken_.expirationTime !== token.expirationTime) {\n                // Update the cache before firing listeners. Listeners may directly query the\n                // cached token state.\n                this.cachedToken_ = token;\n                this.tokenListeners_.forEach((listener) => {\n                    listener(token.accessToken);\n                });\n            }\n            return token;\n        })\n            .catch((error) => {\n            let errorMessage = (typeof error === 'string') ? error : error.message;\n            errorMessage = 'Credential implementation provided to initializeApp() via the ' +\n                '\"credential\" property failed to fetch a valid Google OAuth2 access token with the ' +\n                `following error: \"${errorMessage}\".`;\n            if (errorMessage.indexOf('invalid_grant') !== -1) {\n                errorMessage += ' There are two likely causes: (1) your server time is not properly ' +\n                    'synced or (2) your certificate key file has been revoked. To solve (1), re-sync the ' +\n                    'time on your server. To solve (2), make sure the key ID for your key file is still ' +\n                    'present at https://console.firebase.google.com/iam-admin/serviceaccounts/project. If ' +\n                    'not, generate a new key file at ' +\n                    'https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk.';\n            }\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n        })\n            .finally(() => {\n            this.isRefreshing = false;\n        });\n    }\n    shouldRefresh() {\n        return (!this.cachedToken_ || (this.cachedToken_.expirationTime - Date.now()) <= TOKEN_EXPIRY_THRESHOLD_MILLIS)\n            && !this.isRefreshing;\n    }\n    /**\n     * Adds a listener that is called each time a token changes.\n     *\n     * @param listener - The listener that will be called with each new token.\n     */\n    addAuthTokenListener(listener) {\n        this.tokenListeners_.push(listener);\n        if (this.cachedToken_) {\n            listener(this.cachedToken_.accessToken);\n        }\n    }\n    /**\n     * Removes a token listener.\n     *\n     * @param listener - The listener to remove.\n     */\n    removeAuthTokenListener(listener) {\n        this.tokenListeners_ = this.tokenListeners_.filter((other) => other !== listener);\n    }\n}\nexports.FirebaseAppInternals = FirebaseAppInternals;\n/**\n * Global context object for a collection of services using a shared authentication state.\n *\n * @internal\n */\nclass FirebaseApp {\n    constructor(options, name, appStore) {\n        this.appStore = appStore;\n        this.services_ = {};\n        this.isDeleted_ = false;\n        this.name_ = name;\n        this.options_ = (0, deep_copy_1.deepCopy)(options);\n        if (!validator.isNonNullObject(this.options_)) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Invalid Firebase app options passed as the first argument to initializeApp() for the ' +\n                `app named \"${this.name_}\". Options must be a non-null object.`);\n        }\n        const hasCredential = ('credential' in this.options_);\n        if (!hasCredential) {\n            this.options_.credential = (0, credential_internal_1.getApplicationDefault)(this.options_.httpAgent);\n        }\n        const credential = this.options_.credential;\n        if (typeof credential !== 'object' || credential === null || typeof credential.getAccessToken !== 'function') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Invalid Firebase app options passed as the first argument to initializeApp() for the ' +\n                `app named \"${this.name_}\". The \"credential\" property must be an object which implements ` +\n                'the Credential interface.');\n        }\n        this.INTERNAL = new FirebaseAppInternals(credential);\n    }\n    /**\n     * Returns the name of the FirebaseApp instance.\n     *\n     * @returns The name of the FirebaseApp instance.\n     */\n    get name() {\n        this.checkDestroyed_();\n        return this.name_;\n    }\n    /**\n     * Returns the options for the FirebaseApp instance.\n     *\n     * @returns The options for the FirebaseApp instance.\n     */\n    get options() {\n        this.checkDestroyed_();\n        return (0, deep_copy_1.deepCopy)(this.options_);\n    }\n    /**\n     * @internal\n     */\n    getOrInitService(name, init) {\n        return this.ensureService_(name, () => init(this));\n    }\n    /**\n     * Deletes the FirebaseApp instance.\n     *\n     * @returns An empty Promise fulfilled once the FirebaseApp instance is deleted.\n     */\n    delete() {\n        this.checkDestroyed_();\n        // Also remove the instance from the AppStore. This is needed to support the existing\n        // app.delete() use case. In the future we can remove this API, and deleteApp() will\n        // become the only way to tear down an App.\n        this.appStore?.removeApp(this.name);\n        return Promise.all(Object.keys(this.services_).map((serviceName) => {\n            const service = this.services_[serviceName];\n            if (isStateful(service)) {\n                return service.delete();\n            }\n            return Promise.resolve();\n        })).then(() => {\n            this.services_ = {};\n            this.isDeleted_ = true;\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    ensureService_(serviceName, initializer) {\n        this.checkDestroyed_();\n        if (!(serviceName in this.services_)) {\n            this.services_[serviceName] = initializer();\n        }\n        return this.services_[serviceName];\n    }\n    /**\n     * Throws an Error if the FirebaseApp instance has already been deleted.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    checkDestroyed_() {\n        if (this.isDeleted_) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.APP_DELETED, `Firebase app named \"${this.name_}\" has already been deleted.`);\n        }\n    }\n}\nexports.FirebaseApp = FirebaseApp;\nfunction isStateful(service) {\n    return typeof service.delete === 'function';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}