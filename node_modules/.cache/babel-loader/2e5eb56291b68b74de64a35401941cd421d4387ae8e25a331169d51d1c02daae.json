{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tokenCache = exports.AzureCredentialCache = exports.AZURE_BASE_URL = void 0;\nexports.addAzureParams = addAzureParams;\nexports.prepareRequest = prepareRequest;\nexports.fetchAzureKMSToken = fetchAzureKMSToken;\nexports.loadAzureCredentials = loadAzureCredentials;\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst errors_1 = require(\"../errors\");\nconst MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS = 6000;\n/** Base URL for getting Azure tokens. */\nexports.AZURE_BASE_URL = 'http://169.254.169.254/metadata/identity/oauth2/token?';\n/**\n * @internal\n */\nclass AzureCredentialCache {\n  constructor() {\n    this.cachedToken = null;\n  }\n  async getToken() {\n    if (this.cachedToken == null || this.needsRefresh(this.cachedToken)) {\n      this.cachedToken = await this._getToken();\n    }\n    return {\n      accessToken: this.cachedToken.accessToken\n    };\n  }\n  needsRefresh(token) {\n    const timeUntilExpirationMS = token.expiresOnTimestamp - Date.now();\n    return timeUntilExpirationMS <= MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS;\n  }\n  /**\n   * exposed for testing\n   */\n  resetCache() {\n    this.cachedToken = null;\n  }\n  /**\n   * exposed for testing\n   */\n  _getToken() {\n    return fetchAzureKMSToken();\n  }\n}\nexports.AzureCredentialCache = AzureCredentialCache;\n/** @internal */\nexports.tokenCache = new AzureCredentialCache();\n/** @internal */\nasync function parseResponse(response) {\n  const {\n    status,\n    body: rawBody\n  } = response;\n  const body = (() => {\n    try {\n      return JSON.parse(rawBody);\n    } catch {\n      throw new errors_1.MongoCryptAzureKMSRequestError('Malformed JSON body in GET request.');\n    }\n  })();\n  if (status !== 200) {\n    throw new errors_1.MongoCryptAzureKMSRequestError('Unable to complete request.', body);\n  }\n  if (!body.access_token) {\n    throw new errors_1.MongoCryptAzureKMSRequestError('Malformed response body - missing field `access_token`.');\n  }\n  if (!body.expires_in) {\n    throw new errors_1.MongoCryptAzureKMSRequestError('Malformed response body - missing field `expires_in`.');\n  }\n  const expiresInMS = Number(body.expires_in) * 1000;\n  if (Number.isNaN(expiresInMS)) {\n    throw new errors_1.MongoCryptAzureKMSRequestError('Malformed response body - unable to parse int from `expires_in` field.');\n  }\n  return {\n    accessToken: body.access_token,\n    expiresOnTimestamp: Date.now() + expiresInMS\n  };\n}\n/**\n * @internal\n * Get the Azure endpoint URL.\n */\nfunction addAzureParams(url, resource, username) {\n  url.searchParams.append('api-version', '2018-02-01');\n  url.searchParams.append('resource', resource);\n  if (username) {\n    url.searchParams.append('client_id', username);\n  }\n  return url;\n}\n/**\n * @internal\n *\n * parses any options provided by prose tests to `fetchAzureKMSToken` and merges them with\n * the default values for headers and the request url.\n */\nfunction prepareRequest(options) {\n  const url = new URL(options.url?.toString() ?? exports.AZURE_BASE_URL);\n  addAzureParams(url, 'https://vault.azure.net');\n  const headers = {\n    ...options.headers,\n    'Content-Type': 'application/json',\n    Metadata: true\n  };\n  return {\n    headers,\n    url\n  };\n}\n/**\n * @internal\n *\n * `AzureKMSRequestOptions` allows prose tests to modify the http request sent to the idms\n * servers.  This is required to simulate different server conditions.  No options are expected to\n * be set outside of tests.\n *\n * exposed for CSFLE\n * [prose test 18](https://github.com/mongodb/specifications/tree/master/source/client-side-encryption/tests#azure-imds-credentials)\n */\nasync function fetchAzureKMSToken() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    headers,\n    url\n  } = prepareRequest(options);\n  try {\n    const response = await (0, utils_1.get)(url, {\n      headers\n    });\n    return await parseResponse(response);\n  } catch (error) {\n    if (error instanceof error_1.MongoNetworkTimeoutError) {\n      throw new errors_1.MongoCryptAzureKMSRequestError(`[Azure KMS] ${error.message}`);\n    }\n    throw error;\n  }\n}\n/**\n * @internal\n *\n * @throws Will reject with a `MongoCryptError` if the http request fails or the http response is malformed.\n */\nasync function loadAzureCredentials(kmsProviders) {\n  const azure = await exports.tokenCache.getToken();\n  return {\n    ...kmsProviders,\n    azure\n  };\n}","map":{"version":3,"mappings":"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","names":["exports","MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS","AzureCredentialCache","constructor","getToken","cachedToken","needsRefresh","_getToken","accessToken","token","timeUntilExpirationMS","expiresOnTimestamp","Date","now","resetCache","fetchAzureKMSToken","parseResponse","response","status","body","rawBody","JSON","parse","errors_1","access_token","expires_in","expiresInMS","Number","isNaN","addAzureParams","url","resource","username","searchParams","append","prepareRequest","options","URL","toString","headers","Metadata","error","error_1","message","loadAzureCredentials","kmsProviders","azure"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/client-side-encryption/providers/azure.ts"],"sourcesContent":["import { type Document } from '../../bson';\nimport { MongoNetworkTimeoutError } from '../../error';\nimport { get } from '../../utils';\nimport { MongoCryptAzureKMSRequestError } from '../errors';\nimport { type KMSProviders } from './index';\n\nconst MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS = 6000;\n/** Base URL for getting Azure tokens. */\nexport const AZURE_BASE_URL = 'http://169.254.169.254/metadata/identity/oauth2/token?';\n\n/**\n * The access token that libmongocrypt expects for Azure kms.\n */\ninterface AccessToken {\n  accessToken: string;\n}\n\n/**\n * The response from the azure idms endpoint, including the `expiresOnTimestamp`.\n * `expiresOnTimestamp` is needed for caching.\n */\ninterface AzureTokenCacheEntry extends AccessToken {\n  accessToken: string;\n  expiresOnTimestamp: number;\n}\n\n/**\n * @internal\n */\nexport class AzureCredentialCache {\n  cachedToken: AzureTokenCacheEntry | null = null;\n\n  async getToken(): Promise<AccessToken> {\n    if (this.cachedToken == null || this.needsRefresh(this.cachedToken)) {\n      this.cachedToken = await this._getToken();\n    }\n\n    return { accessToken: this.cachedToken.accessToken };\n  }\n\n  needsRefresh(token: AzureTokenCacheEntry): boolean {\n    const timeUntilExpirationMS = token.expiresOnTimestamp - Date.now();\n    return timeUntilExpirationMS <= MINIMUM_TOKEN_REFRESH_IN_MILLISECONDS;\n  }\n\n  /**\n   * exposed for testing\n   */\n  resetCache() {\n    this.cachedToken = null;\n  }\n\n  /**\n   * exposed for testing\n   */\n  _getToken(): Promise<AzureTokenCacheEntry> {\n    return fetchAzureKMSToken();\n  }\n}\n\n/** @internal */\nexport const tokenCache = new AzureCredentialCache();\n\n/** @internal */\nasync function parseResponse(response: {\n  body: string;\n  status?: number;\n}): Promise<AzureTokenCacheEntry> {\n  const { status, body: rawBody } = response;\n\n  const body: { expires_in?: number; access_token?: string } = (() => {\n    try {\n      return JSON.parse(rawBody);\n    } catch {\n      throw new MongoCryptAzureKMSRequestError('Malformed JSON body in GET request.');\n    }\n  })();\n\n  if (status !== 200) {\n    throw new MongoCryptAzureKMSRequestError('Unable to complete request.', body);\n  }\n\n  if (!body.access_token) {\n    throw new MongoCryptAzureKMSRequestError(\n      'Malformed response body - missing field `access_token`.'\n    );\n  }\n\n  if (!body.expires_in) {\n    throw new MongoCryptAzureKMSRequestError(\n      'Malformed response body - missing field `expires_in`.'\n    );\n  }\n\n  const expiresInMS = Number(body.expires_in) * 1000;\n  if (Number.isNaN(expiresInMS)) {\n    throw new MongoCryptAzureKMSRequestError(\n      'Malformed response body - unable to parse int from `expires_in` field.'\n    );\n  }\n\n  return {\n    accessToken: body.access_token,\n    expiresOnTimestamp: Date.now() + expiresInMS\n  };\n}\n\n/**\n * @internal\n *\n * exposed for CSFLE\n * [prose test 18](https://github.com/mongodb/specifications/tree/master/source/client-side-encryption/tests#azure-imds-credentials)\n */\nexport interface AzureKMSRequestOptions {\n  headers?: Document;\n  url?: URL | string;\n}\n\n/**\n * @internal\n * Get the Azure endpoint URL.\n */\nexport function addAzureParams(url: URL, resource: string, username?: string): URL {\n  url.searchParams.append('api-version', '2018-02-01');\n  url.searchParams.append('resource', resource);\n  if (username) {\n    url.searchParams.append('client_id', username);\n  }\n  return url;\n}\n\n/**\n * @internal\n *\n * parses any options provided by prose tests to `fetchAzureKMSToken` and merges them with\n * the default values for headers and the request url.\n */\nexport function prepareRequest(options: AzureKMSRequestOptions): {\n  headers: Document;\n  url: URL;\n} {\n  const url = new URL(options.url?.toString() ?? AZURE_BASE_URL);\n  addAzureParams(url, 'https://vault.azure.net');\n  const headers = { ...options.headers, 'Content-Type': 'application/json', Metadata: true };\n  return { headers, url };\n}\n\n/**\n * @internal\n *\n * `AzureKMSRequestOptions` allows prose tests to modify the http request sent to the idms\n * servers.  This is required to simulate different server conditions.  No options are expected to\n * be set outside of tests.\n *\n * exposed for CSFLE\n * [prose test 18](https://github.com/mongodb/specifications/tree/master/source/client-side-encryption/tests#azure-imds-credentials)\n */\nexport async function fetchAzureKMSToken(\n  options: AzureKMSRequestOptions = {}\n): Promise<AzureTokenCacheEntry> {\n  const { headers, url } = prepareRequest(options);\n  try {\n    const response = await get(url, { headers });\n    return await parseResponse(response);\n  } catch (error) {\n    if (error instanceof MongoNetworkTimeoutError) {\n      throw new MongoCryptAzureKMSRequestError(`[Azure KMS] ${error.message}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * @internal\n *\n * @throws Will reject with a `MongoCryptError` if the http request fails or the http response is malformed.\n */\nexport async function loadAzureCredentials(kmsProviders: KMSProviders): Promise<KMSProviders> {\n  const azure = await tokenCache.getToken();\n  return { ...kmsProviders, azure };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}