{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoDBAWS = void 0;\nconst BSON = require(\"../../bson\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\nconst auth_provider_1 = require(\"./auth_provider\");\nconst aws_temporary_credentials_1 = require(\"./aws_temporary_credentials\");\nconst mongo_credentials_1 = require(\"./mongo_credentials\");\nconst providers_1 = require(\"./providers\");\nconst ASCII_N = 110;\nconst bsonOptions = {\n  useBigInt64: false,\n  promoteLongs: true,\n  promoteValues: true,\n  promoteBuffers: false,\n  bsonRegExp: false\n};\nclass MongoDBAWS extends auth_provider_1.AuthProvider {\n  constructor() {\n    super();\n    this.credentialFetcher = aws_temporary_credentials_1.AWSTemporaryCredentialProvider.isAWSSDKInstalled ? new aws_temporary_credentials_1.AWSSDKCredentialProvider() : new aws_temporary_credentials_1.LegacyAWSTemporaryCredentialProvider();\n  }\n  async auth(authContext) {\n    const {\n      connection\n    } = authContext;\n    if (!authContext.credentials) {\n      throw new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.');\n    }\n    if ('kModuleError' in deps_1.aws4) {\n      throw deps_1.aws4['kModuleError'];\n    }\n    const {\n      sign\n    } = deps_1.aws4;\n    if ((0, utils_1.maxWireVersion)(connection) < 9) {\n      throw new error_1.MongoCompatibilityError('MONGODB-AWS authentication requires MongoDB version 4.4 or later');\n    }\n    if (!authContext.credentials.username) {\n      authContext.credentials = await makeTempCredentials(authContext.credentials, this.credentialFetcher);\n    }\n    const {\n      credentials\n    } = authContext;\n    const accessKeyId = credentials.username;\n    const secretAccessKey = credentials.password;\n    // Allow the user to specify an AWS session token for authentication with temporary credentials.\n    const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;\n    // If all three defined, include sessionToken, else include username and pass, else no credentials\n    const awsCredentials = accessKeyId && secretAccessKey && sessionToken ? {\n      accessKeyId,\n      secretAccessKey,\n      sessionToken\n    } : accessKeyId && secretAccessKey ? {\n      accessKeyId,\n      secretAccessKey\n    } : undefined;\n    const db = credentials.source;\n    const nonce = await (0, utils_1.randomBytes)(32);\n    // All messages between MongoDB clients and servers are sent as BSON objects\n    // in the payload field of saslStart and saslContinue.\n    const saslStart = {\n      saslStart: 1,\n      mechanism: 'MONGODB-AWS',\n      payload: BSON.serialize({\n        r: nonce,\n        p: ASCII_N\n      }, bsonOptions)\n    };\n    const saslStartResponse = await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslStart, undefined);\n    const serverResponse = BSON.deserialize(saslStartResponse.payload.buffer, bsonOptions);\n    const host = serverResponse.h;\n    const serverNonce = serverResponse.s.buffer;\n    if (serverNonce.length !== 64) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`);\n    }\n    if (!utils_1.ByteUtils.equals(serverNonce.subarray(0, nonce.byteLength), nonce)) {\n      // throw because the serverNonce's leading 32 bytes must equal the client nonce's 32 bytes\n      // https://github.com/mongodb/specifications/blob/875446db44aade414011731840831f38a6c668df/source/auth/auth.rst#id11\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('Server nonce does not begin with client nonce');\n    }\n    if (host.length < 1 || host.length > 255 || host.indexOf('..') !== -1) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError(`Server returned an invalid host: \"${host}\"`);\n    }\n    const body = 'Action=GetCallerIdentity&Version=2011-06-15';\n    const options = sign({\n      method: 'POST',\n      host,\n      region: deriveRegion(serverResponse.h),\n      service: 'sts',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n        'Content-Length': body.length,\n        'X-MongoDB-Server-Nonce': utils_1.ByteUtils.toBase64(serverNonce),\n        'X-MongoDB-GS2-CB-Flag': 'n'\n      },\n      path: '/',\n      body\n    }, awsCredentials);\n    const payload = {\n      a: options.headers.Authorization,\n      d: options.headers['X-Amz-Date']\n    };\n    if (sessionToken) {\n      payload.t = sessionToken;\n    }\n    const saslContinue = {\n      saslContinue: 1,\n      conversationId: 1,\n      payload: BSON.serialize(payload, bsonOptions)\n    };\n    await connection.command((0, utils_1.ns)(`${db}.$cmd`), saslContinue, undefined);\n  }\n}\nexports.MongoDBAWS = MongoDBAWS;\nasync function makeTempCredentials(credentials, awsCredentialFetcher) {\n  function makeMongoCredentialsFromAWSTemp(creds) {\n    // The AWS session token (creds.Token) may or may not be set.\n    if (!creds.AccessKeyId || !creds.SecretAccessKey) {\n      throw new error_1.MongoMissingCredentialsError('Could not obtain temporary MONGODB-AWS credentials');\n    }\n    return new mongo_credentials_1.MongoCredentials({\n      username: creds.AccessKeyId,\n      password: creds.SecretAccessKey,\n      source: credentials.source,\n      mechanism: providers_1.AuthMechanism.MONGODB_AWS,\n      mechanismProperties: {\n        AWS_SESSION_TOKEN: creds.Token\n      }\n    });\n  }\n  const temporaryCredentials = await awsCredentialFetcher.getCredentials();\n  return makeMongoCredentialsFromAWSTemp(temporaryCredentials);\n}\nfunction deriveRegion(host) {\n  const parts = host.split('.');\n  if (parts.length === 1 || parts[1] === 'amazonaws') {\n    return 'us-east-1';\n  }\n  return parts[1];\n}","map":{"version":3,"mappings":"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","names":["ASCII_N","bsonOptions","useBigInt64","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","MongoDBAWS","auth_provider_1","constructor","credentialFetcher","aws_temporary_credentials_1","isAWSSDKInstalled","auth","authContext","connection","credentials","error_1","deps_1","sign","username","makeTempCredentials","accessKeyId","secretAccessKey","password","sessionToken","mechanismProperties","AWS_SESSION_TOKEN","awsCredentials","undefined","db","source","nonce","saslStart","mechanism","payload","BSON","serialize","r","p","saslStartResponse","command","serverResponse","deserialize","buffer","host","h","serverNonce","s","length","utils_1","equals","subarray","byteLength","indexOf","body","options","method","region","deriveRegion","service","headers","toBase64","path","a","Authorization","d","t","saslContinue","conversationId","exports","awsCredentialFetcher","makeMongoCredentialsFromAWSTemp","creds","AccessKeyId","SecretAccessKey","mongo_credentials_1","providers_1","MONGODB_AWS","Token","temporaryCredentials","getCredentials","parts","split"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/cmap/auth/mongodb_aws.ts"],"sourcesContent":["import type { Binary, BSONSerializeOptions } from '../../bson';\nimport * as BSON from '../../bson';\nimport { aws4 } from '../../deps';\nimport {\n  MongoCompatibilityError,\n  MongoMissingCredentialsError,\n  MongoRuntimeError\n} from '../../error';\nimport { ByteUtils, maxWireVersion, ns, randomBytes } from '../../utils';\nimport { type AuthContext, AuthProvider } from './auth_provider';\nimport {\n  AWSSDKCredentialProvider,\n  type AWSTempCredentials,\n  AWSTemporaryCredentialProvider,\n  LegacyAWSTemporaryCredentialProvider\n} from './aws_temporary_credentials';\nimport { MongoCredentials } from './mongo_credentials';\nimport { AuthMechanism } from './providers';\n\nconst ASCII_N = 110;\nconst bsonOptions: BSONSerializeOptions = {\n  useBigInt64: false,\n  promoteLongs: true,\n  promoteValues: true,\n  promoteBuffers: false,\n  bsonRegExp: false\n};\n\ninterface AWSSaslContinuePayload {\n  a: string;\n  d: string;\n  t?: string;\n}\n\nexport class MongoDBAWS extends AuthProvider {\n  private credentialFetcher: AWSTemporaryCredentialProvider;\n  constructor() {\n    super();\n\n    this.credentialFetcher = AWSTemporaryCredentialProvider.isAWSSDKInstalled\n      ? new AWSSDKCredentialProvider()\n      : new LegacyAWSTemporaryCredentialProvider();\n  }\n\n  override async auth(authContext: AuthContext): Promise<void> {\n    const { connection } = authContext;\n    if (!authContext.credentials) {\n      throw new MongoMissingCredentialsError('AuthContext must provide credentials.');\n    }\n\n    if ('kModuleError' in aws4) {\n      throw aws4['kModuleError'];\n    }\n    const { sign } = aws4;\n\n    if (maxWireVersion(connection) < 9) {\n      throw new MongoCompatibilityError(\n        'MONGODB-AWS authentication requires MongoDB version 4.4 or later'\n      );\n    }\n\n    if (!authContext.credentials.username) {\n      authContext.credentials = await makeTempCredentials(\n        authContext.credentials,\n        this.credentialFetcher\n      );\n    }\n\n    const { credentials } = authContext;\n\n    const accessKeyId = credentials.username;\n    const secretAccessKey = credentials.password;\n    // Allow the user to specify an AWS session token for authentication with temporary credentials.\n    const sessionToken = credentials.mechanismProperties.AWS_SESSION_TOKEN;\n\n    // If all three defined, include sessionToken, else include username and pass, else no credentials\n    const awsCredentials =\n      accessKeyId && secretAccessKey && sessionToken\n        ? { accessKeyId, secretAccessKey, sessionToken }\n        : accessKeyId && secretAccessKey\n          ? { accessKeyId, secretAccessKey }\n          : undefined;\n\n    const db = credentials.source;\n    const nonce = await randomBytes(32);\n\n    // All messages between MongoDB clients and servers are sent as BSON objects\n    // in the payload field of saslStart and saslContinue.\n    const saslStart = {\n      saslStart: 1,\n      mechanism: 'MONGODB-AWS',\n      payload: BSON.serialize({ r: nonce, p: ASCII_N }, bsonOptions)\n    };\n\n    const saslStartResponse = await connection.command(ns(`${db}.$cmd`), saslStart, undefined);\n\n    const serverResponse = BSON.deserialize(saslStartResponse.payload.buffer, bsonOptions) as {\n      s: Binary;\n      h: string;\n    };\n    const host = serverResponse.h;\n    const serverNonce = serverResponse.s.buffer;\n    if (serverNonce.length !== 64) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError(`Invalid server nonce length ${serverNonce.length}, expected 64`);\n    }\n\n    if (!ByteUtils.equals(serverNonce.subarray(0, nonce.byteLength), nonce)) {\n      // throw because the serverNonce's leading 32 bytes must equal the client nonce's 32 bytes\n      // https://github.com/mongodb/specifications/blob/875446db44aade414011731840831f38a6c668df/source/auth/auth.rst#id11\n\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError('Server nonce does not begin with client nonce');\n    }\n\n    if (host.length < 1 || host.length > 255 || host.indexOf('..') !== -1) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError(`Server returned an invalid host: \"${host}\"`);\n    }\n\n    const body = 'Action=GetCallerIdentity&Version=2011-06-15';\n    const options = sign(\n      {\n        method: 'POST',\n        host,\n        region: deriveRegion(serverResponse.h),\n        service: 'sts',\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded',\n          'Content-Length': body.length,\n          'X-MongoDB-Server-Nonce': ByteUtils.toBase64(serverNonce),\n          'X-MongoDB-GS2-CB-Flag': 'n'\n        },\n        path: '/',\n        body\n      },\n      awsCredentials\n    );\n\n    const payload: AWSSaslContinuePayload = {\n      a: options.headers.Authorization,\n      d: options.headers['X-Amz-Date']\n    };\n\n    if (sessionToken) {\n      payload.t = sessionToken;\n    }\n\n    const saslContinue = {\n      saslContinue: 1,\n      conversationId: 1,\n      payload: BSON.serialize(payload, bsonOptions)\n    };\n\n    await connection.command(ns(`${db}.$cmd`), saslContinue, undefined);\n  }\n}\n\nasync function makeTempCredentials(\n  credentials: MongoCredentials,\n  awsCredentialFetcher: AWSTemporaryCredentialProvider\n): Promise<MongoCredentials> {\n  function makeMongoCredentialsFromAWSTemp(creds: AWSTempCredentials) {\n    // The AWS session token (creds.Token) may or may not be set.\n    if (!creds.AccessKeyId || !creds.SecretAccessKey) {\n      throw new MongoMissingCredentialsError('Could not obtain temporary MONGODB-AWS credentials');\n    }\n\n    return new MongoCredentials({\n      username: creds.AccessKeyId,\n      password: creds.SecretAccessKey,\n      source: credentials.source,\n      mechanism: AuthMechanism.MONGODB_AWS,\n      mechanismProperties: {\n        AWS_SESSION_TOKEN: creds.Token\n      }\n    });\n  }\n  const temporaryCredentials = await awsCredentialFetcher.getCredentials();\n\n  return makeMongoCredentialsFromAWSTemp(temporaryCredentials);\n}\n\nfunction deriveRegion(host: string) {\n  const parts = host.split('.');\n  if (parts.length === 1 || parts[1] === 'amazonaws') {\n    return 'us-east-1';\n  }\n\n  return parts[1];\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}