{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildReplaceOneOperation = exports.buildUpdateManyOperation = exports.buildUpdateOneOperation = exports.buildDeleteManyOperation = exports.buildDeleteOneOperation = exports.buildInsertOneOperation = exports.ClientBulkWriteCommandBuilder = void 0;\nexports.buildOperation = buildOperation;\nconst bson_1 = require(\"../../bson\");\nconst commands_1 = require(\"../../cmap/commands\");\nconst error_1 = require(\"../../error\");\nconst utils_1 = require(\"../../utils\");\n/**\n * The bytes overhead for the extra fields added post command generation.\n */\nconst MESSAGE_OVERHEAD_BYTES = 1000;\n/** @internal */\nclass ClientBulkWriteCommandBuilder {\n  /**\n   * Create the command builder.\n   * @param models - The client write models.\n   */\n  constructor(models, options, pkFactory) {\n    this.models = models;\n    this.options = options;\n    this.pkFactory = pkFactory ?? utils_1.DEFAULT_PK_FACTORY;\n    this.currentModelIndex = 0;\n    this.previousModelIndex = 0;\n    this.lastOperations = [];\n    this.isBatchRetryable = true;\n  }\n  /**\n   * Gets the errorsOnly value for the command, which is the inverse of the\n   * user provided verboseResults option. Defaults to true.\n   */\n  get errorsOnly() {\n    if ('verboseResults' in this.options) {\n      return !this.options.verboseResults;\n    }\n    return true;\n  }\n  /**\n   * Determines if there is another batch to process.\n   * @returns True if not all batches have been built.\n   */\n  hasNextBatch() {\n    return this.currentModelIndex < this.models.length;\n  }\n  /**\n   * When we need to retry a command we need to set the current\n   * model index back to its previous value.\n   */\n  resetBatch() {\n    this.currentModelIndex = this.previousModelIndex;\n    return true;\n  }\n  /**\n   * Build a single batch of a client bulk write command.\n   * @param maxMessageSizeBytes - The max message size in bytes.\n   * @param maxWriteBatchSize - The max write batch size.\n   * @returns The client bulk write command.\n   */\n  buildBatch(maxMessageSizeBytes, maxWriteBatchSize, maxBsonObjectSize) {\n    // We start by assuming the batch has no multi-updates, so it is retryable\n    // until we find them.\n    this.isBatchRetryable = true;\n    let commandLength = 0;\n    let currentNamespaceIndex = 0;\n    const command = this.baseCommand();\n    const namespaces = new Map();\n    // In the case of retries we need to mark where we started this batch.\n    this.previousModelIndex = this.currentModelIndex;\n    while (this.currentModelIndex < this.models.length) {\n      const model = this.models[this.currentModelIndex];\n      const ns = model.namespace;\n      const nsIndex = namespaces.get(ns);\n      // Multi updates are not retryable.\n      if (model.name === 'deleteMany' || model.name === 'updateMany') {\n        this.isBatchRetryable = false;\n      }\n      if (nsIndex != null) {\n        // Build the operation and serialize it to get the bytes buffer.\n        const operation = buildOperation(model, nsIndex, this.pkFactory);\n        let operationBuffer;\n        try {\n          operationBuffer = bson_1.BSON.serialize(operation);\n        } catch (cause) {\n          throw new error_1.MongoInvalidArgumentError(`Could not serialize operation to BSON`, {\n            cause\n          });\n        }\n        validateBufferSize('ops', operationBuffer, maxBsonObjectSize);\n        // Check if the operation buffer can fit in the command. If it can,\n        // then add the operation to the document sequence and increment the\n        // current length as long as the ops don't exceed the maxWriteBatchSize.\n        if (commandLength + operationBuffer.length < maxMessageSizeBytes && command.ops.documents.length < maxWriteBatchSize) {\n          // Pushing to the ops document sequence returns the total byte length of the document sequence.\n          commandLength = MESSAGE_OVERHEAD_BYTES + command.ops.push(operation, operationBuffer);\n          // Increment the builder's current model index.\n          this.currentModelIndex++;\n        } else {\n          // The operation cannot fit in the current command and will need to\n          // go in the next batch. Exit the loop.\n          break;\n        }\n      } else {\n        // The namespace is not already in the nsInfo so we will set it in the map, and\n        // construct our nsInfo and ops documents and buffers.\n        namespaces.set(ns, currentNamespaceIndex);\n        const nsInfo = {\n          ns: ns\n        };\n        const operation = buildOperation(model, currentNamespaceIndex, this.pkFactory);\n        let nsInfoBuffer;\n        let operationBuffer;\n        try {\n          nsInfoBuffer = bson_1.BSON.serialize(nsInfo);\n          operationBuffer = bson_1.BSON.serialize(operation);\n        } catch (cause) {\n          throw new error_1.MongoInvalidArgumentError(`Could not serialize ns info to BSON`, {\n            cause\n          });\n        }\n        validateBufferSize('nsInfo', nsInfoBuffer, maxBsonObjectSize);\n        validateBufferSize('ops', operationBuffer, maxBsonObjectSize);\n        // Check if the operation and nsInfo buffers can fit in the command. If they\n        // can, then add the operation and nsInfo to their respective document\n        // sequences and increment the current length as long as the ops don't exceed\n        // the maxWriteBatchSize.\n        if (commandLength + nsInfoBuffer.length + operationBuffer.length < maxMessageSizeBytes && command.ops.documents.length < maxWriteBatchSize) {\n          // Pushing to the ops document sequence returns the total byte length of the document sequence.\n          commandLength = MESSAGE_OVERHEAD_BYTES + command.nsInfo.push(nsInfo, nsInfoBuffer) + command.ops.push(operation, operationBuffer);\n          // We've added a new namespace, increment the namespace index.\n          currentNamespaceIndex++;\n          // Increment the builder's current model index.\n          this.currentModelIndex++;\n        } else {\n          // The operation cannot fit in the current command and will need to\n          // go in the next batch. Exit the loop.\n          break;\n        }\n      }\n    }\n    // Set the last operations and return the command.\n    this.lastOperations = command.ops.documents;\n    return command;\n  }\n  baseCommand() {\n    const command = {\n      bulkWrite: 1,\n      errorsOnly: this.errorsOnly,\n      ordered: this.options.ordered ?? true,\n      ops: new commands_1.DocumentSequence('ops'),\n      nsInfo: new commands_1.DocumentSequence('nsInfo')\n    };\n    // Add bypassDocumentValidation if it was present in the options.\n    if (this.options.bypassDocumentValidation != null) {\n      command.bypassDocumentValidation = this.options.bypassDocumentValidation;\n    }\n    // Add let if it was present in the options.\n    if (this.options.let) {\n      command.let = this.options.let;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (this.options.comment !== undefined) {\n      command.comment = this.options.comment;\n    }\n    return command;\n  }\n}\nexports.ClientBulkWriteCommandBuilder = ClientBulkWriteCommandBuilder;\nfunction validateBufferSize(name, buffer, maxBsonObjectSize) {\n  if (buffer.length > maxBsonObjectSize) {\n    throw new error_1.MongoInvalidArgumentError(`Client bulk write operation ${name} of length ${buffer.length} exceeds the max bson object size of ${maxBsonObjectSize}`);\n  }\n}\n/**\n * Build the insert one operation.\n * @param model - The insert one model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nconst buildInsertOneOperation = (model, index, pkFactory) => {\n  const document = {\n    insert: index,\n    document: model.document\n  };\n  document.document._id = model.document._id ?? pkFactory.createPk();\n  return document;\n};\nexports.buildInsertOneOperation = buildInsertOneOperation;\n/**\n * Build the delete one operation.\n * @param model - The insert many model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nconst buildDeleteOneOperation = (model, index) => {\n  return createDeleteOperation(model, index, false);\n};\nexports.buildDeleteOneOperation = buildDeleteOneOperation;\n/**\n * Build the delete many operation.\n * @param model - The delete many model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nconst buildDeleteManyOperation = (model, index) => {\n  return createDeleteOperation(model, index, true);\n};\nexports.buildDeleteManyOperation = buildDeleteManyOperation;\n/**\n * Creates a delete operation based on the parameters.\n */\nfunction createDeleteOperation(model, index, multi) {\n  const document = {\n    delete: index,\n    multi: multi,\n    filter: model.filter\n  };\n  if (model.hint) {\n    document.hint = model.hint;\n  }\n  if (model.collation) {\n    document.collation = model.collation;\n  }\n  return document;\n}\n/**\n * Build the update one operation.\n * @param model - The update one model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nconst buildUpdateOneOperation = (model, index) => {\n  return createUpdateOperation(model, index, false);\n};\nexports.buildUpdateOneOperation = buildUpdateOneOperation;\n/**\n * Build the update many operation.\n * @param model - The update many model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nconst buildUpdateManyOperation = (model, index) => {\n  return createUpdateOperation(model, index, true);\n};\nexports.buildUpdateManyOperation = buildUpdateManyOperation;\n/**\n * Validate the update document.\n * @param update - The update document.\n */\nfunction validateUpdate(update) {\n  if (!(0, utils_1.hasAtomicOperators)(update)) {\n    throw new error_1.MongoAPIError('Client bulk write update models must only contain atomic modifiers (start with $) and must not be empty.');\n  }\n}\n/**\n * Creates a delete operation based on the parameters.\n */\nfunction createUpdateOperation(model, index, multi) {\n  // Update documents provided in UpdateOne and UpdateMany write models are\n  // required only to contain atomic modifiers (i.e. keys that start with \"$\").\n  // Drivers MUST throw an error if an update document is empty or if the\n  // document's first key does not start with \"$\".\n  validateUpdate(model.update);\n  const document = {\n    update: index,\n    multi: multi,\n    filter: model.filter,\n    updateMods: model.update\n  };\n  if (model.hint) {\n    document.hint = model.hint;\n  }\n  if (model.upsert) {\n    document.upsert = model.upsert;\n  }\n  if (model.arrayFilters) {\n    document.arrayFilters = model.arrayFilters;\n  }\n  if (model.collation) {\n    document.collation = model.collation;\n  }\n  return document;\n}\n/**\n * Build the replace one operation.\n * @param model - The replace one model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nconst buildReplaceOneOperation = (model, index) => {\n  if ((0, utils_1.hasAtomicOperators)(model.replacement)) {\n    throw new error_1.MongoAPIError('Client bulk write replace models must not contain atomic modifiers (start with $) and must not be empty.');\n  }\n  const document = {\n    update: index,\n    multi: false,\n    filter: model.filter,\n    updateMods: model.replacement\n  };\n  if (model.hint) {\n    document.hint = model.hint;\n  }\n  if (model.upsert) {\n    document.upsert = model.upsert;\n  }\n  if (model.collation) {\n    document.collation = model.collation;\n  }\n  return document;\n};\nexports.buildReplaceOneOperation = buildReplaceOneOperation;\n/** @internal */\nfunction buildOperation(model, index, pkFactory) {\n  switch (model.name) {\n    case 'insertOne':\n      return (0, exports.buildInsertOneOperation)(model, index, pkFactory);\n    case 'deleteOne':\n      return (0, exports.buildDeleteOneOperation)(model, index);\n    case 'deleteMany':\n      return (0, exports.buildDeleteManyOperation)(model, index);\n    case 'updateOne':\n      return (0, exports.buildUpdateOneOperation)(model, index);\n    case 'updateMany':\n      return (0, exports.buildUpdateManyOperation)(model, index);\n    case 'replaceOne':\n      return (0, exports.buildReplaceOneOperation)(model, index);\n  }\n}","map":{"version":3,"mappings":"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","names":["exports","MESSAGE_OVERHEAD_BYTES","ClientBulkWriteCommandBuilder","constructor","models","options","pkFactory","utils_1","currentModelIndex","previousModelIndex","lastOperations","isBatchRetryable","errorsOnly","verboseResults","hasNextBatch","length","resetBatch","buildBatch","maxMessageSizeBytes","maxWriteBatchSize","maxBsonObjectSize","commandLength","currentNamespaceIndex","command","baseCommand","namespaces","Map","model","ns","namespace","nsIndex","get","name","operation","buildOperation","operationBuffer","bson_1","serialize","cause","error_1","validateBufferSize","ops","documents","push","set","nsInfo","nsInfoBuffer","bulkWrite","ordered","commands_1","bypassDocumentValidation","let","comment","undefined","buffer","buildInsertOneOperation","index","document","insert","_id","createPk","buildDeleteOneOperation","createDeleteOperation","buildDeleteManyOperation","multi","delete","filter","hint","collation","buildUpdateOneOperation","createUpdateOperation","buildUpdateManyOperation","validateUpdate","update","updateMods","upsert","arrayFilters","buildReplaceOneOperation","replacement"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/operations/client_bulk_write/command_builder.ts"],"sourcesContent":["import { BSON, type Document } from '../../bson';\nimport { DocumentSequence } from '../../cmap/commands';\nimport { MongoAPIError, MongoInvalidArgumentError } from '../../error';\nimport { type PkFactory } from '../../mongo_client';\nimport type { Filter, OptionalId, UpdateFilter, WithoutId } from '../../mongo_types';\nimport { DEFAULT_PK_FACTORY, hasAtomicOperators } from '../../utils';\nimport { type CollationOptions } from '../command';\nimport { type Hint } from '../operation';\nimport type {\n  AnyClientBulkWriteModel,\n  ClientBulkWriteOptions,\n  ClientDeleteManyModel,\n  ClientDeleteOneModel,\n  ClientInsertOneModel,\n  ClientReplaceOneModel,\n  ClientUpdateManyModel,\n  ClientUpdateOneModel\n} from './common';\n\n/** @internal */\nexport interface ClientBulkWriteCommand {\n  bulkWrite: 1;\n  errorsOnly: boolean;\n  ordered: boolean;\n  ops: DocumentSequence;\n  nsInfo: DocumentSequence;\n  bypassDocumentValidation?: boolean;\n  let?: Document;\n  comment?: any;\n}\n\n/**\n * The bytes overhead for the extra fields added post command generation.\n */\nconst MESSAGE_OVERHEAD_BYTES = 1000;\n\n/** @internal */\nexport class ClientBulkWriteCommandBuilder {\n  models: ReadonlyArray<AnyClientBulkWriteModel<Document>>;\n  options: ClientBulkWriteOptions;\n  pkFactory: PkFactory;\n  /** The current index in the models array that is being processed. */\n  currentModelIndex: number;\n  /** The model index that the builder was on when it finished the previous batch. Used for resets when retrying. */\n  previousModelIndex: number;\n  /** The last array of operations that were created. Used by the results merger for indexing results. */\n  lastOperations: Document[];\n  /** Returns true if the current batch being created has no multi-updates. */\n  isBatchRetryable: boolean;\n\n  /**\n   * Create the command builder.\n   * @param models - The client write models.\n   */\n  constructor(\n    models: ReadonlyArray<AnyClientBulkWriteModel<Document>>,\n    options: ClientBulkWriteOptions,\n    pkFactory?: PkFactory\n  ) {\n    this.models = models;\n    this.options = options;\n    this.pkFactory = pkFactory ?? DEFAULT_PK_FACTORY;\n    this.currentModelIndex = 0;\n    this.previousModelIndex = 0;\n    this.lastOperations = [];\n    this.isBatchRetryable = true;\n  }\n\n  /**\n   * Gets the errorsOnly value for the command, which is the inverse of the\n   * user provided verboseResults option. Defaults to true.\n   */\n  get errorsOnly(): boolean {\n    if ('verboseResults' in this.options) {\n      return !this.options.verboseResults;\n    }\n    return true;\n  }\n\n  /**\n   * Determines if there is another batch to process.\n   * @returns True if not all batches have been built.\n   */\n  hasNextBatch(): boolean {\n    return this.currentModelIndex < this.models.length;\n  }\n\n  /**\n   * When we need to retry a command we need to set the current\n   * model index back to its previous value.\n   */\n  resetBatch(): boolean {\n    this.currentModelIndex = this.previousModelIndex;\n    return true;\n  }\n\n  /**\n   * Build a single batch of a client bulk write command.\n   * @param maxMessageSizeBytes - The max message size in bytes.\n   * @param maxWriteBatchSize - The max write batch size.\n   * @returns The client bulk write command.\n   */\n  buildBatch(\n    maxMessageSizeBytes: number,\n    maxWriteBatchSize: number,\n    maxBsonObjectSize: number\n  ): ClientBulkWriteCommand {\n    // We start by assuming the batch has no multi-updates, so it is retryable\n    // until we find them.\n    this.isBatchRetryable = true;\n    let commandLength = 0;\n    let currentNamespaceIndex = 0;\n    const command: ClientBulkWriteCommand = this.baseCommand();\n    const namespaces = new Map<string, number>();\n    // In the case of retries we need to mark where we started this batch.\n    this.previousModelIndex = this.currentModelIndex;\n\n    while (this.currentModelIndex < this.models.length) {\n      const model = this.models[this.currentModelIndex];\n      const ns = model.namespace;\n      const nsIndex = namespaces.get(ns);\n\n      // Multi updates are not retryable.\n      if (model.name === 'deleteMany' || model.name === 'updateMany') {\n        this.isBatchRetryable = false;\n      }\n\n      if (nsIndex != null) {\n        // Build the operation and serialize it to get the bytes buffer.\n        const operation = buildOperation(model, nsIndex, this.pkFactory);\n        let operationBuffer;\n        try {\n          operationBuffer = BSON.serialize(operation);\n        } catch (cause) {\n          throw new MongoInvalidArgumentError(`Could not serialize operation to BSON`, { cause });\n        }\n\n        validateBufferSize('ops', operationBuffer, maxBsonObjectSize);\n\n        // Check if the operation buffer can fit in the command. If it can,\n        // then add the operation to the document sequence and increment the\n        // current length as long as the ops don't exceed the maxWriteBatchSize.\n        if (\n          commandLength + operationBuffer.length < maxMessageSizeBytes &&\n          command.ops.documents.length < maxWriteBatchSize\n        ) {\n          // Pushing to the ops document sequence returns the total byte length of the document sequence.\n          commandLength = MESSAGE_OVERHEAD_BYTES + command.ops.push(operation, operationBuffer);\n          // Increment the builder's current model index.\n          this.currentModelIndex++;\n        } else {\n          // The operation cannot fit in the current command and will need to\n          // go in the next batch. Exit the loop.\n          break;\n        }\n      } else {\n        // The namespace is not already in the nsInfo so we will set it in the map, and\n        // construct our nsInfo and ops documents and buffers.\n        namespaces.set(ns, currentNamespaceIndex);\n        const nsInfo = { ns: ns };\n        const operation = buildOperation(model, currentNamespaceIndex, this.pkFactory);\n        let nsInfoBuffer;\n        let operationBuffer;\n        try {\n          nsInfoBuffer = BSON.serialize(nsInfo);\n          operationBuffer = BSON.serialize(operation);\n        } catch (cause) {\n          throw new MongoInvalidArgumentError(`Could not serialize ns info to BSON`, { cause });\n        }\n\n        validateBufferSize('nsInfo', nsInfoBuffer, maxBsonObjectSize);\n        validateBufferSize('ops', operationBuffer, maxBsonObjectSize);\n\n        // Check if the operation and nsInfo buffers can fit in the command. If they\n        // can, then add the operation and nsInfo to their respective document\n        // sequences and increment the current length as long as the ops don't exceed\n        // the maxWriteBatchSize.\n        if (\n          commandLength + nsInfoBuffer.length + operationBuffer.length < maxMessageSizeBytes &&\n          command.ops.documents.length < maxWriteBatchSize\n        ) {\n          // Pushing to the ops document sequence returns the total byte length of the document sequence.\n          commandLength =\n            MESSAGE_OVERHEAD_BYTES +\n            command.nsInfo.push(nsInfo, nsInfoBuffer) +\n            command.ops.push(operation, operationBuffer);\n          // We've added a new namespace, increment the namespace index.\n          currentNamespaceIndex++;\n          // Increment the builder's current model index.\n          this.currentModelIndex++;\n        } else {\n          // The operation cannot fit in the current command and will need to\n          // go in the next batch. Exit the loop.\n          break;\n        }\n      }\n    }\n    // Set the last operations and return the command.\n    this.lastOperations = command.ops.documents;\n    return command;\n  }\n\n  private baseCommand(): ClientBulkWriteCommand {\n    const command: ClientBulkWriteCommand = {\n      bulkWrite: 1,\n      errorsOnly: this.errorsOnly,\n      ordered: this.options.ordered ?? true,\n      ops: new DocumentSequence('ops'),\n      nsInfo: new DocumentSequence('nsInfo')\n    };\n    // Add bypassDocumentValidation if it was present in the options.\n    if (this.options.bypassDocumentValidation != null) {\n      command.bypassDocumentValidation = this.options.bypassDocumentValidation;\n    }\n    // Add let if it was present in the options.\n    if (this.options.let) {\n      command.let = this.options.let;\n    }\n\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (this.options.comment !== undefined) {\n      command.comment = this.options.comment;\n    }\n\n    return command;\n  }\n}\n\nfunction validateBufferSize(name: string, buffer: Uint8Array, maxBsonObjectSize: number) {\n  if (buffer.length > maxBsonObjectSize) {\n    throw new MongoInvalidArgumentError(\n      `Client bulk write operation ${name} of length ${buffer.length} exceeds the max bson object size of ${maxBsonObjectSize}`\n    );\n  }\n}\n\n/** @internal */\ninterface ClientInsertOperation {\n  insert: number;\n  document: OptionalId<Document>;\n}\n\n/**\n * Build the insert one operation.\n * @param model - The insert one model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nexport const buildInsertOneOperation = (\n  model: ClientInsertOneModel<Document>,\n  index: number,\n  pkFactory: PkFactory\n): ClientInsertOperation => {\n  const document: ClientInsertOperation = {\n    insert: index,\n    document: model.document\n  };\n  document.document._id = model.document._id ?? pkFactory.createPk();\n  return document;\n};\n\n/** @internal */\nexport interface ClientDeleteOperation {\n  delete: number;\n  multi: boolean;\n  filter: Filter<Document>;\n  hint?: Hint;\n  collation?: CollationOptions;\n}\n\n/**\n * Build the delete one operation.\n * @param model - The insert many model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nexport const buildDeleteOneOperation = (\n  model: ClientDeleteOneModel<Document>,\n  index: number\n): Document => {\n  return createDeleteOperation(model, index, false);\n};\n\n/**\n * Build the delete many operation.\n * @param model - The delete many model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nexport const buildDeleteManyOperation = (\n  model: ClientDeleteManyModel<Document>,\n  index: number\n): Document => {\n  return createDeleteOperation(model, index, true);\n};\n\n/**\n * Creates a delete operation based on the parameters.\n */\nfunction createDeleteOperation(\n  model: ClientDeleteOneModel<Document> | ClientDeleteManyModel<Document>,\n  index: number,\n  multi: boolean\n): ClientDeleteOperation {\n  const document: ClientDeleteOperation = {\n    delete: index,\n    multi: multi,\n    filter: model.filter\n  };\n  if (model.hint) {\n    document.hint = model.hint;\n  }\n  if (model.collation) {\n    document.collation = model.collation;\n  }\n  return document;\n}\n\n/** @internal */\nexport interface ClientUpdateOperation {\n  update: number;\n  multi: boolean;\n  filter: Filter<Document>;\n  updateMods: UpdateFilter<Document> | Document[];\n  hint?: Hint;\n  upsert?: boolean;\n  arrayFilters?: Document[];\n  collation?: CollationOptions;\n}\n\n/**\n * Build the update one operation.\n * @param model - The update one model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nexport const buildUpdateOneOperation = (\n  model: ClientUpdateOneModel<Document>,\n  index: number\n): ClientUpdateOperation => {\n  return createUpdateOperation(model, index, false);\n};\n\n/**\n * Build the update many operation.\n * @param model - The update many model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nexport const buildUpdateManyOperation = (\n  model: ClientUpdateManyModel<Document>,\n  index: number\n): ClientUpdateOperation => {\n  return createUpdateOperation(model, index, true);\n};\n\n/**\n * Validate the update document.\n * @param update - The update document.\n */\nfunction validateUpdate(update: Document) {\n  if (!hasAtomicOperators(update)) {\n    throw new MongoAPIError(\n      'Client bulk write update models must only contain atomic modifiers (start with $) and must not be empty.'\n    );\n  }\n}\n\n/**\n * Creates a delete operation based on the parameters.\n */\nfunction createUpdateOperation(\n  model: ClientUpdateOneModel<Document> | ClientUpdateManyModel<Document>,\n  index: number,\n  multi: boolean\n): ClientUpdateOperation {\n  // Update documents provided in UpdateOne and UpdateMany write models are\n  // required only to contain atomic modifiers (i.e. keys that start with \"$\").\n  // Drivers MUST throw an error if an update document is empty or if the\n  // document's first key does not start with \"$\".\n  validateUpdate(model.update);\n  const document: ClientUpdateOperation = {\n    update: index,\n    multi: multi,\n    filter: model.filter,\n    updateMods: model.update\n  };\n  if (model.hint) {\n    document.hint = model.hint;\n  }\n  if (model.upsert) {\n    document.upsert = model.upsert;\n  }\n  if (model.arrayFilters) {\n    document.arrayFilters = model.arrayFilters;\n  }\n  if (model.collation) {\n    document.collation = model.collation;\n  }\n  return document;\n}\n\n/** @internal */\nexport interface ClientReplaceOneOperation {\n  update: number;\n  multi: boolean;\n  filter: Filter<Document>;\n  updateMods: WithoutId<Document>;\n  hint?: Hint;\n  upsert?: boolean;\n  collation?: CollationOptions;\n}\n\n/**\n * Build the replace one operation.\n * @param model - The replace one model.\n * @param index - The namespace index.\n * @returns the operation.\n */\nexport const buildReplaceOneOperation = (\n  model: ClientReplaceOneModel<Document>,\n  index: number\n): ClientReplaceOneOperation => {\n  if (hasAtomicOperators(model.replacement)) {\n    throw new MongoAPIError(\n      'Client bulk write replace models must not contain atomic modifiers (start with $) and must not be empty.'\n    );\n  }\n\n  const document: ClientReplaceOneOperation = {\n    update: index,\n    multi: false,\n    filter: model.filter,\n    updateMods: model.replacement\n  };\n  if (model.hint) {\n    document.hint = model.hint;\n  }\n  if (model.upsert) {\n    document.upsert = model.upsert;\n  }\n  if (model.collation) {\n    document.collation = model.collation;\n  }\n  return document;\n};\n\n/** @internal */\nexport function buildOperation(\n  model: AnyClientBulkWriteModel<Document>,\n  index: number,\n  pkFactory: PkFactory\n): Document {\n  switch (model.name) {\n    case 'insertOne':\n      return buildInsertOneOperation(model, index, pkFactory);\n    case 'deleteOne':\n      return buildDeleteOneOperation(model, index);\n    case 'deleteMany':\n      return buildDeleteManyOperation(model, index);\n    case 'updateOne':\n      return buildUpdateOneOperation(model, index);\n    case 'updateMany':\n      return buildUpdateManyOperation(model, index);\n    case 'replaceOne':\n      return buildReplaceOneOperation(model, index);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}