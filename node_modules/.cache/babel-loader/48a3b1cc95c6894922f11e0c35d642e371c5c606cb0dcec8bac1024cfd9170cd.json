{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClientBulkWriteExecutor = void 0;\nconst client_bulk_write_cursor_1 = require(\"../../cursor/client_bulk_write_cursor\");\nconst error_1 = require(\"../../error\");\nconst write_concern_1 = require(\"../../write_concern\");\nconst execute_operation_1 = require(\"../execute_operation\");\nconst client_bulk_write_1 = require(\"./client_bulk_write\");\nconst command_builder_1 = require(\"./command_builder\");\nconst results_merger_1 = require(\"./results_merger\");\n/**\n * Responsible for executing a client bulk write.\n * @internal\n */\nclass ClientBulkWriteExecutor {\n  /**\n   * Instantiate the executor.\n   * @param client - The mongo client.\n   * @param operations - The user supplied bulk write models.\n   * @param options - The bulk write options.\n   */\n  constructor(client, operations, options) {\n    if (operations.length === 0) {\n      throw new error_1.MongoClientBulkWriteExecutionError('No client bulk write models were provided.');\n    }\n    this.client = client;\n    this.operations = operations;\n    this.options = {\n      ordered: true,\n      bypassDocumentValidation: false,\n      verboseResults: false,\n      ...options\n    };\n    // If no write concern was provided, we inherit one from the client.\n    if (!this.options.writeConcern) {\n      this.options.writeConcern = write_concern_1.WriteConcern.fromOptions(this.client.options);\n    }\n    if (this.options.writeConcern?.w === 0) {\n      if (this.options.verboseResults) {\n        throw new error_1.MongoInvalidArgumentError('Cannot request unacknowledged write concern and verbose results');\n      }\n      if (this.options.ordered) {\n        throw new error_1.MongoInvalidArgumentError('Cannot request unacknowledged write concern and ordered writes');\n      }\n    }\n  }\n  /**\n   * Execute the client bulk write. Will split commands into batches and exhaust the cursors\n   * for each, then merge the results into one.\n   * @returns The result.\n   */\n  async execute() {\n    // The command builder will take the user provided models and potential split the batch\n    // into multiple commands due to size.\n    const pkFactory = this.client.s.options.pkFactory;\n    const commandBuilder = new command_builder_1.ClientBulkWriteCommandBuilder(this.operations, this.options, pkFactory);\n    // Unacknowledged writes need to execute all batches and return { ok: 1}\n    if (this.options.writeConcern?.w === 0) {\n      while (commandBuilder.hasNextBatch()) {\n        const operation = new client_bulk_write_1.ClientBulkWriteOperation(commandBuilder, this.options);\n        await (0, execute_operation_1.executeOperation)(this.client, operation);\n      }\n      return results_merger_1.ClientBulkWriteResultsMerger.unacknowledged();\n    } else {\n      const resultsMerger = new results_merger_1.ClientBulkWriteResultsMerger(this.options);\n      // For each command will will create and exhaust a cursor for the results.\n      while (commandBuilder.hasNextBatch()) {\n        const cursor = new client_bulk_write_cursor_1.ClientBulkWriteCursor(this.client, commandBuilder, this.options);\n        try {\n          await resultsMerger.merge(cursor);\n        } catch (error) {\n          // Write concern errors are recorded in the writeConcernErrors field on MongoClientBulkWriteError.\n          // When a write concern error is encountered, it should not terminate execution of the bulk write\n          // for either ordered or unordered bulk writes. However, drivers MUST throw an exception at the end\n          // of execution if any write concern errors were observed.\n          if (error instanceof error_1.MongoServerError && !(error instanceof error_1.MongoClientBulkWriteError)) {\n            // Server side errors need to be wrapped inside a MongoClientBulkWriteError, where the root\n            // cause is the error property and a partial result is to be included.\n            const bulkWriteError = new error_1.MongoClientBulkWriteError({\n              message: 'Mongo client bulk write encountered an error during execution'\n            });\n            bulkWriteError.cause = error;\n            bulkWriteError.partialResult = resultsMerger.bulkWriteResult;\n            throw bulkWriteError;\n          } else {\n            // Client side errors are just thrown.\n            throw error;\n          }\n        }\n      }\n      // If we have write concern errors or unordered write errors at the end we throw.\n      if (resultsMerger.writeConcernErrors.length > 0 || resultsMerger.writeErrors.size > 0) {\n        const error = new error_1.MongoClientBulkWriteError({\n          message: 'Mongo client bulk write encountered errors during execution.'\n        });\n        error.writeConcernErrors = resultsMerger.writeConcernErrors;\n        error.writeErrors = resultsMerger.writeErrors;\n        error.partialResult = resultsMerger.bulkWriteResult;\n        throw error;\n      }\n      return resultsMerger.bulkWriteResult;\n    }\n  }\n}\nexports.ClientBulkWriteExecutor = ClientBulkWriteExecutor;","map":{"version":3,"mappings":";;;;;;AACA;AACA;AAOA;AACA;AACA;AACA;AAMA;AAEA;;;;AAIA,MAAaA,uBAAuB;EAKlC;;;;;;EAMAC,YACEC,MAAmB,EACnBC,UAA4D,EAC5DC,OAAgC;IAEhC,IAAID,UAAU,CAACE,MAAM,KAAK,CAAC,EAAE;MAC3B,MAAM,IAAIC,0CAAkC,CAAC,4CAA4C,CAAC;IAC5F;IAEA,IAAI,CAACJ,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,OAAO,GAAG;MACbG,OAAO,EAAE,IAAI;MACbC,wBAAwB,EAAE,KAAK;MAC/BC,cAAc,EAAE,KAAK;MACrB,GAAGL;KACJ;IAED;IACA,IAAI,CAAC,IAAI,CAACA,OAAO,CAACM,YAAY,EAAE;MAC9B,IAAI,CAACN,OAAO,CAACM,YAAY,GAAGC,4BAAY,CAACC,WAAW,CAAC,IAAI,CAACV,MAAM,CAACE,OAAO,CAAC;IAC3E;IAEA,IAAI,IAAI,CAACA,OAAO,CAACM,YAAY,EAAEG,CAAC,KAAK,CAAC,EAAE;MACtC,IAAI,IAAI,CAACT,OAAO,CAACK,cAAc,EAAE;QAC/B,MAAM,IAAIH,iCAAyB,CACjC,iEAAiE,CAClE;MACH;MAEA,IAAI,IAAI,CAACF,OAAO,CAACG,OAAO,EAAE;QACxB,MAAM,IAAID,iCAAyB,CACjC,gEAAgE,CACjE;MACH;IACF;EACF;EAEA;;;;;EAKA,MAAMQ,OAAO;IACX;IACA;IACA,MAAMC,SAAS,GAAG,IAAI,CAACb,MAAM,CAACc,CAAC,CAACZ,OAAO,CAACW,SAAS;IACjD,MAAME,cAAc,GAAG,IAAIC,+CAA6B,CACtD,IAAI,CAACf,UAAU,EACf,IAAI,CAACC,OAAO,EACZW,SAAS,CACV;IACD;IACA,IAAI,IAAI,CAACX,OAAO,CAACM,YAAY,EAAEG,CAAC,KAAK,CAAC,EAAE;MACtC,OAAOI,cAAc,CAACE,YAAY,EAAE,EAAE;QACpC,MAAMC,SAAS,GAAG,IAAIC,4CAAwB,CAACJ,cAAc,EAAE,IAAI,CAACb,OAAO,CAAC;QAC5E,MAAM,wCAAgB,EAAC,IAAI,CAACF,MAAM,EAAEkB,SAAS,CAAC;MAChD;MACA,OAAOE,6CAA4B,CAACC,cAAc,EAAE;IACtD,CAAC,MAAM;MACL,MAAMC,aAAa,GAAG,IAAIF,6CAA4B,CAAC,IAAI,CAAClB,OAAO,CAAC;MACpE;MACA,OAAOa,cAAc,CAACE,YAAY,EAAE,EAAE;QACpC,MAAMM,MAAM,GAAG,IAAIC,gDAAqB,CAAC,IAAI,CAACxB,MAAM,EAAEe,cAAc,EAAE,IAAI,CAACb,OAAO,CAAC;QACnF,IAAI;UACF,MAAMoB,aAAa,CAACG,KAAK,CAACF,MAAM,CAAC;QACnC,CAAC,CAAC,OAAOG,KAAK,EAAE;UACd;UACA;UACA;UACA;UACA,IAAIA,KAAK,YAAYtB,wBAAgB,IAAI,EAAEsB,KAAK,YAAYtB,iCAAyB,CAAC,EAAE;YACtF;YACA;YACA,MAAMuB,cAAc,GAAG,IAAIvB,iCAAyB,CAAC;cACnDwB,OAAO,EAAE;aACV,CAAC;YACFD,cAAc,CAACE,KAAK,GAAGH,KAAK;YAC5BC,cAAc,CAACG,aAAa,GAAGR,aAAa,CAACS,eAAe;YAC5D,MAAMJ,cAAc;UACtB,CAAC,MAAM;YACL;YACA,MAAMD,KAAK;UACb;QACF;MACF;MAEA;MACA,IAAIJ,aAAa,CAACU,kBAAkB,CAAC7B,MAAM,GAAG,CAAC,IAAImB,aAAa,CAACW,WAAW,CAACC,IAAI,GAAG,CAAC,EAAE;QACrF,MAAMR,KAAK,GAAG,IAAItB,iCAAyB,CAAC;UAC1CwB,OAAO,EAAE;SACV,CAAC;QACFF,KAAK,CAACM,kBAAkB,GAAGV,aAAa,CAACU,kBAAkB;QAC3DN,KAAK,CAACO,WAAW,GAAGX,aAAa,CAACW,WAAW;QAC7CP,KAAK,CAACI,aAAa,GAAGR,aAAa,CAACS,eAAe;QACnD,MAAML,KAAK;MACb;MAEA,OAAOJ,aAAa,CAACS,eAAe;IACtC;EACF;;AA/GFI","names":["ClientBulkWriteExecutor","constructor","client","operations","options","length","error_1","ordered","bypassDocumentValidation","verboseResults","writeConcern","write_concern_1","fromOptions","w","execute","pkFactory","s","commandBuilder","command_builder_1","hasNextBatch","operation","client_bulk_write_1","results_merger_1","unacknowledged","resultsMerger","cursor","client_bulk_write_cursor_1","merge","error","bulkWriteError","message","cause","partialResult","bulkWriteResult","writeConcernErrors","writeErrors","size","exports"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/operations/client_bulk_write/executor.ts"],"sourcesContent":["import { type Document } from '../../bson';\nimport { ClientBulkWriteCursor } from '../../cursor/client_bulk_write_cursor';\nimport {\n  MongoClientBulkWriteError,\n  MongoClientBulkWriteExecutionError,\n  MongoInvalidArgumentError,\n  MongoServerError\n} from '../../error';\nimport { type MongoClient } from '../../mongo_client';\nimport { WriteConcern } from '../../write_concern';\nimport { executeOperation } from '../execute_operation';\nimport { ClientBulkWriteOperation } from './client_bulk_write';\nimport { ClientBulkWriteCommandBuilder } from './command_builder';\nimport {\n  type AnyClientBulkWriteModel,\n  type ClientBulkWriteOptions,\n  type ClientBulkWriteResult\n} from './common';\nimport { ClientBulkWriteResultsMerger } from './results_merger';\n\n/**\n * Responsible for executing a client bulk write.\n * @internal\n */\nexport class ClientBulkWriteExecutor {\n  private readonly client: MongoClient;\n  private readonly options: ClientBulkWriteOptions;\n  private readonly operations: ReadonlyArray<AnyClientBulkWriteModel<Document>>;\n\n  /**\n   * Instantiate the executor.\n   * @param client - The mongo client.\n   * @param operations - The user supplied bulk write models.\n   * @param options - The bulk write options.\n   */\n  constructor(\n    client: MongoClient,\n    operations: ReadonlyArray<AnyClientBulkWriteModel<Document>>,\n    options?: ClientBulkWriteOptions\n  ) {\n    if (operations.length === 0) {\n      throw new MongoClientBulkWriteExecutionError('No client bulk write models were provided.');\n    }\n\n    this.client = client;\n    this.operations = operations;\n    this.options = {\n      ordered: true,\n      bypassDocumentValidation: false,\n      verboseResults: false,\n      ...options\n    };\n\n    // If no write concern was provided, we inherit one from the client.\n    if (!this.options.writeConcern) {\n      this.options.writeConcern = WriteConcern.fromOptions(this.client.options);\n    }\n\n    if (this.options.writeConcern?.w === 0) {\n      if (this.options.verboseResults) {\n        throw new MongoInvalidArgumentError(\n          'Cannot request unacknowledged write concern and verbose results'\n        );\n      }\n\n      if (this.options.ordered) {\n        throw new MongoInvalidArgumentError(\n          'Cannot request unacknowledged write concern and ordered writes'\n        );\n      }\n    }\n  }\n\n  /**\n   * Execute the client bulk write. Will split commands into batches and exhaust the cursors\n   * for each, then merge the results into one.\n   * @returns The result.\n   */\n  async execute(): Promise<ClientBulkWriteResult> {\n    // The command builder will take the user provided models and potential split the batch\n    // into multiple commands due to size.\n    const pkFactory = this.client.s.options.pkFactory;\n    const commandBuilder = new ClientBulkWriteCommandBuilder(\n      this.operations,\n      this.options,\n      pkFactory\n    );\n    // Unacknowledged writes need to execute all batches and return { ok: 1}\n    if (this.options.writeConcern?.w === 0) {\n      while (commandBuilder.hasNextBatch()) {\n        const operation = new ClientBulkWriteOperation(commandBuilder, this.options);\n        await executeOperation(this.client, operation);\n      }\n      return ClientBulkWriteResultsMerger.unacknowledged();\n    } else {\n      const resultsMerger = new ClientBulkWriteResultsMerger(this.options);\n      // For each command will will create and exhaust a cursor for the results.\n      while (commandBuilder.hasNextBatch()) {\n        const cursor = new ClientBulkWriteCursor(this.client, commandBuilder, this.options);\n        try {\n          await resultsMerger.merge(cursor);\n        } catch (error) {\n          // Write concern errors are recorded in the writeConcernErrors field on MongoClientBulkWriteError.\n          // When a write concern error is encountered, it should not terminate execution of the bulk write\n          // for either ordered or unordered bulk writes. However, drivers MUST throw an exception at the end\n          // of execution if any write concern errors were observed.\n          if (error instanceof MongoServerError && !(error instanceof MongoClientBulkWriteError)) {\n            // Server side errors need to be wrapped inside a MongoClientBulkWriteError, where the root\n            // cause is the error property and a partial result is to be included.\n            const bulkWriteError = new MongoClientBulkWriteError({\n              message: 'Mongo client bulk write encountered an error during execution'\n            });\n            bulkWriteError.cause = error;\n            bulkWriteError.partialResult = resultsMerger.bulkWriteResult;\n            throw bulkWriteError;\n          } else {\n            // Client side errors are just thrown.\n            throw error;\n          }\n        }\n      }\n\n      // If we have write concern errors or unordered write errors at the end we throw.\n      if (resultsMerger.writeConcernErrors.length > 0 || resultsMerger.writeErrors.size > 0) {\n        const error = new MongoClientBulkWriteError({\n          message: 'Mongo client bulk write encountered errors during execution.'\n        });\n        error.writeConcernErrors = resultsMerger.writeConcernErrors;\n        error.writeErrors = resultsMerger.writeErrors;\n        error.partialResult = resultsMerger.bulkWriteResult;\n        throw error;\n      }\n\n      return resultsMerger.bulkWriteResult;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}