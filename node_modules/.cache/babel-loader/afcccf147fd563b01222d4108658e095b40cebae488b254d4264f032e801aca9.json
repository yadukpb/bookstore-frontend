{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = executeOperation;\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst server_selection_1 = require(\"../sdam/server_selection\");\nconst utils_1 = require(\"../utils\");\nconst operation_1 = require(\"./operation\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * Allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided.\n *\n * The expectation is that this function:\n * - Connects the MongoClient if it has not already been connected, see {@link autoConnect}\n * - Creates a session if none is provided and cleans up the session it creates\n * - Tries an operation and retries under certain conditions, see {@link tryOperation}\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param client - The MongoClient to execute this operation with\n * @param operation - The operation to execute\n */\nasync function executeOperation(client, operation) {\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n  const topology = await autoConnect(client);\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner;\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({\n      owner,\n      explicit: false\n    });\n  } else if (session.hasEnded) {\n    throw new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n    throw new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  } else if (session.client !== client) {\n    throw new error_1.MongoInvalidArgumentError('ClientSession must be from the same MongoClient');\n  }\n  if (session.explicit && session?.timeoutMS != null && operation.options.timeoutMS != null) {\n    throw new error_1.MongoInvalidArgumentError('Do not specify timeoutMS on operation if already specified on an explicit session');\n  }\n  const readPreference = operation.readPreference ?? read_preference_1.ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n  const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary) && (hasReadAspect || operation.commandName === 'runCommand')) {\n    throw new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`);\n  }\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n  try {\n    return await tryOperation(operation, {\n      topology,\n      session,\n      readPreference\n    });\n  } finally {\n    if (session?.owner != null && session.owner === owner) {\n      await session.endSession();\n    }\n  }\n}\n/**\n * Connects a client if it has not yet been connected\n * @internal\n */\nasync function autoConnect(client) {\n  if (client.topology == null) {\n    if (client.s.hasBeenClosed) {\n      throw new error_1.MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n    try {\n      await client.connect();\n      if (client.topology == null) {\n        throw new error_1.MongoRuntimeError('client.connect did not create a topology but also did not throw');\n      }\n      return client.topology;\n    } finally {\n      delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n    }\n  }\n  return client.topology;\n}\n/**\n * Executes an operation and retries as appropriate\n * @internal\n *\n * @remarks\n * Implements behaviour described in [Retryable Reads](https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.md) and [Retryable\n * Writes](https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.md) specification\n *\n * This function:\n * - performs initial server selection\n * - attempts to execute an operation\n * - retries the operation if it meets the criteria for a retryable read or a retryable write\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param operation - The operation to execute\n * */\nasync function tryOperation(operation, _ref) {\n  let {\n    topology,\n    session,\n    readPreference\n  } = _ref;\n  let selector;\n  if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = (0, server_selection_1.sameServerSelector)(operation.server?.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n  let server = await topology.selectServer(selector, {\n    session,\n    operationName: operation.commandName\n  });\n  const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n  const inTransaction = session?.inTransaction() ?? false;\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n  const willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n  const willRetry = operation.hasAspect(operation_1.Aspect.RETRYABLE) && session != null && (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite);\n  if (hasWriteAspect && willRetryWrite && session != null) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n  // TODO(NODE-6231): implement infinite retry within CSOT timeout here\n  const maxTries = willRetry ? 2 : 1;\n  let previousOperationError;\n  let previousServer;\n  // TODO(NODE-6231): implement infinite retry within CSOT timeout here\n  for (let tries = 0; tries < maxTries; tries++) {\n    if (previousOperationError) {\n      if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n        throw new error_1.MongoServerError({\n          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          originalError: previousOperationError\n        });\n      }\n      if (operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING) && !operation.canRetryWrite) {\n        throw previousOperationError;\n      }\n      if (hasWriteAspect && !(0, error_1.isRetryableWriteError)(previousOperationError)) throw previousOperationError;\n      if (hasReadAspect && !(0, error_1.isRetryableReadError)(previousOperationError)) throw previousOperationError;\n      if (previousOperationError instanceof error_1.MongoNetworkError && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING) && session != null && session.isPinned && !session.inTransaction()) {\n        session.unpin({\n          force: true,\n          forceClear: true\n        });\n      }\n      server = await topology.selectServer(selector, {\n        session,\n        operationName: operation.commandName,\n        previousServer\n      });\n      if (hasWriteAspect && !(0, utils_1.supportsRetryableWrites)(server)) {\n        throw new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes');\n      }\n    }\n    try {\n      // If tries > 0 and we are command batching we need to reset the batch.\n      if (tries > 0 && operation.hasAspect(operation_1.Aspect.COMMAND_BATCHING)) {\n        operation.resetBatch();\n      }\n      return await operation.execute(server, session);\n    } catch (operationError) {\n      if (!(operationError instanceof error_1.MongoError)) throw operationError;\n      if (previousOperationError != null && operationError.hasErrorLabel(error_1.MongoErrorLabel.NoWritesPerformed)) {\n        throw previousOperationError;\n      }\n      previousServer = server.description;\n      previousOperationError = operationError;\n    }\n  }\n  throw previousOperationError ?? new error_1.MongoRuntimeError('Tried to propagate retryability error, but no error was found.');\n}","map":{"version":3,"mappings":"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","names":["exports","MMAPv1_RETRY_WRITES_ERROR_CODE","error_1","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","executeOperation","client","operation","operation_1","topology","autoConnect","session","owner","Symbol","startSession","explicit","hasEnded","snapshotEnabled","capabilities","supportsSnapshotReads","timeoutMS","options","readPreference","read_preference_1","primary","inTransaction","hasReadAspect","hasAspect","READ_OPERATION","equals","commandName","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","tryOperation","endSession","s","hasBeenClosed","for","connect","selector","MUST_SELECT_SAME_SERVER","server","description","trySecondaryWrite","commonWireVersion","selectServer","operationName","hasWriteAspect","WRITE_OPERATION","willRetryRead","retryReads","canRetryRead","willRetryWrite","retryWrites","canRetryWrite","willRetry","RETRYABLE","incrementTransactionNumber","maxTries","previousOperationError","previousServer","tries","code","message","errmsg","originalError","COMMAND_BATCHING","CURSOR_CREATING","force","forceClear","resetBatch","execute","operationError","hasErrorLabel","NoWritesPerformed"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/operations/execute_operation.ts"],"sourcesContent":["import {\n  isRetryableReadError,\n  isRetryableWriteError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  MongoError,\n  MongoErrorLabel,\n  MongoExpiredSessionError,\n  MongoInvalidArgumentError,\n  MongoNetworkError,\n  MongoNotConnectedError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoUnexpectedServerResponseError\n} from '../error';\nimport type { MongoClient } from '../mongo_client';\nimport { ReadPreference } from '../read_preference';\nimport type { ServerDescription } from '../sdam/server_description';\nimport {\n  sameServerSelector,\n  secondaryWritableServerSelector,\n  type ServerSelector\n} from '../sdam/server_selection';\nimport type { Topology } from '../sdam/topology';\nimport type { ClientSession } from '../sessions';\nimport { supportsRetryableWrites } from '../utils';\nimport { AbstractOperation, Aspect } from './operation';\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\ntype ResultTypeFromOperation<TOperation> =\n  TOperation extends AbstractOperation<infer K> ? K : never;\n\n/**\n * Executes the given operation with provided arguments.\n * @internal\n *\n * @remarks\n * Allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided.\n *\n * The expectation is that this function:\n * - Connects the MongoClient if it has not already been connected, see {@link autoConnect}\n * - Creates a session if none is provided and cleans up the session it creates\n * - Tries an operation and retries under certain conditions, see {@link tryOperation}\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param client - The MongoClient to execute this operation with\n * @param operation - The operation to execute\n */\nexport async function executeOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(client: MongoClient, operation: T): Promise<TResult> {\n  if (!(operation instanceof AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  const topology = await autoConnect(client);\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session = operation.session;\n  let owner: symbol | undefined;\n\n  if (session == null) {\n    owner = Symbol();\n    session = client.startSession({ owner, explicit: false });\n  } else if (session.hasEnded) {\n    throw new MongoExpiredSessionError('Use of expired sessions is not permitted');\n  } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n    throw new MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later');\n  } else if (session.client !== client) {\n    throw new MongoInvalidArgumentError('ClientSession must be from the same MongoClient');\n  }\n  if (session.explicit && session?.timeoutMS != null && operation.options.timeoutMS != null) {\n    throw new MongoInvalidArgumentError(\n      'Do not specify timeoutMS on operation if already specified on an explicit session'\n    );\n  }\n\n  const readPreference = operation.readPreference ?? ReadPreference.primary;\n  const inTransaction = !!session?.inTransaction();\n\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n\n  if (\n    inTransaction &&\n    !readPreference.equals(ReadPreference.primary) &&\n    (hasReadAspect || operation.commandName === 'runCommand')\n  ) {\n    throw new MongoTransactionError(\n      `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n    );\n  }\n\n  if (session?.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  try {\n    return await tryOperation(operation, {\n      topology,\n      session,\n      readPreference\n    });\n  } finally {\n    if (session?.owner != null && session.owner === owner) {\n      await session.endSession();\n    }\n  }\n}\n\n/**\n * Connects a client if it has not yet been connected\n * @internal\n */\nasync function autoConnect(client: MongoClient): Promise<Topology> {\n  if (client.topology == null) {\n    if (client.s.hasBeenClosed) {\n      throw new MongoNotConnectedError('Client must be connected before running operations');\n    }\n    client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n    try {\n      await client.connect();\n      if (client.topology == null) {\n        throw new MongoRuntimeError(\n          'client.connect did not create a topology but also did not throw'\n        );\n      }\n      return client.topology;\n    } finally {\n      delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n    }\n  }\n  return client.topology;\n}\n\n/** @internal */\ntype RetryOptions = {\n  session: ClientSession | undefined;\n  readPreference: ReadPreference;\n  topology: Topology;\n};\n\n/**\n * Executes an operation and retries as appropriate\n * @internal\n *\n * @remarks\n * Implements behaviour described in [Retryable Reads](https://github.com/mongodb/specifications/blob/master/source/retryable-reads/retryable-reads.md) and [Retryable\n * Writes](https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.md) specification\n *\n * This function:\n * - performs initial server selection\n * - attempts to execute an operation\n * - retries the operation if it meets the criteria for a retryable read or a retryable write\n *\n * @typeParam T - The operation's type\n * @typeParam TResult - The type of the operation's result, calculated from T\n *\n * @param operation - The operation to execute\n * */\nasync function tryOperation<\n  T extends AbstractOperation<TResult>,\n  TResult = ResultTypeFromOperation<T>\n>(operation: T, { topology, session, readPreference }: RetryOptions): Promise<TResult> {\n  let selector: ReadPreference | ServerSelector;\n\n  if (operation.hasAspect(Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = sameServerSelector(operation.server?.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = secondaryWritableServerSelector(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n\n  let server = await topology.selectServer(selector, {\n    session,\n    operationName: operation.commandName\n  });\n\n  const hasReadAspect = operation.hasAspect(Aspect.READ_OPERATION);\n  const hasWriteAspect = operation.hasAspect(Aspect.WRITE_OPERATION);\n  const inTransaction = session?.inTransaction() ?? false;\n\n  const willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n\n  const willRetryWrite =\n    topology.s.options.retryWrites &&\n    !inTransaction &&\n    supportsRetryableWrites(server) &&\n    operation.canRetryWrite;\n\n  const willRetry =\n    operation.hasAspect(Aspect.RETRYABLE) &&\n    session != null &&\n    ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite));\n\n  if (hasWriteAspect && willRetryWrite && session != null) {\n    operation.options.willRetryWrite = true;\n    session.incrementTransactionNumber();\n  }\n\n  // TODO(NODE-6231): implement infinite retry within CSOT timeout here\n  const maxTries = willRetry ? 2 : 1;\n  let previousOperationError: MongoError | undefined;\n  let previousServer: ServerDescription | undefined;\n\n  // TODO(NODE-6231): implement infinite retry within CSOT timeout here\n  for (let tries = 0; tries < maxTries; tries++) {\n    if (previousOperationError) {\n      if (hasWriteAspect && previousOperationError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n        throw new MongoServerError({\n          message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n          originalError: previousOperationError\n        });\n      }\n\n      if (operation.hasAspect(Aspect.COMMAND_BATCHING) && !operation.canRetryWrite) {\n        throw previousOperationError;\n      }\n\n      if (hasWriteAspect && !isRetryableWriteError(previousOperationError))\n        throw previousOperationError;\n\n      if (hasReadAspect && !isRetryableReadError(previousOperationError))\n        throw previousOperationError;\n\n      if (\n        previousOperationError instanceof MongoNetworkError &&\n        operation.hasAspect(Aspect.CURSOR_CREATING) &&\n        session != null &&\n        session.isPinned &&\n        !session.inTransaction()\n      ) {\n        session.unpin({ force: true, forceClear: true });\n      }\n\n      server = await topology.selectServer(selector, {\n        session,\n        operationName: operation.commandName,\n        previousServer\n      });\n\n      if (hasWriteAspect && !supportsRetryableWrites(server)) {\n        throw new MongoUnexpectedServerResponseError(\n          'Selected server does not support retryable writes'\n        );\n      }\n    }\n\n    try {\n      // If tries > 0 and we are command batching we need to reset the batch.\n      if (tries > 0 && operation.hasAspect(Aspect.COMMAND_BATCHING)) {\n        operation.resetBatch();\n      }\n      return await operation.execute(server, session);\n    } catch (operationError) {\n      if (!(operationError instanceof MongoError)) throw operationError;\n\n      if (\n        previousOperationError != null &&\n        operationError.hasErrorLabel(MongoErrorLabel.NoWritesPerformed)\n      ) {\n        throw previousOperationError;\n      }\n      previousServer = server.description;\n      previousOperationError = operationError;\n    }\n  }\n\n  throw (\n    previousOperationError ??\n    new MongoRuntimeError('Tried to propagate retryability error, but no error was found.')\n  );\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}