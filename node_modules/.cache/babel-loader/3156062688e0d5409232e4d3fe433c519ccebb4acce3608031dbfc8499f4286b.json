{"ast":null,"code":"\"use strict\";\n\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ServerSessionPool = exports.ServerSession = exports.ClientSession = void 0;\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\nexports.applySession = applySession;\nexports.updateSessionFromResponse = updateSessionFromResponse;\nconst bson_1 = require(\"./bson\");\nconst metrics_1 = require(\"./cmap/metrics\");\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\nconst constants_1 = require(\"./constants\");\nconst error_1 = require(\"./error\");\nconst mongo_types_1 = require(\"./mongo_types\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst run_command_1 = require(\"./operations/run_command\");\nconst read_concern_1 = require(\"./read_concern\");\nconst read_preference_1 = require(\"./read_preference\");\nconst resource_management_1 = require(\"./resource_management\");\nconst common_1 = require(\"./sdam/common\");\nconst transactions_1 = require(\"./transactions\");\nconst utils_1 = require(\"./utils\");\nconst write_concern_1 = require(\"./write_concern\");\nconst minWireVersionForShardedTransactions = 8;\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n  /**\n   * Create a client session.\n   * @internal\n   * @param client - The current client\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(client, sessionPool, options, clientOptions) {\n    super();\n    /** @internal */\n    this[_a] = false;\n    if (client == null) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');\n    }\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n    options = options ?? {};\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n      if (options.causalConsistency === true) {\n        throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n      }\n    }\n    this.client = client;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this.timeoutMS = options.defaultTimeoutMS ?? client.s.options?.timeoutMS;\n    this.explicit = !!options.explicit;\n    this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n    this[kTxnNumberIncrement] = 0;\n    const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;\n    this.supports = {\n      // if we can enable causal consistency, do so by default\n      causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue\n    };\n    this.clusterTime = options.initialClusterTime;\n    this.operationTime = undefined;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = {\n      ...options.defaultTransactionOptions\n    };\n    this.transaction = new transactions_1.Transaction();\n  }\n  /** The server id associated with this session */\n  get id() {\n    return this[kServerSession]?.id;\n  }\n  get serverSession() {\n    let serverSession = this[kServerSession];\n    if (serverSession == null) {\n      if (this.explicit) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');\n      }\n      if (this.hasEnded) {\n        throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n      }\n      serverSession = this.sessionPool.acquire();\n      this[kServerSession] = serverSession;\n    }\n    return serverSession;\n  }\n  /** Whether or not this session is configured for snapshot reads */\n  get snapshotEnabled() {\n    return this[kSnapshotEnabled];\n  }\n  get loadBalanced() {\n    return this.client.topology?.description.type === common_1.TopologyType.LoadBalanced;\n  }\n  /** @internal */\n  get pinnedConnection() {\n    return this[kPinnedConnection];\n  }\n  /** @internal */\n  pin(conn) {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n    this[kPinnedConnection] = conn;\n    conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n  }\n  /** @internal */\n  unpin(options) {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n    this.transaction.unpinServer();\n  }\n  get isPinned() {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n  /**\n   * Frees any client-side resources held by the current session.  If a session is in a transaction,\n   * the transaction is aborted.\n   *\n   * Does not end the session on the server.\n   *\n   * @param options - Optional settings. Currently reserved for future use\n   */\n  async endSession(options) {\n    try {\n      if (this.inTransaction()) {\n        await this.abortTransaction();\n      }\n      if (!this.hasEnded) {\n        const serverSession = this[kServerSession];\n        if (serverSession != null) {\n          // release the server session back to the pool\n          this.sessionPool.release(serverSession);\n          // Make sure a new serverSession never makes it onto this ClientSession\n          Object.defineProperty(this, kServerSession, {\n            value: ServerSession.clone(serverSession),\n            writable: false\n          });\n        }\n        // mark the session as ended, and emit a signal\n        this.hasEnded = true;\n        this.emit('ended', this);\n      }\n    } catch (error) {\n      // spec indicates that we should ignore all errors for `endSessions`\n      (0, utils_1.squashError)(error);\n    } finally {\n      maybeClearPinnedConnection(this, {\n        force: true,\n        ...options\n      });\n    }\n  }\n  /** @internal */\n  async asyncDispose() {\n    await this.endSession({\n      force: true\n    });\n  }\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n  advanceClusterTime(clusterTime) {\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n    }\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n    }\n    if (!clusterTime.signature || clusterTime.signature.hash?._bsontype !== 'Binary' || typeof clusterTime.signature.keyId !== 'bigint' && typeof clusterTime.signature.keyId !== 'number' && clusterTime.signature.keyId?._bsontype !== 'Long' // apparently we decode the key to number?\n    ) {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n    }\n    (0, common_1._advanceClusterTime)(this, clusterTime);\n  }\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n    return utils_1.ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);\n  }\n  /**\n   * Increment the transaction number on the internal ServerSession\n   *\n   * @privateRemarks\n   * This helper increments a value stored on the client session that will be\n   * added to the serverSession's txnNumber upon applying it to a command.\n   * This is because the serverSession is lazily acquired after a connection is obtained\n   */\n  incrementTransactionNumber() {\n    this[kTxnNumberIncrement] += 1;\n  }\n  /** @returns whether this session is currently in a transaction or not */\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @remarks\n   * **IMPORTANT**: Running operations in parallel is not supported during a transaction. The use of `Promise.all`,\n   * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is\n   * undefined behaviour.\n   *\n   * @param options - Options for the transaction\n   */\n  startTransaction(options) {\n    if (this[kSnapshotEnabled]) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n    }\n    if (this.inTransaction()) {\n      throw new error_1.MongoTransactionError('Transaction already in progress');\n    }\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n    const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);\n    if ((0, shared_1.isSharded)(this.client.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    }\n    this.commitAttempted = false;\n    // increment txnNumber\n    this.incrementTransactionNumber();\n    // create transaction state\n    this.transaction = new transactions_1.Transaction({\n      readConcern: options?.readConcern ?? this.defaultTransactionOptions.readConcern ?? this.clientOptions?.readConcern,\n      writeConcern: options?.writeConcern ?? this.defaultTransactionOptions.writeConcern ?? this.clientOptions?.writeConcern,\n      readPreference: options?.readPreference ?? this.defaultTransactionOptions.readPreference ?? this.clientOptions?.readPreference,\n      maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS\n    });\n    this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n  }\n  /**\n   * Commits the currently active transaction in this session.\n   */\n  async commitTransaction() {\n    if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {\n      throw new error_1.MongoTransactionError('No transaction started');\n    }\n    if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n      return;\n    }\n    if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      throw new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction');\n    }\n    const command = {\n      commitTransaction: 1\n    };\n    const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;\n    if (wc != null) {\n      write_concern_1.WriteConcern.apply(command, {\n        wtimeoutMS: 10000,\n        w: 'majority',\n        ...wc\n      });\n    }\n    if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.commitAttempted) {\n      write_concern_1.WriteConcern.apply(command, {\n        wtimeoutMS: 10000,\n        ...wc,\n        w: 'majority'\n      });\n    }\n    if (typeof this.transaction.options.maxTimeMS === 'number') {\n      command.maxTimeMS = this.transaction.options.maxTimeMS;\n    }\n    if (this.transaction.recoveryToken) {\n      command.recoveryToken = this.transaction.recoveryToken;\n    }\n    const operation = new run_command_1.RunAdminCommandOperation(command, {\n      session: this,\n      readPreference: read_preference_1.ReadPreference.primary,\n      bypassPinningCheck: true\n    });\n    try {\n      await (0, execute_operation_1.executeOperation)(this.client, operation);\n      this.commitAttempted = undefined;\n      return;\n    } catch (firstCommitError) {\n      this.commitAttempted = true;\n      if (firstCommitError instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(firstCommitError)) {\n        // SPEC-1185: apply majority write concern when retrying commitTransaction\n        write_concern_1.WriteConcern.apply(command, {\n          wtimeoutMS: 10000,\n          ...wc,\n          w: 'majority'\n        });\n        // per txns spec, must unpin session in this case\n        this.unpin({\n          force: true\n        });\n        try {\n          await (0, execute_operation_1.executeOperation)(this.client, new run_command_1.RunAdminCommandOperation(command, {\n            session: this,\n            readPreference: read_preference_1.ReadPreference.primary,\n            bypassPinningCheck: true\n          }));\n          return;\n        } catch (retryCommitError) {\n          // If the retry failed, we process that error instead of the original\n          if (shouldAddUnknownTransactionCommitResultLabel(retryCommitError)) {\n            retryCommitError.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n          }\n          if (shouldUnpinAfterCommitError(retryCommitError)) {\n            this.unpin({\n              error: retryCommitError\n            });\n          }\n          throw retryCommitError;\n        }\n      }\n      if (shouldAddUnknownTransactionCommitResultLabel(firstCommitError)) {\n        firstCommitError.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);\n      }\n      if (shouldUnpinAfterCommitError(firstCommitError)) {\n        this.unpin({\n          error: firstCommitError\n        });\n      }\n      throw firstCommitError;\n    } finally {\n      this.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n    }\n  }\n  /**\n   * Aborts the currently active transaction in this session.\n   */\n  async abortTransaction() {\n    if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION) {\n      throw new error_1.MongoTransactionError('No transaction started');\n    }\n    if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      return;\n    }\n    if (this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      throw new error_1.MongoTransactionError('Cannot call abortTransaction twice');\n    }\n    if (this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      throw new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction');\n    }\n    const command = {\n      abortTransaction: 1\n    };\n    const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;\n    if (wc != null) {\n      write_concern_1.WriteConcern.apply(command, {\n        wtimeoutMS: 10000,\n        w: 'majority',\n        ...wc\n      });\n    }\n    if (this.transaction.recoveryToken) {\n      command.recoveryToken = this.transaction.recoveryToken;\n    }\n    const operation = new run_command_1.RunAdminCommandOperation(command, {\n      session: this,\n      readPreference: read_preference_1.ReadPreference.primary,\n      bypassPinningCheck: true\n    });\n    try {\n      await (0, execute_operation_1.executeOperation)(this.client, operation);\n      this.unpin();\n      return;\n    } catch (firstAbortError) {\n      this.unpin();\n      if (firstAbortError instanceof error_1.MongoError && (0, error_1.isRetryableWriteError)(firstAbortError)) {\n        try {\n          await (0, execute_operation_1.executeOperation)(this.client, operation);\n          return;\n        } catch {\n          // we do not retry the retry\n        }\n      }\n      // The spec indicates that if the operation times out or fails with a non-retryable error, we should ignore all errors on `abortTransaction`\n    } finally {\n      this.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      if (this.loadBalanced) {\n        maybeClearPinnedConnection(this, {\n          force: false\n        });\n      }\n    }\n  }\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n  toBSON() {\n    throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n  /**\n   * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.\n   *\n   * **IMPORTANT:** This method requires the function passed in to return a Promise. That promise must be made by `await`-ing all operations in such a way that rejections are propagated to the returned promise.\n   *\n   * **IMPORTANT:** Running operations in parallel is not supported during a transaction. The use of `Promise.all`,\n   * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is\n   * undefined behaviour.\n   *\n   *\n   * @remarks\n   * - If all operations successfully complete and the `commitTransaction` operation is successful, then the provided function will return the result of the provided function.\n   * - If the transaction is unable to complete or an error is thrown from within the provided function, then the provided function will throw an error.\n   *   - If the transaction is manually aborted within the provided function it will not throw.\n   * - If the driver needs to attempt to retry the operations, the provided function may be called multiple times.\n   *\n   * Checkout a descriptive example here:\n   * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions\n   *\n   * If a command inside withTransaction fails:\n   * - It may cause the transaction on the server to be aborted.\n   * - This situation is normally handled transparently by the driver.\n   * - However, if the application catches such an error and does not rethrow it, the driver will not be able to determine whether the transaction was aborted or not.\n   * - The driver will then retry the transaction indefinitely.\n   *\n   * To avoid this situation, the application must not silently handle errors within the provided function.\n   * If the application needs to handle errors within, it must await all operations such that if an operation is rejected it becomes the rejection of the callback function passed into withTransaction.\n   *\n   * @param fn - callback to run within a transaction\n   * @param options - optional settings for the transaction\n   * @returns A raw command response or undefined\n   */\n  async withTransaction(fn, options) {\n    const MAX_TIMEOUT = 120000;\n    const startTime = (0, utils_1.now)();\n    let committed = false;\n    let result;\n    while (!committed) {\n      this.startTransaction(options); // may throw on error\n      try {\n        const promise = fn(this);\n        if (!(0, utils_1.isPromiseLike)(promise)) {\n          throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');\n        }\n        result = await promise;\n        if (this.transaction.state === transactions_1.TxnState.NO_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_COMMITTED || this.transaction.state === transactions_1.TxnState.TRANSACTION_ABORTED) {\n          // Assume callback intentionally ended the transaction\n          return result;\n        }\n      } catch (fnError) {\n        if (!(fnError instanceof error_1.MongoError) || fnError instanceof error_1.MongoInvalidArgumentError) {\n          await this.abortTransaction();\n          throw fnError;\n        }\n        if (this.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION || this.transaction.state === transactions_1.TxnState.TRANSACTION_IN_PROGRESS) {\n          await this.abortTransaction();\n        }\n        if (fnError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && (0, utils_1.now)() - startTime < MAX_TIMEOUT) {\n          continue;\n        }\n        throw fnError;\n      }\n      while (!committed) {\n        try {\n          /*\n           * We will rely on ClientSession.commitTransaction() to\n           * apply a majority write concern if commitTransaction is\n           * being retried (see: DRIVERS-601)\n           */\n          await this.commitTransaction();\n          committed = true;\n        } catch (commitError) {\n          /*\n           * Note: a maxTimeMS error will have the MaxTimeMSExpired\n           * code (50) and can be reported as a top-level error or\n           * inside writeConcernError, ex.\n           * { ok:0, code: 50, codeName: 'MaxTimeMSExpired' }\n           * { ok:1, writeConcernError: { code: 50, codeName: 'MaxTimeMSExpired' } }\n           */\n          if (!isMaxTimeMSExpiredError(commitError) && commitError.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult) && (0, utils_1.now)() - startTime < MAX_TIMEOUT) {\n            continue;\n          }\n          if (commitError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) && (0, utils_1.now)() - startTime < MAX_TIMEOUT) {\n            break;\n          }\n          throw commitError;\n        }\n      }\n    }\n    return result;\n  }\n}\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\n(0, resource_management_1.configureResourceManagement)(ClientSession.prototype);\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\nfunction shouldUnpinAfterCommitError(commitError) {\n  if (commitError instanceof error_1.MongoError) {\n    if ((0, error_1.isRetryableWriteError)(commitError) || commitError instanceof error_1.MongoWriteConcernError || isMaxTimeMSExpiredError(commitError)) {\n      if (isUnknownTransactionCommitResult(commitError)) {\n        // per txns spec, must unpin session in this case\n        return true;\n      }\n    } else if (commitError.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction shouldAddUnknownTransactionCommitResultLabel(commitError) {\n  let ok = (0, error_1.isRetryableWriteError)(commitError);\n  ok ||= commitError instanceof error_1.MongoWriteConcernError;\n  ok ||= isMaxTimeMSExpiredError(commitError);\n  ok &&= isUnknownTransactionCommitResult(commitError);\n  return ok;\n}\nfunction isUnknownTransactionCommitResult(err) {\n  const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;\n}\nfunction maybeClearPinnedConnection(session, options) {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options?.error;\n  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {\n    return;\n  }\n  const topology = session.client.topology;\n  // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n  if (conn && topology != null) {\n    const servers = Array.from(topology.s.servers.values());\n    const loadBalancer = servers[0];\n    if (options?.error == null || options?.force) {\n      loadBalancer.pool.checkIn(conn);\n      session[kPinnedConnection] = undefined;\n      conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n      if (options?.forceClear) {\n        loadBalancer.pool.clear({\n          serviceId: conn.serviceId\n        });\n      }\n    }\n  }\n}\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null || !(err instanceof error_1.MongoServerError)) {\n    return false;\n  }\n  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError?.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nclass ServerSession {\n  /** @internal */\n  constructor() {\n    this.id = {\n      id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = (0, utils_1.now)();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000 % 3600000 / 60000);\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n  /**\n   * @internal\n   * Cloning meant to keep a readable reference to the server session data\n   * after ClientSession has ended\n   */\n  static clone(serverSession) {\n    const arrayBuffer = new ArrayBuffer(16);\n    const idBytes = Buffer.from(arrayBuffer);\n    idBytes.set(serverSession.id.id.buffer);\n    const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);\n    // Manual prototype construction to avoid modifying the constructor of this class\n    return Object.setPrototypeOf({\n      id: {\n        id\n      },\n      lastUse: serverSession.lastUse,\n      txnNumber: serverSession.txnNumber,\n      isDirty: serverSession.isDirty\n    }, ServerSession.prototype);\n  }\n}\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nclass ServerSessionPool {\n  constructor(client) {\n    if (client == null) {\n      throw new error_1.MongoRuntimeError('ServerSessionPool requires a MongoClient');\n    }\n    this.client = client;\n    this.sessions = new utils_1.List();\n  }\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n  acquire() {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n    let session = null;\n    // Try to obtain from session pool\n    while (this.sessions.length > 0) {\n      const potentialSession = this.sessions.shift();\n      if (potentialSession != null && (!!this.client.topology?.loadBalanced || !potentialSession.hasTimedOut(sessionTimeoutMinutes))) {\n        session = potentialSession;\n        break;\n      }\n    }\n    // If nothing valid came from the pool make a new one\n    if (session == null) {\n      session = new ServerSession();\n    }\n    return session;\n  }\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n  release(session) {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n    if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n    this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\nexports.ServerSessionPool = ServerSessionPool;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\nfunction applySession(session, command, options) {\n  if (session.hasEnded) {\n    return new error_1.MongoExpiredSessionError();\n  }\n  // May acquire serverSession here\n  const serverSession = session.serverSession;\n  if (serverSession == null) {\n    return new error_1.MongoRuntimeError('Unable to acquire server session');\n  }\n  if (options.writeConcern?.w === 0) {\n    if (session && session.explicit) {\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n    return;\n  }\n  // mark the last use of this session, and apply the `lsid`\n  serverSession.lastUse = (0, utils_1.now)();\n  command.lsid = serverSession.id;\n  const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);\n  const isRetryableWrite = !!options.willRetryWrite;\n  if (isRetryableWrite || inTxnOrTxnCommand) {\n    serverSession.txnNumber += session[kTxnNumberIncrement];\n    session[kTxnNumberIncrement] = 0;\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n  }\n  if (!inTxnOrTxnCommand) {\n    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n    }\n    if (session.supports.causalConsistency && session.operationTime && (0, utils_1.commandSupportsReadConcern)(command)) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || {\n        level: read_concern_1.ReadConcernLevel.snapshot\n      };\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, {\n          atClusterTime: session[kSnapshotTime]\n        });\n      }\n    }\n    return;\n  }\n  // now attempt to apply transaction-specific sessions data\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    const readConcern = session.transaction.options.readConcern || session?.clientOptions?.readConcern;\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n  return;\n}\nfunction updateSessionFromResponse(session, document) {\n  if (document.$clusterTime) {\n    (0, common_1._advanceClusterTime)(session, document.$clusterTime);\n  }\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n  if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = document.atClusterTime;\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["exports","minWireVersionForShardedTransactions","kServerSession","Symbol","kSnapshotTime","kSnapshotEnabled","kPinnedConnection","kTxnNumberIncrement","ClientSession","mongo_types_1","constructor","client","sessionPool","options","clientOptions","error_1","ServerSessionPool","snapshot","causalConsistency","hasEnded","timeoutMS","defaultTimeoutMS","s","explicit","acquire","defaultCausalConsistencyValue","supports","clusterTime","initialClusterTime","operationTime","undefined","owner","defaultTransactionOptions","transaction","transactions_1","id","serverSession","snapshotEnabled","loadBalanced","topology","description","type","common_1","LoadBalanced","pinnedConnection","pin","conn","TypeError","emit","constants_1","inTransaction","metrics_1","TXN","CURSOR","unpin","maybeClearPinnedConnection","unpinServer","isPinned","endSession","abortTransaction","release","Object","defineProperty","value","ServerSession","clone","writable","error","force","asyncDispose","advanceOperationTime","greaterThan","advanceClusterTime","_bsontype","signature","hash","keyId","equals","session","utils_1","buffer","incrementTransactionNumber","isActive","startTransaction","isCommitted","topologyMaxWireVersion","commitAttempted","readConcern","writeConcern","readPreference","maxCommitTimeMS","transition","STARTING_TRANSACTION","commitTransaction","state","NO_TRANSACTION","TRANSACTION_COMMITTED_EMPTY","TRANSACTION_ABORTED","command","wc","write_concern_1","apply","wtimeoutMS","w","TRANSACTION_COMMITTED","maxTimeMS","recoveryToken","operation","run_command_1","read_preference_1","primary","bypassPinningCheck","firstCommitError","retryCommitError","shouldAddUnknownTransactionCommitResultLabel","addErrorLabel","UnknownTransactionCommitResult","shouldUnpinAfterCommitError","firstAbortError","toBSON","withTransaction","fn","MAX_TIMEOUT","startTime","committed","result","promise","fnError","TRANSACTION_IN_PROGRESS","hasErrorLabel","TransientTransactionError","commitError","isMaxTimeMSExpiredError","prototype","NON_DETERMINISTIC_WRITE_CONCERN_ERRORS","Set","isUnknownTransactionCommitResult","ok","err","isNonDeterministicWriteConcernError","codeName","has","code","UnsatisfiableWriteConcern","UnknownReplWriteConcern","servers","Array","from","values","loadBalancer","pool","checkIn","forceClear","clear","serviceId","MaxTimeMSExpired","writeConcernError","bson_1","SUBTYPE_UUID","lastUse","txnNumber","isDirty","hasTimedOut","sessionTimeoutMinutes","idleTimeMinutes","Math","round","arrayBuffer","ArrayBuffer","idBytes","Buffer","set","sub_type","setPrototypeOf","sessions","logicalSessionTimeoutMinutes","length","potentialSession","shift","unshift","prune","applySession","lsid","inTxnOrTxnCommand","isRetryableWrite","willRetryWrite","fromNumber","assign","afterClusterTime","level","read_concern_1","atClusterTime","autocommit","updateSessionFromResponse","document","$clusterTime","_recoveryToken"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/sessions.ts"],"sourcesContent":["import { Binary, type Document, Long, type Timestamp } from './bson';\nimport type { CommandOptions, Connection } from './cmap/connection';\nimport { ConnectionPoolMetrics } from './cmap/metrics';\nimport { type MongoDBResponse } from './cmap/wire_protocol/responses';\nimport { isSharded } from './cmap/wire_protocol/shared';\nimport { PINNED, UNPINNED } from './constants';\nimport type { AbstractCursor } from './cursor/abstract_cursor';\nimport {\n  type AnyError,\n  isRetryableWriteError,\n  MongoAPIError,\n  MongoCompatibilityError,\n  MONGODB_ERROR_CODES,\n  type MongoDriverError,\n  MongoError,\n  MongoErrorLabel,\n  MongoExpiredSessionError,\n  MongoInvalidArgumentError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoTransactionError,\n  MongoWriteConcernError\n} from './error';\nimport type { MongoClient, MongoOptions } from './mongo_client';\nimport { TypedEventEmitter } from './mongo_types';\nimport { executeOperation } from './operations/execute_operation';\nimport { RunAdminCommandOperation } from './operations/run_command';\nimport { ReadConcernLevel } from './read_concern';\nimport { ReadPreference } from './read_preference';\nimport { type AsyncDisposable, configureResourceManagement } from './resource_management';\nimport { _advanceClusterTime, type ClusterTime, TopologyType } from './sdam/common';\nimport {\n  isTransactionCommand,\n  Transaction,\n  type TransactionOptions,\n  TxnState\n} from './transactions';\nimport {\n  ByteUtils,\n  calculateDurationInMs,\n  commandSupportsReadConcern,\n  isPromiseLike,\n  List,\n  maxWireVersion,\n  now,\n  squashError,\n  uuidV4\n} from './utils';\nimport { WriteConcern, type WriteConcernOptions, type WriteConcernSettings } from './write_concern';\n\nconst minWireVersionForShardedTransactions = 8;\n\n/** @public */\nexport interface ClientSessionOptions {\n  /** Whether causal consistency should be enabled on this session */\n  causalConsistency?: boolean;\n  /** Whether all read operations should be read from the same snapshot for this session (NOTE: not compatible with `causalConsistency=true`) */\n  snapshot?: boolean;\n  /** The default TransactionOptions to use for transactions started on this session. */\n  defaultTransactionOptions?: TransactionOptions;\n  /** @internal\n   * The value of timeoutMS used for CSOT. Used to override client timeoutMS */\n  defaultTimeoutMS?: number;\n\n  /** @internal */\n  owner?: symbol | AbstractCursor;\n  /** @internal */\n  explicit?: boolean;\n  /** @internal */\n  initialClusterTime?: ClusterTime;\n}\n\n/** @public */\nexport type WithTransactionCallback<T = any> = (session: ClientSession) => Promise<T>;\n\n/** @public */\nexport type ClientSessionEvents = {\n  ended(session: ClientSession): void;\n};\n\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nconst kPinnedConnection = Symbol('pinnedConnection');\n/** @internal Accumulates total number of increments to add to txnNumber when applying session to command */\nconst kTxnNumberIncrement = Symbol('txnNumberIncrement');\n\n/** @public */\nexport interface EndSessionOptions {\n  /**\n   * An optional error which caused the call to end this session\n   * @internal\n   */\n  error?: AnyError;\n  force?: boolean;\n  forceClear?: boolean;\n}\n\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nexport class ClientSession\n  extends TypedEventEmitter<ClientSessionEvents>\n  implements AsyncDisposable\n{\n  /** @internal */\n  client: MongoClient;\n  /** @internal */\n  sessionPool: ServerSessionPool;\n  hasEnded: boolean;\n  clientOptions?: MongoOptions;\n  supports: { causalConsistency: boolean };\n  clusterTime?: ClusterTime;\n  operationTime?: Timestamp;\n  explicit: boolean;\n  /** @internal */\n  owner?: symbol | AbstractCursor;\n  defaultTransactionOptions: TransactionOptions;\n  transaction: Transaction;\n  /** @internal\n   * Keeps track of whether or not the current transaction has attempted to be committed. Is\n   * initially undefined. Gets set to false when startTransaction is called. When commitTransaction is sent to server, if the commitTransaction succeeds, it is then set to undefined, otherwise, set to true */\n  commitAttempted?: boolean;\n  /** @internal */\n  [kServerSession]: ServerSession | null;\n  /** @internal */\n  [kSnapshotTime]?: Timestamp;\n  /** @internal */\n  [kSnapshotEnabled] = false;\n  /** @internal */\n  [kPinnedConnection]?: Connection;\n  /** @internal */\n  [kTxnNumberIncrement]: number;\n  /** @internal */\n  timeoutMS?: number;\n\n  /**\n   * Create a client session.\n   * @internal\n   * @param client - The current client\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(\n    client: MongoClient,\n    sessionPool: ServerSessionPool,\n    options: ClientSessionOptions,\n    clientOptions?: MongoOptions\n  ) {\n    super();\n\n    if (client == null) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError('ClientSession requires a MongoClient');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options ?? {};\n\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n      if (options.causalConsistency === true) {\n        throw new MongoInvalidArgumentError(\n          'Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive'\n        );\n      }\n    }\n\n    this.client = client;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this.timeoutMS = options.defaultTimeoutMS ?? client.s.options?.timeoutMS;\n\n    this.explicit = !!options.explicit;\n    this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;\n    this[kTxnNumberIncrement] = 0;\n\n    const defaultCausalConsistencyValue = this.explicit && options.snapshot !== true;\n    this.supports = {\n      // if we can enable causal consistency, do so by default\n      causalConsistency: options.causalConsistency ?? defaultCausalConsistencyValue\n    };\n\n    this.clusterTime = options.initialClusterTime;\n\n    this.operationTime = undefined;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = { ...options.defaultTransactionOptions };\n    this.transaction = new Transaction();\n  }\n\n  /** The server id associated with this session */\n  get id(): ServerSessionId | undefined {\n    return this[kServerSession]?.id;\n  }\n\n  get serverSession(): ServerSession {\n    let serverSession = this[kServerSession];\n    if (serverSession == null) {\n      if (this.explicit) {\n        throw new MongoRuntimeError('Unexpected null serverSession for an explicit session');\n      }\n      if (this.hasEnded) {\n        throw new MongoRuntimeError('Unexpected null serverSession for an ended implicit session');\n      }\n      serverSession = this.sessionPool.acquire();\n      this[kServerSession] = serverSession;\n    }\n    return serverSession;\n  }\n\n  /** Whether or not this session is configured for snapshot reads */\n  get snapshotEnabled(): boolean {\n    return this[kSnapshotEnabled];\n  }\n\n  get loadBalanced(): boolean {\n    return this.client.topology?.description.type === TopologyType.LoadBalanced;\n  }\n\n  /** @internal */\n  get pinnedConnection(): Connection | undefined {\n    return this[kPinnedConnection];\n  }\n\n  /** @internal */\n  pin(conn: Connection): void {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n\n    this[kPinnedConnection] = conn;\n    conn.emit(\n      PINNED,\n      this.inTransaction() ? ConnectionPoolMetrics.TXN : ConnectionPoolMetrics.CURSOR\n    );\n  }\n\n  /** @internal */\n  unpin(options?: { force?: boolean; forceClear?: boolean; error?: AnyError }): void {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n\n    this.transaction.unpinServer();\n  }\n\n  get isPinned(): boolean {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n\n  /**\n   * Frees any client-side resources held by the current session.  If a session is in a transaction,\n   * the transaction is aborted.\n   *\n   * Does not end the session on the server.\n   *\n   * @param options - Optional settings. Currently reserved for future use\n   */\n  async endSession(options?: EndSessionOptions): Promise<void> {\n    try {\n      if (this.inTransaction()) {\n        await this.abortTransaction();\n      }\n      if (!this.hasEnded) {\n        const serverSession = this[kServerSession];\n        if (serverSession != null) {\n          // release the server session back to the pool\n          this.sessionPool.release(serverSession);\n          // Make sure a new serverSession never makes it onto this ClientSession\n          Object.defineProperty(this, kServerSession, {\n            value: ServerSession.clone(serverSession),\n            writable: false\n          });\n        }\n        // mark the session as ended, and emit a signal\n        this.hasEnded = true;\n        this.emit('ended', this);\n      }\n    } catch (error) {\n      // spec indicates that we should ignore all errors for `endSessions`\n      squashError(error);\n    } finally {\n      maybeClearPinnedConnection(this, { force: true, ...options });\n    }\n  }\n  /**\n   * @beta\n   * @experimental\n   * An alias for {@link ClientSession.endSession|ClientSession.endSession()}.\n   */\n  declare [Symbol.asyncDispose]: () => Promise<void>;\n  /** @internal */\n  async asyncDispose() {\n    await this.endSession({ force: true });\n  }\n\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime: Timestamp): void {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n  advanceClusterTime(clusterTime: ClusterTime): void {\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new MongoInvalidArgumentError('input cluster time must be an object');\n    }\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new MongoInvalidArgumentError(\n        'input cluster time \"clusterTime\" property must be a valid BSON Timestamp'\n      );\n    }\n    if (\n      !clusterTime.signature ||\n      clusterTime.signature.hash?._bsontype !== 'Binary' ||\n      (typeof clusterTime.signature.keyId !== 'bigint' &&\n        typeof clusterTime.signature.keyId !== 'number' &&\n        clusterTime.signature.keyId?._bsontype !== 'Long') // apparently we decode the key to number?\n    ) {\n      throw new MongoInvalidArgumentError(\n        'input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId'\n      );\n    }\n\n    _advanceClusterTime(this, clusterTime);\n  }\n\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n  equals(session: ClientSession): boolean {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n\n    return ByteUtils.equals(this.id.id.buffer, session.id.id.buffer);\n  }\n\n  /**\n   * Increment the transaction number on the internal ServerSession\n   *\n   * @privateRemarks\n   * This helper increments a value stored on the client session that will be\n   * added to the serverSession's txnNumber upon applying it to a command.\n   * This is because the serverSession is lazily acquired after a connection is obtained\n   */\n  incrementTransactionNumber(): void {\n    this[kTxnNumberIncrement] += 1;\n  }\n\n  /** @returns whether this session is currently in a transaction or not */\n  inTransaction(): boolean {\n    return this.transaction.isActive;\n  }\n\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @remarks\n   * **IMPORTANT**: Running operations in parallel is not supported during a transaction. The use of `Promise.all`,\n   * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is\n   * undefined behaviour.\n   *\n   * @param options - Options for the transaction\n   */\n  startTransaction(options?: TransactionOptions): void {\n    if (this[kSnapshotEnabled]) {\n      throw new MongoCompatibilityError('Transactions are not supported in snapshot sessions');\n    }\n\n    if (this.inTransaction()) {\n      throw new MongoTransactionError('Transaction already in progress');\n    }\n\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n\n    const topologyMaxWireVersion = maxWireVersion(this.client.topology);\n    if (\n      isSharded(this.client.topology) &&\n      topologyMaxWireVersion != null &&\n      topologyMaxWireVersion < minWireVersionForShardedTransactions\n    ) {\n      throw new MongoCompatibilityError(\n        'Transactions are not supported on sharded clusters in MongoDB < 4.2.'\n      );\n    }\n\n    this.commitAttempted = false;\n    // increment txnNumber\n    this.incrementTransactionNumber();\n    // create transaction state\n    this.transaction = new Transaction({\n      readConcern:\n        options?.readConcern ??\n        this.defaultTransactionOptions.readConcern ??\n        this.clientOptions?.readConcern,\n      writeConcern:\n        options?.writeConcern ??\n        this.defaultTransactionOptions.writeConcern ??\n        this.clientOptions?.writeConcern,\n      readPreference:\n        options?.readPreference ??\n        this.defaultTransactionOptions.readPreference ??\n        this.clientOptions?.readPreference,\n      maxCommitTimeMS: options?.maxCommitTimeMS ?? this.defaultTransactionOptions.maxCommitTimeMS\n    });\n\n    this.transaction.transition(TxnState.STARTING_TRANSACTION);\n  }\n\n  /**\n   * Commits the currently active transaction in this session.\n   */\n  async commitTransaction(): Promise<void> {\n    if (this.transaction.state === TxnState.NO_TRANSACTION) {\n      throw new MongoTransactionError('No transaction started');\n    }\n\n    if (\n      this.transaction.state === TxnState.STARTING_TRANSACTION ||\n      this.transaction.state === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      // the transaction was never started, we can safely exit here\n      this.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\n      return;\n    }\n\n    if (this.transaction.state === TxnState.TRANSACTION_ABORTED) {\n      throw new MongoTransactionError(\n        'Cannot call commitTransaction after calling abortTransaction'\n      );\n    }\n\n    const command: {\n      commitTransaction: 1;\n      writeConcern?: WriteConcernSettings;\n      recoveryToken?: Document;\n      maxTimeMS?: number;\n    } = { commitTransaction: 1 };\n\n    const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;\n    if (wc != null) {\n      WriteConcern.apply(command, { wtimeoutMS: 10000, w: 'majority', ...wc });\n    }\n\n    if (this.transaction.state === TxnState.TRANSACTION_COMMITTED || this.commitAttempted) {\n      WriteConcern.apply(command, { wtimeoutMS: 10000, ...wc, w: 'majority' });\n    }\n\n    if (typeof this.transaction.options.maxTimeMS === 'number') {\n      command.maxTimeMS = this.transaction.options.maxTimeMS;\n    }\n\n    if (this.transaction.recoveryToken) {\n      command.recoveryToken = this.transaction.recoveryToken;\n    }\n\n    const operation = new RunAdminCommandOperation(command, {\n      session: this,\n      readPreference: ReadPreference.primary,\n      bypassPinningCheck: true\n    });\n\n    try {\n      await executeOperation(this.client, operation);\n      this.commitAttempted = undefined;\n      return;\n    } catch (firstCommitError) {\n      this.commitAttempted = true;\n      if (firstCommitError instanceof MongoError && isRetryableWriteError(firstCommitError)) {\n        // SPEC-1185: apply majority write concern when retrying commitTransaction\n        WriteConcern.apply(command, { wtimeoutMS: 10000, ...wc, w: 'majority' });\n        // per txns spec, must unpin session in this case\n        this.unpin({ force: true });\n\n        try {\n          await executeOperation(\n            this.client,\n            new RunAdminCommandOperation(command, {\n              session: this,\n              readPreference: ReadPreference.primary,\n              bypassPinningCheck: true\n            })\n          );\n          return;\n        } catch (retryCommitError) {\n          // If the retry failed, we process that error instead of the original\n          if (shouldAddUnknownTransactionCommitResultLabel(retryCommitError)) {\n            retryCommitError.addErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult);\n          }\n\n          if (shouldUnpinAfterCommitError(retryCommitError)) {\n            this.unpin({ error: retryCommitError });\n          }\n\n          throw retryCommitError;\n        }\n      }\n\n      if (shouldAddUnknownTransactionCommitResultLabel(firstCommitError)) {\n        firstCommitError.addErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult);\n      }\n\n      if (shouldUnpinAfterCommitError(firstCommitError)) {\n        this.unpin({ error: firstCommitError });\n      }\n\n      throw firstCommitError;\n    } finally {\n      this.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n    }\n  }\n\n  /**\n   * Aborts the currently active transaction in this session.\n   */\n  async abortTransaction(): Promise<void> {\n    if (this.transaction.state === TxnState.NO_TRANSACTION) {\n      throw new MongoTransactionError('No transaction started');\n    }\n\n    if (this.transaction.state === TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      this.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      return;\n    }\n\n    if (this.transaction.state === TxnState.TRANSACTION_ABORTED) {\n      throw new MongoTransactionError('Cannot call abortTransaction twice');\n    }\n\n    if (\n      this.transaction.state === TxnState.TRANSACTION_COMMITTED ||\n      this.transaction.state === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      throw new MongoTransactionError(\n        'Cannot call abortTransaction after calling commitTransaction'\n      );\n    }\n\n    const command: {\n      abortTransaction: 1;\n      writeConcern?: WriteConcernOptions;\n      recoveryToken?: Document;\n    } = { abortTransaction: 1 };\n\n    const wc = this.transaction.options.writeConcern ?? this.clientOptions?.writeConcern;\n    if (wc != null) {\n      WriteConcern.apply(command, { wtimeoutMS: 10000, w: 'majority', ...wc });\n    }\n\n    if (this.transaction.recoveryToken) {\n      command.recoveryToken = this.transaction.recoveryToken;\n    }\n\n    const operation = new RunAdminCommandOperation(command, {\n      session: this,\n      readPreference: ReadPreference.primary,\n      bypassPinningCheck: true\n    });\n\n    try {\n      await executeOperation(this.client, operation);\n      this.unpin();\n      return;\n    } catch (firstAbortError) {\n      this.unpin();\n\n      if (firstAbortError instanceof MongoError && isRetryableWriteError(firstAbortError)) {\n        try {\n          await executeOperation(this.client, operation);\n          return;\n        } catch {\n          // we do not retry the retry\n        }\n      }\n\n      // The spec indicates that if the operation times out or fails with a non-retryable error, we should ignore all errors on `abortTransaction`\n    } finally {\n      this.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      if (this.loadBalanced) {\n        maybeClearPinnedConnection(this, { force: false });\n      }\n    }\n  }\n\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n  toBSON(): never {\n    throw new MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n\n  /**\n   * Starts a transaction and runs a provided function, ensuring the commitTransaction is always attempted when all operations run in the function have completed.\n   *\n   * **IMPORTANT:** This method requires the function passed in to return a Promise. That promise must be made by `await`-ing all operations in such a way that rejections are propagated to the returned promise.\n   *\n   * **IMPORTANT:** Running operations in parallel is not supported during a transaction. The use of `Promise.all`,\n   * `Promise.allSettled`, `Promise.race`, etc to parallelize operations inside a transaction is\n   * undefined behaviour.\n   *\n   *\n   * @remarks\n   * - If all operations successfully complete and the `commitTransaction` operation is successful, then the provided function will return the result of the provided function.\n   * - If the transaction is unable to complete or an error is thrown from within the provided function, then the provided function will throw an error.\n   *   - If the transaction is manually aborted within the provided function it will not throw.\n   * - If the driver needs to attempt to retry the operations, the provided function may be called multiple times.\n   *\n   * Checkout a descriptive example here:\n   * @see https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-implement-transactions\n   *\n   * If a command inside withTransaction fails:\n   * - It may cause the transaction on the server to be aborted.\n   * - This situation is normally handled transparently by the driver.\n   * - However, if the application catches such an error and does not rethrow it, the driver will not be able to determine whether the transaction was aborted or not.\n   * - The driver will then retry the transaction indefinitely.\n   *\n   * To avoid this situation, the application must not silently handle errors within the provided function.\n   * If the application needs to handle errors within, it must await all operations such that if an operation is rejected it becomes the rejection of the callback function passed into withTransaction.\n   *\n   * @param fn - callback to run within a transaction\n   * @param options - optional settings for the transaction\n   * @returns A raw command response or undefined\n   */\n  async withTransaction<T = any>(\n    fn: WithTransactionCallback<T>,\n    options?: TransactionOptions\n  ): Promise<T> {\n    const MAX_TIMEOUT = 120000;\n    const startTime = now();\n\n    let committed = false;\n    let result: any;\n\n    while (!committed) {\n      this.startTransaction(options); // may throw on error\n\n      try {\n        const promise = fn(this);\n        if (!isPromiseLike(promise)) {\n          throw new MongoInvalidArgumentError(\n            'Function provided to `withTransaction` must return a Promise'\n          );\n        }\n\n        result = await promise;\n\n        if (\n          this.transaction.state === TxnState.NO_TRANSACTION ||\n          this.transaction.state === TxnState.TRANSACTION_COMMITTED ||\n          this.transaction.state === TxnState.TRANSACTION_ABORTED\n        ) {\n          // Assume callback intentionally ended the transaction\n          return result;\n        }\n      } catch (fnError) {\n        if (!(fnError instanceof MongoError) || fnError instanceof MongoInvalidArgumentError) {\n          await this.abortTransaction();\n          throw fnError;\n        }\n\n        if (\n          this.transaction.state === TxnState.STARTING_TRANSACTION ||\n          this.transaction.state === TxnState.TRANSACTION_IN_PROGRESS\n        ) {\n          await this.abortTransaction();\n        }\n\n        if (\n          fnError.hasErrorLabel(MongoErrorLabel.TransientTransactionError) &&\n          now() - startTime < MAX_TIMEOUT\n        ) {\n          continue;\n        }\n\n        throw fnError;\n      }\n\n      while (!committed) {\n        try {\n          /*\n           * We will rely on ClientSession.commitTransaction() to\n           * apply a majority write concern if commitTransaction is\n           * being retried (see: DRIVERS-601)\n           */\n          await this.commitTransaction();\n          committed = true;\n        } catch (commitError) {\n          /*\n           * Note: a maxTimeMS error will have the MaxTimeMSExpired\n           * code (50) and can be reported as a top-level error or\n           * inside writeConcernError, ex.\n           * { ok:0, code: 50, codeName: 'MaxTimeMSExpired' }\n           * { ok:1, writeConcernError: { code: 50, codeName: 'MaxTimeMSExpired' } }\n           */\n          if (\n            !isMaxTimeMSExpiredError(commitError) &&\n            commitError.hasErrorLabel(MongoErrorLabel.UnknownTransactionCommitResult) &&\n            now() - startTime < MAX_TIMEOUT\n          ) {\n            continue;\n          }\n\n          if (\n            commitError.hasErrorLabel(MongoErrorLabel.TransientTransactionError) &&\n            now() - startTime < MAX_TIMEOUT\n          ) {\n            break;\n          }\n\n          throw commitError;\n        }\n      }\n    }\n\n    return result;\n  }\n}\n\nconfigureResourceManagement(ClientSession.prototype);\n\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\n  'CannotSatisfyWriteConcern',\n  'UnknownReplWriteConcern',\n  'UnsatisfiableWriteConcern'\n]);\n\nfunction shouldUnpinAfterCommitError(commitError: Error) {\n  if (commitError instanceof MongoError) {\n    if (\n      isRetryableWriteError(commitError) ||\n      commitError instanceof MongoWriteConcernError ||\n      isMaxTimeMSExpiredError(commitError)\n    ) {\n      if (isUnknownTransactionCommitResult(commitError)) {\n        // per txns spec, must unpin session in this case\n        return true;\n      }\n    } else if (commitError.hasErrorLabel(MongoErrorLabel.TransientTransactionError)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction shouldAddUnknownTransactionCommitResultLabel(commitError: MongoError) {\n  let ok = isRetryableWriteError(commitError);\n  ok ||= commitError instanceof MongoWriteConcernError;\n  ok ||= isMaxTimeMSExpiredError(commitError);\n  ok &&= isUnknownTransactionCommitResult(commitError);\n  return ok;\n}\n\nfunction isUnknownTransactionCommitResult(err: MongoError): err is MongoError {\n  const isNonDeterministicWriteConcernError =\n    err instanceof MongoServerError &&\n    err.codeName &&\n    NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n\n  return (\n    isMaxTimeMSExpiredError(err) ||\n    (!isNonDeterministicWriteConcernError &&\n      err.code !== MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&\n      err.code !== MONGODB_ERROR_CODES.UnknownReplWriteConcern)\n  );\n}\n\nexport function maybeClearPinnedConnection(\n  session: ClientSession,\n  options?: EndSessionOptions\n): void {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options?.error;\n\n  if (\n    session.inTransaction() &&\n    error &&\n    error instanceof MongoError &&\n    error.hasErrorLabel(MongoErrorLabel.TransientTransactionError)\n  ) {\n    return;\n  }\n\n  const topology = session.client.topology;\n  // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n  if (conn && topology != null) {\n    const servers = Array.from(topology.s.servers.values());\n    const loadBalancer = servers[0];\n\n    if (options?.error == null || options?.force) {\n      loadBalancer.pool.checkIn(conn);\n      session[kPinnedConnection] = undefined;\n      conn.emit(\n        UNPINNED,\n        session.transaction.state !== TxnState.NO_TRANSACTION\n          ? ConnectionPoolMetrics.TXN\n          : ConnectionPoolMetrics.CURSOR\n      );\n\n      if (options?.forceClear) {\n        loadBalancer.pool.clear({ serviceId: conn.serviceId });\n      }\n    }\n  }\n}\n\nfunction isMaxTimeMSExpiredError(err: MongoError): boolean {\n  if (err == null || !(err instanceof MongoServerError)) {\n    return false;\n  }\n\n  return (\n    err.code === MONGODB_ERROR_CODES.MaxTimeMSExpired ||\n    err.writeConcernError?.code === MONGODB_ERROR_CODES.MaxTimeMSExpired\n  );\n}\n\n/** @public */\nexport type ServerSessionId = { id: Binary };\n\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nexport class ServerSession {\n  id: ServerSessionId;\n  lastUse: number;\n  txnNumber: number;\n  isDirty: boolean;\n\n  /** @internal */\n  constructor() {\n    this.id = { id: new Binary(uuidV4(), Binary.SUBTYPE_UUID) };\n    this.lastUse = now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n  hasTimedOut(sessionTimeoutMinutes: number): boolean {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round(\n      ((calculateDurationInMs(this.lastUse) % 86400000) % 3600000) / 60000\n    );\n\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n\n  /**\n   * @internal\n   * Cloning meant to keep a readable reference to the server session data\n   * after ClientSession has ended\n   */\n  static clone(serverSession: ServerSession): Readonly<ServerSession> {\n    const arrayBuffer = new ArrayBuffer(16);\n    const idBytes = Buffer.from(arrayBuffer);\n    idBytes.set(serverSession.id.id.buffer);\n\n    const id = new Binary(idBytes, serverSession.id.id.sub_type);\n\n    // Manual prototype construction to avoid modifying the constructor of this class\n    return Object.setPrototypeOf(\n      {\n        id: { id },\n        lastUse: serverSession.lastUse,\n        txnNumber: serverSession.txnNumber,\n        isDirty: serverSession.isDirty\n      },\n      ServerSession.prototype\n    );\n  }\n}\n\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nexport class ServerSessionPool {\n  client: MongoClient;\n  sessions: List<ServerSession>;\n\n  constructor(client: MongoClient) {\n    if (client == null) {\n      throw new MongoRuntimeError('ServerSessionPool requires a MongoClient');\n    }\n\n    this.client = client;\n    this.sessions = new List<ServerSession>();\n  }\n\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n  acquire(): ServerSession {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n\n    let session: ServerSession | null = null;\n\n    // Try to obtain from session pool\n    while (this.sessions.length > 0) {\n      const potentialSession = this.sessions.shift();\n      if (\n        potentialSession != null &&\n        (!!this.client.topology?.loadBalanced ||\n          !potentialSession.hasTimedOut(sessionTimeoutMinutes))\n      ) {\n        session = potentialSession;\n        break;\n      }\n    }\n\n    // If nothing valid came from the pool make a new one\n    if (session == null) {\n      session = new ServerSession();\n    }\n\n    return session;\n  }\n\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n  release(session: ServerSession): void {\n    const sessionTimeoutMinutes = this.client.topology?.logicalSessionTimeoutMinutes ?? 10;\n\n    if (this.client.topology?.loadBalanced && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n\n    this.sessions.prune(session => session.hasTimedOut(sessionTimeoutMinutes));\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\n\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n *\n * @internal\n */\nexport function applySession(\n  session: ClientSession,\n  command: Document,\n  options: CommandOptions\n): MongoDriverError | undefined {\n  if (session.hasEnded) {\n    return new MongoExpiredSessionError();\n  }\n\n  // May acquire serverSession here\n  const serverSession = session.serverSession;\n  if (serverSession == null) {\n    return new MongoRuntimeError('Unable to acquire server session');\n  }\n\n  if (options.writeConcern?.w === 0) {\n    if (session && session.explicit) {\n      // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)\n      return new MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n    return;\n  }\n\n  // mark the last use of this session, and apply the `lsid`\n  serverSession.lastUse = now();\n  command.lsid = serverSession.id;\n\n  const inTxnOrTxnCommand = session.inTransaction() || isTransactionCommand(command);\n  const isRetryableWrite = !!options.willRetryWrite;\n\n  if (isRetryableWrite || inTxnOrTxnCommand) {\n    serverSession.txnNumber += session[kTxnNumberIncrement];\n    session[kTxnNumberIncrement] = 0;\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    command.txnNumber = Long.fromNumber(serverSession.txnNumber);\n  }\n\n  if (!inTxnOrTxnCommand) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    }\n\n    if (\n      session.supports.causalConsistency &&\n      session.operationTime &&\n      commandSupportsReadConcern(command)\n    ) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || { level: ReadConcernLevel.snapshot };\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });\n      }\n    }\n\n    return;\n  }\n\n  // now attempt to apply transaction-specific sessions data\n\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n\n    const readConcern =\n      session.transaction.options.readConcern || session?.clientOptions?.readConcern;\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    }\n  }\n  return;\n}\n\nexport function updateSessionFromResponse(session: ClientSession, document: MongoDBResponse): void {\n  if (document.$clusterTime) {\n    _advanceClusterTime(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n\n  if (session?.[kSnapshotEnabled] && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = document.atClusterTime;\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}