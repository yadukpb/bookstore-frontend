{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.retryable = retryable;\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst timeout_1 = require(\"./timeout\");\n/**\n * Creates a function equivalent to func, but that retries on certain\n * exceptions.\n *\n * @private\n *\n * @param {GRPCCall} func - A function.\n * @param {RetryOptions} retry - Configures the exceptions upon which the\n *   function eshould retry, and the parameters to the exponential backoff retry\n *   algorithm.\n * @param {GRPCCallOtherArgs} otherArgs - the additional arguments to be passed to func.\n * @return {SimpleCallbackFunction} A function that will retry.\n */\nfunction retryable(func, retry, otherArgs, apiName) {\n  const delayMult = retry.backoffSettings.retryDelayMultiplier;\n  const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n  const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n  const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n  let delay = retry.backoffSettings.initialRetryDelayMillis;\n  let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n  /**\n   * Equivalent to ``func``, but retries upon transient failure.\n   *\n   * Retrying is done through an exponential backoff algorithm configured\n   * by the options in ``retry``.\n   * @param {RequestType} argument The request object.\n   * @param {APICallback} callback The callback.\n   * @return {GRPCCall}\n   */\n  return (argument, callback) => {\n    let canceller;\n    let timeoutId;\n    let now = new Date();\n    let deadline;\n    if (retry.backoffSettings.totalTimeoutMillis) {\n      deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n    }\n    let retries = 0;\n    const maxRetries = retry.backoffSettings.maxRetries;\n    // TODO: define A/B testing values for retry behaviors.\n    /** Repeat the API call as long as necessary. */\n    function repeat(err) {\n      timeoutId = null;\n      if (deadline && now.getTime() >= deadline) {\n        const error = new googleError_1.GoogleError(`Total timeout of API ${apiName} exceeded ${retry.backoffSettings.totalTimeoutMillis} milliseconds ${err ? `retrying error ${err} ` : ''} before any response was received.`);\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n      if (retries && retries >= maxRetries) {\n        const error = new googleError_1.GoogleError('Exceeded maximum number of retries ' + (err ? `retrying error ${err} ` : '') + 'before any response was received');\n        error.code = status_1.Status.DEADLINE_EXCEEDED;\n        callback(error);\n        return;\n      }\n      retries++;\n      let lastError = err;\n      const toCall = (0, timeout_1.addTimeoutArg)(func, timeout, otherArgs);\n      canceller = toCall(argument, (err, response, next, rawResponse) => {\n        // Save only the error before deadline exceeded\n        if (err && err.code !== 4) {\n          lastError = err;\n        }\n        if (!err) {\n          callback(null, response, next, rawResponse);\n          return;\n        }\n        canceller = null;\n        if (retry.retryCodes.length > 0 && retry.retryCodes.indexOf(err.code) < 0) {\n          err.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n          callback(err);\n        } else {\n          const toSleep = Math.random() * delay;\n          timeoutId = setTimeout(() => {\n            now = new Date();\n            delay = Math.min(delay * delayMult, maxDelay);\n            const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n            const rpcTimeout = maxTimeout ? maxTimeout : 0;\n            const newDeadline = deadline ? deadline - now.getTime() : 0;\n            timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n            repeat(lastError);\n          }, toSleep);\n        }\n      });\n      if (canceller instanceof Promise) {\n        canceller.catch(err => {\n          callback(new googleError_1.GoogleError(err));\n        });\n      }\n    }\n    if (maxRetries && deadline) {\n      const error = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' + 'in backoffSettings.');\n      error.code = status_1.Status.INVALID_ARGUMENT;\n      callback(error);\n    } else {\n      repeat();\n    }\n    return {\n      cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        if (canceller) {\n          canceller.cancel();\n        } else {\n          const error = new googleError_1.GoogleError('cancelled');\n          error.code = status_1.Status.CANCELLED;\n          callback(error);\n        }\n      }\n    };\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","retryable","status_1","require","googleError_1","timeout_1","func","retry","otherArgs","apiName","delayMult","backoffSettings","retryDelayMultiplier","maxDelay","maxRetryDelayMillis","timeoutMult","rpcTimeoutMultiplier","maxTimeout","maxRpcTimeoutMillis","delay","initialRetryDelayMillis","timeout","initialRpcTimeoutMillis","argument","callback","canceller","timeoutId","now","Date","deadline","totalTimeoutMillis","getTime","retries","maxRetries","repeat","err","error","GoogleError","code","Status","DEADLINE_EXCEEDED","lastError","toCall","addTimeoutArg","response","next","rawResponse","retryCodes","length","indexOf","note","toSleep","Math","random","setTimeout","min","timeoutCal","rpcTimeout","newDeadline","Promise","catch","INVALID_ARGUMENT","cancel","clearTimeout","CANCELLED"],"sources":["/home/yadu/Music/Gifty/node_modules/google-gax/build/src/normalCalls/retries.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.retryable = retryable;\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst timeout_1 = require(\"./timeout\");\n/**\n * Creates a function equivalent to func, but that retries on certain\n * exceptions.\n *\n * @private\n *\n * @param {GRPCCall} func - A function.\n * @param {RetryOptions} retry - Configures the exceptions upon which the\n *   function eshould retry, and the parameters to the exponential backoff retry\n *   algorithm.\n * @param {GRPCCallOtherArgs} otherArgs - the additional arguments to be passed to func.\n * @return {SimpleCallbackFunction} A function that will retry.\n */\nfunction retryable(func, retry, otherArgs, apiName) {\n    const delayMult = retry.backoffSettings.retryDelayMultiplier;\n    const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n    const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n    const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n    let delay = retry.backoffSettings.initialRetryDelayMillis;\n    let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n    /**\n     * Equivalent to ``func``, but retries upon transient failure.\n     *\n     * Retrying is done through an exponential backoff algorithm configured\n     * by the options in ``retry``.\n     * @param {RequestType} argument The request object.\n     * @param {APICallback} callback The callback.\n     * @return {GRPCCall}\n     */\n    return (argument, callback) => {\n        let canceller;\n        let timeoutId;\n        let now = new Date();\n        let deadline;\n        if (retry.backoffSettings.totalTimeoutMillis) {\n            deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n        }\n        let retries = 0;\n        const maxRetries = retry.backoffSettings.maxRetries;\n        // TODO: define A/B testing values for retry behaviors.\n        /** Repeat the API call as long as necessary. */\n        function repeat(err) {\n            timeoutId = null;\n            if (deadline && now.getTime() >= deadline) {\n                const error = new googleError_1.GoogleError(`Total timeout of API ${apiName} exceeded ${retry.backoffSettings.totalTimeoutMillis} milliseconds ${err ? `retrying error ${err} ` : ''} before any response was received.`);\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\n                callback(error);\n                return;\n            }\n            if (retries && retries >= maxRetries) {\n                const error = new googleError_1.GoogleError('Exceeded maximum number of retries ' +\n                    (err ? `retrying error ${err} ` : '') +\n                    'before any response was received');\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\n                callback(error);\n                return;\n            }\n            retries++;\n            let lastError = err;\n            const toCall = (0, timeout_1.addTimeoutArg)(func, timeout, otherArgs);\n            canceller = toCall(argument, (err, response, next, rawResponse) => {\n                // Save only the error before deadline exceeded\n                if (err && err.code !== 4) {\n                    lastError = err;\n                }\n                if (!err) {\n                    callback(null, response, next, rawResponse);\n                    return;\n                }\n                canceller = null;\n                if (retry.retryCodes.length > 0 &&\n                    retry.retryCodes.indexOf(err.code) < 0) {\n                    err.note =\n                        'Exception occurred in retry method that was ' +\n                            'not classified as transient';\n                    callback(err);\n                }\n                else {\n                    const toSleep = Math.random() * delay;\n                    timeoutId = setTimeout(() => {\n                        now = new Date();\n                        delay = Math.min(delay * delayMult, maxDelay);\n                        const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n                        const rpcTimeout = maxTimeout ? maxTimeout : 0;\n                        const newDeadline = deadline ? deadline - now.getTime() : 0;\n                        timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n                        repeat(lastError);\n                    }, toSleep);\n                }\n            });\n            if (canceller instanceof Promise) {\n                canceller.catch(err => {\n                    callback(new googleError_1.GoogleError(err));\n                });\n            }\n        }\n        if (maxRetries && deadline) {\n            const error = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' +\n                'in backoffSettings.');\n            error.code = status_1.Status.INVALID_ARGUMENT;\n            callback(error);\n        }\n        else {\n            repeat();\n        }\n        return {\n            cancel() {\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n                if (canceller) {\n                    canceller.cancel();\n                }\n                else {\n                    const error = new googleError_1.GoogleError('cancelled');\n                    error.code = status_1.Status.CANCELLED;\n                    callback(error);\n                }\n            },\n        };\n    };\n}\n//# sourceMappingURL=retries.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}