{"ast":null,"code":"/*! firebase-admin v12.7.0 */\n\"use strict\";\n\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EmailPrivacyAuthConfig = exports.PasswordPolicyAuthConfig = exports.RecaptchaAuthConfig = exports.SmsRegionsAuthConfig = exports.OIDCConfig = exports.SAMLConfig = exports.EmailSignInConfig = exports.validateTestPhoneNumbers = exports.MultiFactorAuthConfig = exports.MAXIMUM_TEST_PHONE_NUMBERS = void 0;\nconst validator = require(\"../utils/validator\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst error_1 = require(\"../utils/error\");\n/** A maximum of 10 test phone number / code pairs can be configured. */\nexports.MAXIMUM_TEST_PHONE_NUMBERS = 10;\n/** Client Auth factor type to server auth factor type mapping. */\nconst AUTH_FACTOR_CLIENT_TO_SERVER_TYPE = {\n  phone: 'PHONE_SMS'\n};\n/** Server Auth factor type to client auth factor type mapping. */\nconst AUTH_FACTOR_SERVER_TO_CLIENT_TYPE = Object.keys(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE).reduce((res, key) => {\n  res[AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[key]] = key;\n  return res;\n}, {});\n/**\n * Defines the multi-factor config class used to convert client side MultiFactorConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass MultiFactorAuthConfig {\n  /**\n   * Static method to convert a client side request to a MultiFactorAuthServerConfig.\n   * Throws an error if validation fails.\n   *\n   * @param options - The options object to convert to a server request.\n   * @returns The resulting server request.\n   * @internal\n   */\n  static buildServerRequest(options) {\n    const request = {};\n    MultiFactorAuthConfig.validate(options);\n    if (Object.prototype.hasOwnProperty.call(options, 'state')) {\n      request.state = options.state;\n    }\n    if (Object.prototype.hasOwnProperty.call(options, 'factorIds')) {\n      (options.factorIds || []).forEach(factorId => {\n        if (typeof request.enabledProviders === 'undefined') {\n          request.enabledProviders = [];\n        }\n        request.enabledProviders.push(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId]);\n      });\n      // In case an empty array is passed. Ensure it gets populated so the array is cleared.\n      if (options.factorIds && options.factorIds.length === 0) {\n        request.enabledProviders = [];\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, 'providerConfigs')) {\n      request.providerConfigs = options.providerConfigs;\n    }\n    return request;\n  }\n  /**\n   * Validates the MultiFactorConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   */\n  static validate(options) {\n    const validKeys = {\n      state: true,\n      factorIds: true,\n      providerConfigs: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig\" must be a non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid MultiFactorConfig parameter.`);\n      }\n    }\n    // Validate content.\n    if (typeof options.state !== 'undefined' && options.state !== 'ENABLED' && options.state !== 'DISABLED') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.state\" must be either \"ENABLED\" or \"DISABLED\".');\n    }\n    if (typeof options.factorIds !== 'undefined') {\n      if (!validator.isArray(options.factorIds)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.factorIds\" must be an array of valid \"AuthFactorTypes\".');\n      }\n      // Validate content of array.\n      options.factorIds.forEach(factorId => {\n        if (typeof AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId] === 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${factorId}\" is not a valid \"AuthFactorType\".`);\n        }\n      });\n    }\n    if (typeof options.providerConfigs !== 'undefined') {\n      if (!validator.isArray(options.providerConfigs)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.providerConfigs\" must be an array of valid \"MultiFactorProviderConfig.\"');\n      }\n      //Validate content of array.\n      options.providerConfigs.forEach(multiFactorProviderConfig => {\n        if (typeof multiFactorProviderConfig === 'undefined' || !validator.isObject(multiFactorProviderConfig)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${multiFactorProviderConfig}\" is not a valid \"MultiFactorProviderConfig\" type.`);\n        }\n        const validProviderConfigKeys = {\n          state: true,\n          totpProviderConfig: true\n        };\n        for (const key in multiFactorProviderConfig) {\n          if (!(key in validProviderConfigKeys)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid ProviderConfig parameter.`);\n          }\n        }\n        if (typeof multiFactorProviderConfig.state === 'undefined' || multiFactorProviderConfig.state !== 'ENABLED' && multiFactorProviderConfig.state !== 'DISABLED') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.providerConfigs.state\" must be either \"ENABLED\" or \"DISABLED\".');\n        }\n        // Since TOTP is the only provider config available right now, not defining it will lead into an error\n        if (typeof multiFactorProviderConfig.totpProviderConfig === 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.providerConfigs.totpProviderConfig\" must be defined.');\n        }\n        const validTotpProviderConfigKeys = {\n          adjacentIntervals: true\n        };\n        for (const key in multiFactorProviderConfig.totpProviderConfig) {\n          if (!(key in validTotpProviderConfigKeys)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid TotpProviderConfig parameter.`);\n          }\n        }\n        const adjIntervals = multiFactorProviderConfig.totpProviderConfig.adjacentIntervals;\n        if (typeof adjIntervals !== 'undefined' && (!Number.isInteger(adjIntervals) || adjIntervals < 0 || adjIntervals > 10)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"MultiFactorConfig.providerConfigs.totpProviderConfig.adjacentIntervals\" must' + ' be a valid number between 0 and 10 (both inclusive).');\n        }\n      });\n    }\n  }\n  /**\n   * The MultiFactorAuthConfig constructor.\n   *\n   * @param response - The server side response used to initialize the\n   *     MultiFactorAuthConfig object.\n   * @constructor\n   * @internal\n   */\n  constructor(response) {\n    if (typeof response.state === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');\n    }\n    this.state = response.state;\n    this.factorIds = [];\n    (response.enabledProviders || []).forEach(enabledProvider => {\n      // Ignore unsupported types. It is possible the current admin SDK version is\n      // not up to date and newer backend types are supported.\n      if (typeof AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider] !== 'undefined') {\n        this.factorIds.push(AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider]);\n      }\n    });\n    this.providerConfigs = [];\n    (response.providerConfigs || []).forEach(providerConfig => {\n      if (typeof providerConfig !== 'undefined') {\n        if (typeof providerConfig.state === 'undefined' || typeof providerConfig.totpProviderConfig === 'undefined' || typeof providerConfig.totpProviderConfig.adjacentIntervals !== 'undefined' && typeof providerConfig.totpProviderConfig.adjacentIntervals !== 'number') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');\n        }\n        this.providerConfigs.push(providerConfig);\n      }\n    });\n  }\n  /** Converts MultiFactorConfig to JSON object\n   * @returns The plain object representation of the multi-factor config instance. */\n  toJSON() {\n    return {\n      state: this.state,\n      factorIds: this.factorIds,\n      providerConfigs: this.providerConfigs\n    };\n  }\n}\nexports.MultiFactorAuthConfig = MultiFactorAuthConfig;\n/**\n * Validates the provided map of test phone number / code pairs.\n * @param testPhoneNumbers - The phone number / code pairs to validate.\n */\nfunction validateTestPhoneNumbers(testPhoneNumbers) {\n  if (!validator.isObject(testPhoneNumbers)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"testPhoneNumbers\" must be a map of phone number / code pairs.');\n  }\n  if (Object.keys(testPhoneNumbers).length > exports.MAXIMUM_TEST_PHONE_NUMBERS) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);\n  }\n  for (const phoneNumber in testPhoneNumbers) {\n    // Validate phone number.\n    if (!validator.isPhoneNumber(phoneNumber)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `\"${phoneNumber}\" is not a valid E.164 standard compliant phone number.`);\n    }\n    // Validate code.\n    if (!validator.isString(testPhoneNumbers[phoneNumber]) || !/^[\\d]{6}$/.test(testPhoneNumbers[phoneNumber])) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `\"${testPhoneNumbers[phoneNumber]}\" is not a valid 6 digit code string.`);\n    }\n  }\n}\nexports.validateTestPhoneNumbers = validateTestPhoneNumbers;\n/**\n * Defines the email sign-in config class used to convert client side EmailSignInConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass EmailSignInConfig {\n  /**\n   * Static method to convert a client side request to a EmailSignInConfigServerRequest.\n   * Throws an error if validation fails.\n   *\n   * @param options - The options object to convert to a server request.\n   * @returns The resulting server request.\n   * @internal\n   */\n  static buildServerRequest(options) {\n    const request = {};\n    EmailSignInConfig.validate(options);\n    if (Object.prototype.hasOwnProperty.call(options, 'enabled')) {\n      request.allowPasswordSignup = options.enabled;\n    }\n    if (Object.prototype.hasOwnProperty.call(options, 'passwordRequired')) {\n      request.enableEmailLinkSignin = !options.passwordRequired;\n    }\n    return request;\n  }\n  /**\n   * Validates the EmailSignInConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   */\n  static validate(options) {\n    // TODO: Validate the request.\n    const validKeys = {\n      enabled: true,\n      passwordRequired: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig\" must be a non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `\"${key}\" is not a valid EmailSignInConfig parameter.`);\n      }\n    }\n    // Validate content.\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.enabled\" must be a boolean.');\n    }\n    if (typeof options.passwordRequired !== 'undefined' && !validator.isBoolean(options.passwordRequired)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.passwordRequired\" must be a boolean.');\n    }\n  }\n  /**\n   * The EmailSignInConfig constructor.\n   *\n   * @param response - The server side response used to initialize the\n   *     EmailSignInConfig object.\n   * @constructor\n   */\n  constructor(response) {\n    if (typeof response.allowPasswordSignup === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid email sign-in configuration response');\n    }\n    this.enabled = response.allowPasswordSignup;\n    this.passwordRequired = !response.enableEmailLinkSignin;\n  }\n  /** @returns The plain object representation of the email sign-in config. */\n  toJSON() {\n    return {\n      enabled: this.enabled,\n      passwordRequired: this.passwordRequired\n    };\n  }\n}\nexports.EmailSignInConfig = EmailSignInConfig;\n/**\n * Defines the SAMLConfig class used to convert a client side configuration to its\n * server side representation.\n *\n * @internal\n */\nclass SAMLConfig {\n  /**\n   * Converts a client side request to a SAMLConfigServerRequest which is the format\n   * accepted by the backend server.\n   * Throws an error if validation fails. If the request is not a SAMLConfig request,\n   * returns null.\n   *\n   * @param options - The options object to convert to a server request.\n   * @param ignoreMissingFields - Whether to ignore missing fields.\n   * @returns The resulting server request or null if not valid.\n   */\n  static buildServerRequest(options) {\n    let ignoreMissingFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);\n    if (!makeRequest) {\n      return null;\n    }\n    const request = {};\n    // Validate options.\n    SAMLConfig.validate(options, ignoreMissingFields);\n    request.enabled = options.enabled;\n    request.displayName = options.displayName;\n    // IdP config.\n    if (options.idpEntityId || options.ssoURL || options.x509Certificates) {\n      request.idpConfig = {\n        idpEntityId: options.idpEntityId,\n        ssoUrl: options.ssoURL,\n        signRequest: options.enableRequestSigning,\n        idpCertificates: typeof options.x509Certificates === 'undefined' ? undefined : []\n      };\n      if (options.x509Certificates) {\n        for (const cert of options.x509Certificates || []) {\n          request.idpConfig.idpCertificates.push({\n            x509Certificate: cert\n          });\n        }\n      }\n    }\n    // RP config.\n    if (options.callbackURL || options.rpEntityId) {\n      request.spConfig = {\n        spEntityId: options.rpEntityId,\n        callbackUri: options.callbackURL\n      };\n    }\n    return request;\n  }\n  /**\n   * Returns the provider ID corresponding to the resource name if available.\n   *\n   * @param resourceName - The server side resource name.\n   * @returns The provider ID corresponding to the resource, null otherwise.\n   */\n  static getProviderIdFromResourceName(resourceName) {\n    // name is of form projects/project1/inboundSamlConfigs/providerId1\n    const matchProviderRes = resourceName.match(/\\/inboundSamlConfigs\\/(saml\\..*)$/);\n    if (!matchProviderRes || matchProviderRes.length < 2) {\n      return null;\n    }\n    return matchProviderRes[1];\n  }\n  /**\n   * @param providerId - The provider ID to check.\n   * @returns Whether the provider ID corresponds to a SAML provider.\n   */\n  static isProviderId(providerId) {\n    return validator.isNonEmptyString(providerId) && providerId.indexOf('saml.') === 0;\n  }\n  /**\n   * Validates the SAMLConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   * @param ignoreMissingFields - Whether to ignore missing fields.\n   */\n  static validate(options) {\n    let ignoreMissingFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const validKeys = {\n      enabled: true,\n      displayName: true,\n      providerId: true,\n      idpEntityId: true,\n      ssoURL: true,\n      x509Certificates: true,\n      rpEntityId: true,\n      callbackURL: true,\n      enableRequestSigning: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig\" must be a valid non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SAML config parameter.`);\n      }\n    }\n    // Required fields.\n    if (validator.isNonEmptyString(options.providerId)) {\n      if (options.providerId.indexOf('saml.') !== 0) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n      }\n    } else if (!ignoreMissingFields) {\n      // providerId is required and not provided correctly.\n      throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n    }\n    if (!(ignoreMissingFields && typeof options.idpEntityId === 'undefined') && !validator.isNonEmptyString(options.idpEntityId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.idpEntityId\" must be a valid non-empty string.');\n    }\n    if (!(ignoreMissingFields && typeof options.ssoURL === 'undefined') && !validator.isURL(options.ssoURL)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.ssoURL\" must be a valid URL string.');\n    }\n    if (!(ignoreMissingFields && typeof options.rpEntityId === 'undefined') && !validator.isNonEmptyString(options.rpEntityId)) {\n      throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.rpEntityId\" must be a valid non-empty string.');\n    }\n    if (!(ignoreMissingFields && typeof options.callbackURL === 'undefined') && !validator.isURL(options.callbackURL)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.callbackURL\" must be a valid URL string.');\n    }\n    if (!(ignoreMissingFields && typeof options.x509Certificates === 'undefined') && !validator.isArray(options.x509Certificates)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n    }\n    (options.x509Certificates || []).forEach(cert => {\n      if (!validator.isNonEmptyString(cert)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n      }\n    });\n    if (typeof options.enableRequestSigning !== 'undefined' && !validator.isBoolean(options.enableRequestSigning)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enableRequestSigning\" must be a boolean.');\n    }\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enabled\" must be a boolean.');\n    }\n    if (typeof options.displayName !== 'undefined' && !validator.isString(options.displayName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.displayName\" must be a valid string.');\n    }\n  }\n  /**\n   * The SAMLConfig constructor.\n   *\n   * @param response - The server side response used to initialize the SAMLConfig object.\n   * @constructor\n   */\n  constructor(response) {\n    if (!response || !response.idpConfig || !response.idpConfig.idpEntityId || !response.idpConfig.ssoUrl || !response.spConfig || !response.spConfig.spEntityId || !response.name || !(validator.isString(response.name) && SAMLConfig.getProviderIdFromResourceName(response.name))) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n    const providerId = SAMLConfig.getProviderIdFromResourceName(response.name);\n    if (!providerId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n    this.providerId = providerId;\n    // RP config.\n    this.rpEntityId = response.spConfig.spEntityId;\n    this.callbackURL = response.spConfig.callbackUri;\n    // IdP config.\n    this.idpEntityId = response.idpConfig.idpEntityId;\n    this.ssoURL = response.idpConfig.ssoUrl;\n    this.enableRequestSigning = !!response.idpConfig.signRequest;\n    const x509Certificates = [];\n    for (const cert of response.idpConfig.idpCertificates || []) {\n      if (cert.x509Certificate) {\n        x509Certificates.push(cert.x509Certificate);\n      }\n    }\n    this.x509Certificates = x509Certificates;\n    // When enabled is undefined, it takes its default value of false.\n    this.enabled = !!response.enabled;\n    this.displayName = response.displayName;\n  }\n  /** @returns The plain object representation of the SAMLConfig. */\n  toJSON() {\n    return {\n      enabled: this.enabled,\n      displayName: this.displayName,\n      providerId: this.providerId,\n      idpEntityId: this.idpEntityId,\n      ssoURL: this.ssoURL,\n      x509Certificates: (0, deep_copy_1.deepCopy)(this.x509Certificates),\n      rpEntityId: this.rpEntityId,\n      callbackURL: this.callbackURL,\n      enableRequestSigning: this.enableRequestSigning\n    };\n  }\n}\nexports.SAMLConfig = SAMLConfig;\n/**\n * Defines the OIDCConfig class used to convert a client side configuration to its\n * server side representation.\n *\n * @internal\n */\nclass OIDCConfig {\n  /**\n   * Converts a client side request to a OIDCConfigServerRequest which is the format\n   * accepted by the backend server.\n   * Throws an error if validation fails. If the request is not a OIDCConfig request,\n   * returns null.\n   *\n   * @param options - The options object to convert to a server request.\n   * @param ignoreMissingFields - Whether to ignore missing fields.\n   * @returns The resulting server request or null if not valid.\n   */\n  static buildServerRequest(options) {\n    let ignoreMissingFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);\n    if (!makeRequest) {\n      return null;\n    }\n    const request = {};\n    // Validate options.\n    OIDCConfig.validate(options, ignoreMissingFields);\n    request.enabled = options.enabled;\n    request.displayName = options.displayName;\n    request.issuer = options.issuer;\n    request.clientId = options.clientId;\n    if (typeof options.clientSecret !== 'undefined') {\n      request.clientSecret = options.clientSecret;\n    }\n    if (typeof options.responseType !== 'undefined') {\n      request.responseType = options.responseType;\n    }\n    return request;\n  }\n  /**\n   * Returns the provider ID corresponding to the resource name if available.\n   *\n   * @param resourceName - The server side resource name\n   * @returns The provider ID corresponding to the resource, null otherwise.\n   */\n  static getProviderIdFromResourceName(resourceName) {\n    // name is of form projects/project1/oauthIdpConfigs/providerId1\n    const matchProviderRes = resourceName.match(/\\/oauthIdpConfigs\\/(oidc\\..*)$/);\n    if (!matchProviderRes || matchProviderRes.length < 2) {\n      return null;\n    }\n    return matchProviderRes[1];\n  }\n  /**\n   * @param providerId - The provider ID to check.\n   * @returns Whether the provider ID corresponds to an OIDC provider.\n   */\n  static isProviderId(providerId) {\n    return validator.isNonEmptyString(providerId) && providerId.indexOf('oidc.') === 0;\n  }\n  /**\n   * Validates the OIDCConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   * @param ignoreMissingFields - Whether to ignore missing fields.\n   */\n  static validate(options) {\n    let ignoreMissingFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const validKeys = {\n      enabled: true,\n      displayName: true,\n      providerId: true,\n      clientId: true,\n      issuer: true,\n      clientSecret: true,\n      responseType: true\n    };\n    const validResponseTypes = {\n      idToken: true,\n      code: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig\" must be a valid non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid OIDC config parameter.`);\n      }\n    }\n    // Required fields.\n    if (validator.isNonEmptyString(options.providerId)) {\n      if (options.providerId.indexOf('oidc.') !== 0) {\n        throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n      }\n    } else if (!ignoreMissingFields) {\n      throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n    }\n    if (!(ignoreMissingFields && typeof options.clientId === 'undefined') && !validator.isNonEmptyString(options.clientId)) {\n      throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '\"OIDCAuthProviderConfig.clientId\" must be a valid non-empty string.');\n    }\n    if (!(ignoreMissingFields && typeof options.issuer === 'undefined') && !validator.isURL(options.issuer)) {\n      throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.issuer\" must be a valid URL string.');\n    }\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.enabled\" must be a boolean.');\n    }\n    if (typeof options.displayName !== 'undefined' && !validator.isString(options.displayName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.displayName\" must be a valid string.');\n    }\n    if (typeof options.clientSecret !== 'undefined' && !validator.isNonEmptyString(options.clientSecret)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.clientSecret\" must be a valid string.');\n    }\n    if (validator.isNonNullObject(options.responseType) && typeof options.responseType !== 'undefined') {\n      Object.keys(options.responseType).forEach(key => {\n        if (!(key in validResponseTypes)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid OAuthResponseType parameter.`);\n        }\n      });\n      const idToken = options.responseType.idToken;\n      if (typeof idToken !== 'undefined' && !validator.isBoolean(idToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.idToken\" must be a boolean.');\n      }\n      const code = options.responseType.code;\n      if (typeof code !== 'undefined') {\n        if (!validator.isBoolean(code)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.code\" must be a boolean.');\n        }\n        // If code flow is enabled, client secret must be provided.\n        if (code && typeof options.clientSecret === 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET, 'The OAuth configuration client secret is required to enable OIDC code flow.');\n        }\n      }\n      const allKeys = Object.keys(options.responseType).length;\n      const enabledCount = Object.values(options.responseType).filter(Boolean).length;\n      // Only one of OAuth response types can be set to true.\n      if (allKeys > 1 && enabledCount !== 1) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE, 'Only exactly one OAuth responseType should be set to true.');\n      }\n    }\n  }\n  /**\n   * The OIDCConfig constructor.\n   *\n   * @param response - The server side response used to initialize the OIDCConfig object.\n   * @constructor\n   */\n  constructor(response) {\n    if (!response || !response.issuer || !response.clientId || !response.name || !(validator.isString(response.name) && OIDCConfig.getProviderIdFromResourceName(response.name))) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid OIDC configuration response');\n    }\n    const providerId = OIDCConfig.getProviderIdFromResourceName(response.name);\n    if (!providerId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n    this.providerId = providerId;\n    this.clientId = response.clientId;\n    this.issuer = response.issuer;\n    // When enabled is undefined, it takes its default value of false.\n    this.enabled = !!response.enabled;\n    this.displayName = response.displayName;\n    if (typeof response.clientSecret !== 'undefined') {\n      this.clientSecret = response.clientSecret;\n    }\n    if (typeof response.responseType !== 'undefined') {\n      this.responseType = response.responseType;\n    }\n  }\n  /** @returns The plain object representation of the OIDCConfig. */\n  toJSON() {\n    return {\n      enabled: this.enabled,\n      displayName: this.displayName,\n      providerId: this.providerId,\n      issuer: this.issuer,\n      clientId: this.clientId,\n      clientSecret: (0, deep_copy_1.deepCopy)(this.clientSecret),\n      responseType: (0, deep_copy_1.deepCopy)(this.responseType)\n    };\n  }\n}\nexports.OIDCConfig = OIDCConfig;\n/**\n * Defines the SMSRegionConfig class used for validation.\n *\n * @internal\n */\nclass SmsRegionsAuthConfig {\n  static validate(options) {\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig\" must be a non-null object.');\n    }\n    const validKeys = {\n      allowlistOnly: true,\n      allowByDefault: true\n    };\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig parameter.`);\n      }\n    }\n    // validate mutual exclusiveness of allowByDefault and allowlistOnly\n    if (typeof options.allowByDefault !== 'undefined' && typeof options.allowlistOnly !== 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'SmsRegionConfig cannot have both \"allowByDefault\" and \"allowlistOnly\" parameters.');\n    }\n    // validation for allowByDefault type\n    if (typeof options.allowByDefault !== 'undefined') {\n      const allowByDefaultValidKeys = {\n        disallowedRegions: true\n      };\n      for (const key in options.allowByDefault) {\n        if (!(key in allowByDefaultValidKeys)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig.allowByDefault parameter.`);\n        }\n      }\n      // disallowedRegion can be empty.\n      if (typeof options.allowByDefault.disallowedRegions !== 'undefined' && !validator.isArray(options.allowByDefault.disallowedRegions)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig.allowByDefault.disallowedRegions\" must be a valid string array.');\n      }\n    }\n    if (typeof options.allowlistOnly !== 'undefined') {\n      const allowListOnlyValidKeys = {\n        allowedRegions: true\n      };\n      for (const key in options.allowlistOnly) {\n        if (!(key in allowListOnlyValidKeys)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig.allowlistOnly parameter.`);\n        }\n      }\n      // allowedRegions can be empty\n      if (typeof options.allowlistOnly.allowedRegions !== 'undefined' && !validator.isArray(options.allowlistOnly.allowedRegions)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig.allowlistOnly.allowedRegions\" must be a valid string array.');\n      }\n    }\n  }\n}\nexports.SmsRegionsAuthConfig = SmsRegionsAuthConfig;\n/**\n * Defines the recaptcha config class used to convert client side RecaptchaConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass RecaptchaAuthConfig {\n  /**\n   * The RecaptchaAuthConfig constructor.\n   *\n   * @param response - The server side response used to initialize the\n   *     RecaptchaAuthConfig object.\n   * @constructor\n   * @internal\n   */\n  constructor(response) {\n    const filteredResponse = Object.fromEntries(Object.entries(response).filter(_ref => {\n      let [, value] = _ref;\n      return value !== undefined;\n    }));\n    // Explicitly map the 'tollFraudManagedRules' to 'smsTollFraudManagedRules'\n    if (filteredResponse.tollFraudManagedRules !== undefined) {\n      this.smsTollFraudManagedRules = filteredResponse.tollFraudManagedRules;\n      delete filteredResponse.tollFraudManagedRules; // Remove it if necessary\n    }\n    // Assign the remaining properties directly\n    Object.assign(this, filteredResponse);\n  }\n  /**\n   * Builds a server request object from the client-side RecaptchaConfig.\n   * Converts client-side fields to their server-side equivalents.\n   *\n   * @param options - The client-side RecaptchaConfig object.\n   * @returns The server-side RecaptchaAuthServerConfig object.\n   */\n  static buildServerRequest(options) {\n    RecaptchaAuthConfig.validate(options); // Validate options before building request\n    const request = {};\n    if (typeof options.emailPasswordEnforcementState !== 'undefined') {\n      request.emailPasswordEnforcementState = options.emailPasswordEnforcementState;\n    }\n    if (typeof options.phoneEnforcementState !== 'undefined') {\n      request.phoneEnforcementState = options.phoneEnforcementState;\n    }\n    if (typeof options.managedRules !== 'undefined') {\n      request.managedRules = options.managedRules;\n    }\n    if (typeof options.recaptchaKeys !== 'undefined') {\n      request.recaptchaKeys = options.recaptchaKeys;\n    }\n    if (typeof options.useAccountDefender !== 'undefined') {\n      request.useAccountDefender = options.useAccountDefender;\n    }\n    if (typeof options.useSmsBotScore !== 'undefined') {\n      request.useSmsBotScore = options.useSmsBotScore;\n    }\n    if (typeof options.useSmsTollFraudProtection !== 'undefined') {\n      request.useSmsTollFraudProtection = options.useSmsTollFraudProtection;\n    }\n    if (typeof options.smsTollFraudManagedRules !== 'undefined') {\n      request.tollFraudManagedRules = options.smsTollFraudManagedRules; // Map client-side field to server-side\n    }\n\n    return request;\n  }\n  /**\n   * Validates the RecaptchaConfig options object. Throws an error on failure.\n   * @param options - The options object to validate.\n   */\n  static validate(options) {\n    const validKeys = {\n      emailPasswordEnforcementState: true,\n      phoneEnforcementState: true,\n      managedRules: true,\n      recaptchaKeys: true,\n      useAccountDefender: true,\n      useSmsBotScore: true,\n      useSmsTollFraudProtection: true,\n      smsTollFraudManagedRules: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig\" must be a non-null object.');\n    }\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid RecaptchaConfig parameter.`);\n      }\n    }\n    // Validation\n    if (typeof options.emailPasswordEnforcementState !== 'undefined') {\n      if (!validator.isNonEmptyString(options.emailPasswordEnforcementState)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"RecaptchaConfig.emailPasswordEnforcementState\" must be a valid non-empty string.');\n      }\n      if (options.emailPasswordEnforcementState !== 'OFF' && options.emailPasswordEnforcementState !== 'AUDIT' && options.emailPasswordEnforcementState !== 'ENFORCE') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.emailPasswordEnforcementState\" must be either \"OFF\", \"AUDIT\" or \"ENFORCE\".');\n      }\n    }\n    if (typeof options.phoneEnforcementState !== 'undefined') {\n      if (!validator.isNonEmptyString(options.phoneEnforcementState)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"RecaptchaConfig.phoneEnforcementState\" must be a valid non-empty string.');\n      }\n      if (options.phoneEnforcementState !== 'OFF' && options.phoneEnforcementState !== 'AUDIT' && options.phoneEnforcementState !== 'ENFORCE') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.phoneEnforcementState\" must be either \"OFF\", \"AUDIT\" or \"ENFORCE\".');\n      }\n    }\n    if (typeof options.managedRules !== 'undefined') {\n      // Validate array\n      if (!validator.isArray(options.managedRules)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.managedRules\" must be an array of valid \"RecaptchaManagedRule\".');\n      }\n      // Validate each rule of the array\n      options.managedRules.forEach(managedRule => {\n        RecaptchaAuthConfig.validateManagedRule(managedRule);\n      });\n    }\n    if (typeof options.useAccountDefender !== 'undefined') {\n      if (!validator.isBoolean(options.useAccountDefender)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.useAccountDefender\" must be a boolean value\".');\n      }\n    }\n    if (typeof options.useSmsBotScore !== 'undefined') {\n      if (!validator.isBoolean(options.useSmsBotScore)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.useSmsBotScore\" must be a boolean value\".');\n      }\n    }\n    if (typeof options.useSmsTollFraudProtection !== 'undefined') {\n      if (!validator.isBoolean(options.useSmsTollFraudProtection)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.useSmsTollFraudProtection\" must be a boolean value\".');\n      }\n    }\n    if (typeof options.smsTollFraudManagedRules !== 'undefined') {\n      // Validate array\n      if (!validator.isArray(options.smsTollFraudManagedRules)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.smsTollFraudManagedRules\" must be an array of valid \"RecaptchaTollFraudManagedRule\".');\n      }\n      // Validate each rule of the array\n      options.smsTollFraudManagedRules.forEach(tollFraudManagedRule => {\n        RecaptchaAuthConfig.validateTollFraudManagedRule(tollFraudManagedRule);\n      });\n    }\n  }\n  /**\n   * Validate each element in ManagedRule array\n   * @param options - The options object to validate.\n   */\n  static validateManagedRule(options) {\n    const validKeys = {\n      endScore: true,\n      action: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaManagedRule\" must be a non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid RecaptchaManagedRule parameter.`);\n      }\n    }\n    // Validate content.\n    if (typeof options.action !== 'undefined' && options.action !== 'BLOCK') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaManagedRule.action\" must be \"BLOCK\".');\n    }\n  }\n  /**\n   * Validate each element in TollFraudManagedRule array\n   * @param options - The options object to validate.\n   */\n  static validateTollFraudManagedRule(options) {\n    const validKeys = {\n      startScore: true,\n      action: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaTollFraudManagedRule\" must be a non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid RecaptchaTollFraudManagedRule parameter.`);\n      }\n    }\n    // Validate content.\n    if (typeof options.action !== 'undefined' && options.action !== 'BLOCK') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaTollFraudManagedRule.action\" must be \"BLOCK\".');\n    }\n  }\n}\nexports.RecaptchaAuthConfig = RecaptchaAuthConfig;\n/**\n * Defines the password policy config class used to convert client side PasswordPolicyConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass PasswordPolicyAuthConfig {\n  /**\n   * Static method to convert a client side request to a PasswordPolicyAuthServerConfig.\n   * Throws an error if validation fails.\n   *\n   * @param options - The options object to convert to a server request.\n   * @returns The resulting server request.\n   * @internal\n   */\n  static buildServerRequest(options) {\n    const request = {};\n    PasswordPolicyAuthConfig.validate(options);\n    if (Object.prototype.hasOwnProperty.call(options, 'enforcementState')) {\n      request.passwordPolicyEnforcementState = options.enforcementState;\n    }\n    request.forceUpgradeOnSignin = false;\n    if (Object.prototype.hasOwnProperty.call(options, 'forceUpgradeOnSignin')) {\n      request.forceUpgradeOnSignin = options.forceUpgradeOnSignin;\n    }\n    const constraintsRequest = {\n      containsUppercaseCharacter: false,\n      containsLowercaseCharacter: false,\n      containsNonAlphanumericCharacter: false,\n      containsNumericCharacter: false,\n      minPasswordLength: 6,\n      maxPasswordLength: 4096\n    };\n    request.passwordPolicyVersions = [];\n    if (Object.prototype.hasOwnProperty.call(options, 'constraints')) {\n      if (options) {\n        if (options.constraints?.requireUppercase !== undefined) {\n          constraintsRequest.containsUppercaseCharacter = options.constraints.requireUppercase;\n        }\n        if (options.constraints?.requireLowercase !== undefined) {\n          constraintsRequest.containsLowercaseCharacter = options.constraints.requireLowercase;\n        }\n        if (options.constraints?.requireNonAlphanumeric !== undefined) {\n          constraintsRequest.containsNonAlphanumericCharacter = options.constraints.requireNonAlphanumeric;\n        }\n        if (options.constraints?.requireNumeric !== undefined) {\n          constraintsRequest.containsNumericCharacter = options.constraints.requireNumeric;\n        }\n        if (options.constraints?.minLength !== undefined) {\n          constraintsRequest.minPasswordLength = options.constraints.minLength;\n        }\n        if (options.constraints?.maxLength !== undefined) {\n          constraintsRequest.maxPasswordLength = options.constraints.maxLength;\n        }\n      }\n    }\n    request.passwordPolicyVersions.push({\n      customStrengthOptions: constraintsRequest\n    });\n    return request;\n  }\n  /**\n   * Validates the PasswordPolicyConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   * @internal\n   */\n  static validate(options) {\n    const validKeys = {\n      enforcementState: true,\n      forceUpgradeOnSignin: true,\n      constraints: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig\" must be a non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid PasswordPolicyConfig parameter.`);\n      }\n    }\n    // Validate content.\n    if (typeof options.enforcementState === 'undefined' || !(options.enforcementState === 'ENFORCE' || options.enforcementState === 'OFF')) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.enforcementState\" must be either \"ENFORCE\" or \"OFF\".');\n    }\n    if (typeof options.forceUpgradeOnSignin !== 'undefined') {\n      if (!validator.isBoolean(options.forceUpgradeOnSignin)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.forceUpgradeOnSignin\" must be a boolean.');\n      }\n    }\n    if (typeof options.constraints !== 'undefined') {\n      if (options.enforcementState === 'ENFORCE' && !validator.isNonNullObject(options.constraints)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints\" must be a non-empty object.');\n      }\n      const validCharKeys = {\n        requireUppercase: true,\n        requireLowercase: true,\n        requireNumeric: true,\n        requireNonAlphanumeric: true,\n        minLength: true,\n        maxLength: true\n      };\n      // Check for unsupported  attributes.\n      for (const key in options.constraints) {\n        if (!(key in validCharKeys)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid PasswordPolicyConfig.constraints parameter.`);\n        }\n      }\n      if (typeof options.constraints.requireUppercase !== 'undefined' && !validator.isBoolean(options.constraints.requireUppercase)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireUppercase\" must be a boolean.');\n      }\n      if (typeof options.constraints.requireLowercase !== 'undefined' && !validator.isBoolean(options.constraints.requireLowercase)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireLowercase\" must be a boolean.');\n      }\n      if (typeof options.constraints.requireNonAlphanumeric !== 'undefined' && !validator.isBoolean(options.constraints.requireNonAlphanumeric)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireNonAlphanumeric\"' + ' must be a boolean.');\n      }\n      if (typeof options.constraints.requireNumeric !== 'undefined' && !validator.isBoolean(options.constraints.requireNumeric)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireNumeric\" must be a boolean.');\n      }\n      if (typeof options.constraints.minLength === 'undefined') {\n        options.constraints.minLength = 6;\n      } else if (!validator.isNumber(options.constraints.minLength)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.minLength\" must be a number.');\n      } else {\n        if (!(options.constraints.minLength >= 6 && options.constraints.minLength <= 30)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.minLength\"' + ' must be an integer between 6 and 30, inclusive.');\n        }\n      }\n      if (typeof options.constraints.maxLength === 'undefined') {\n        options.constraints.maxLength = 4096;\n      } else if (!validator.isNumber(options.constraints.maxLength)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.maxLength\" must be a number.');\n      } else {\n        if (!(options.constraints.maxLength >= options.constraints.minLength && options.constraints.maxLength <= 4096)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.maxLength\"' + ' must be greater than or equal to minLength and at max 4096.');\n        }\n      }\n    } else {\n      if (options.enforcementState === 'ENFORCE') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints\" must be defined.');\n      }\n    }\n  }\n  /**\n   * The PasswordPolicyAuthConfig constructor.\n   *\n   * @param response - The server side response used to initialize the\n   *     PasswordPolicyAuthConfig object.\n   * @constructor\n   * @internal\n   */\n  constructor(response) {\n    if (typeof response.passwordPolicyEnforcementState === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid password policy configuration response');\n    }\n    this.enforcementState = response.passwordPolicyEnforcementState;\n    let constraintsResponse = {};\n    if (typeof response.passwordPolicyVersions !== 'undefined') {\n      (response.passwordPolicyVersions || []).forEach(policyVersion => {\n        constraintsResponse = {\n          requireLowercase: policyVersion.customStrengthOptions?.containsLowercaseCharacter,\n          requireUppercase: policyVersion.customStrengthOptions?.containsUppercaseCharacter,\n          requireNonAlphanumeric: policyVersion.customStrengthOptions?.containsNonAlphanumericCharacter,\n          requireNumeric: policyVersion.customStrengthOptions?.containsNumericCharacter,\n          minLength: policyVersion.customStrengthOptions?.minPasswordLength,\n          maxLength: policyVersion.customStrengthOptions?.maxPasswordLength\n        };\n      });\n    }\n    this.constraints = constraintsResponse;\n    this.forceUpgradeOnSignin = response.forceUpgradeOnSignin ? true : false;\n  }\n}\nexports.PasswordPolicyAuthConfig = PasswordPolicyAuthConfig;\n/**\n * Defines the EmailPrivacyAuthConfig class used for validation.\n *\n * @internal\n */\nclass EmailPrivacyAuthConfig {\n  static validate(options) {\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"EmailPrivacyConfig\" must be a non-null object.');\n    }\n    const validKeys = {\n      enableImprovedEmailPrivacy: true\n    };\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid \"EmailPrivacyConfig\" parameter.`);\n      }\n    }\n    if (typeof options.enableImprovedEmailPrivacy !== 'undefined' && !validator.isBoolean(options.enableImprovedEmailPrivacy)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"EmailPrivacyConfig.enableImprovedEmailPrivacy\" must be a valid boolean value.');\n    }\n  }\n}\nexports.EmailPrivacyAuthConfig = EmailPrivacyAuthConfig;","map":{"version":3,"names":["Object","defineProperty","exports","value","EmailPrivacyAuthConfig","PasswordPolicyAuthConfig","RecaptchaAuthConfig","SmsRegionsAuthConfig","OIDCConfig","SAMLConfig","EmailSignInConfig","validateTestPhoneNumbers","MultiFactorAuthConfig","MAXIMUM_TEST_PHONE_NUMBERS","validator","require","deep_copy_1","error_1","AUTH_FACTOR_CLIENT_TO_SERVER_TYPE","phone","AUTH_FACTOR_SERVER_TO_CLIENT_TYPE","keys","reduce","res","key","buildServerRequest","options","request","validate","prototype","hasOwnProperty","call","state","factorIds","forEach","factorId","enabledProviders","push","length","providerConfigs","validKeys","isNonNullObject","FirebaseAuthError","AuthClientErrorCode","INVALID_CONFIG","isArray","multiFactorProviderConfig","isObject","validProviderConfigKeys","totpProviderConfig","validTotpProviderConfigKeys","adjacentIntervals","adjIntervals","Number","isInteger","INVALID_ARGUMENT","constructor","response","INTERNAL_ERROR","enabledProvider","providerConfig","toJSON","testPhoneNumbers","MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED","phoneNumber","isPhoneNumber","INVALID_TESTING_PHONE_NUMBER","isString","test","allowPasswordSignup","enabled","enableEmailLinkSignin","passwordRequired","isBoolean","ignoreMissingFields","makeRequest","providerId","displayName","idpEntityId","ssoURL","x509Certificates","idpConfig","ssoUrl","signRequest","enableRequestSigning","idpCertificates","undefined","cert","x509Certificate","callbackURL","rpEntityId","spConfig","spEntityId","callbackUri","getProviderIdFromResourceName","resourceName","matchProviderRes","match","isProviderId","isNonEmptyString","indexOf","INVALID_PROVIDER_ID","MISSING_PROVIDER_ID","isURL","MISSING_SAML_RELYING_PARTY_CONFIG","name","deepCopy","issuer","clientId","clientSecret","responseType","validResponseTypes","idToken","code","MISSING_OAUTH_CLIENT_ID","INVALID_OAUTH_CLIENT_ID","MISSING_ISSUER","MISSING_OAUTH_CLIENT_SECRET","allKeys","enabledCount","values","filter","Boolean","INVALID_OAUTH_RESPONSETYPE","allowlistOnly","allowByDefault","allowByDefaultValidKeys","disallowedRegions","allowListOnlyValidKeys","allowedRegions","filteredResponse","fromEntries","entries","tollFraudManagedRules","smsTollFraudManagedRules","assign","emailPasswordEnforcementState","phoneEnforcementState","managedRules","recaptchaKeys","useAccountDefender","useSmsBotScore","useSmsTollFraudProtection","managedRule","validateManagedRule","tollFraudManagedRule","validateTollFraudManagedRule","endScore","action","startScore","passwordPolicyEnforcementState","enforcementState","forceUpgradeOnSignin","constraintsRequest","containsUppercaseCharacter","containsLowercaseCharacter","containsNonAlphanumericCharacter","containsNumericCharacter","minPasswordLength","maxPasswordLength","passwordPolicyVersions","constraints","requireUppercase","requireLowercase","requireNonAlphanumeric","requireNumeric","minLength","maxLength","customStrengthOptions","validCharKeys","isNumber","constraintsResponse","policyVersion","enableImprovedEmailPrivacy"],"sources":["/home/yadu/Music/Gifty/node_modules/firebase-admin/lib/auth/auth-config.js"],"sourcesContent":["/*! firebase-admin v12.7.0 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EmailPrivacyAuthConfig = exports.PasswordPolicyAuthConfig = exports.RecaptchaAuthConfig = exports.SmsRegionsAuthConfig = exports.OIDCConfig = exports.SAMLConfig = exports.EmailSignInConfig = exports.validateTestPhoneNumbers = exports.MultiFactorAuthConfig = exports.MAXIMUM_TEST_PHONE_NUMBERS = void 0;\nconst validator = require(\"../utils/validator\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst error_1 = require(\"../utils/error\");\n/** A maximum of 10 test phone number / code pairs can be configured. */\nexports.MAXIMUM_TEST_PHONE_NUMBERS = 10;\n/** Client Auth factor type to server auth factor type mapping. */\nconst AUTH_FACTOR_CLIENT_TO_SERVER_TYPE = {\n    phone: 'PHONE_SMS',\n};\n/** Server Auth factor type to client auth factor type mapping. */\nconst AUTH_FACTOR_SERVER_TO_CLIENT_TYPE = Object.keys(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE)\n    .reduce((res, key) => {\n    res[AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[key]] = key;\n    return res;\n}, {});\n/**\n * Defines the multi-factor config class used to convert client side MultiFactorConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass MultiFactorAuthConfig {\n    /**\n     * Static method to convert a client side request to a MultiFactorAuthServerConfig.\n     * Throws an error if validation fails.\n     *\n     * @param options - The options object to convert to a server request.\n     * @returns The resulting server request.\n     * @internal\n     */\n    static buildServerRequest(options) {\n        const request = {};\n        MultiFactorAuthConfig.validate(options);\n        if (Object.prototype.hasOwnProperty.call(options, 'state')) {\n            request.state = options.state;\n        }\n        if (Object.prototype.hasOwnProperty.call(options, 'factorIds')) {\n            (options.factorIds || []).forEach((factorId) => {\n                if (typeof request.enabledProviders === 'undefined') {\n                    request.enabledProviders = [];\n                }\n                request.enabledProviders.push(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId]);\n            });\n            // In case an empty array is passed. Ensure it gets populated so the array is cleared.\n            if (options.factorIds && options.factorIds.length === 0) {\n                request.enabledProviders = [];\n            }\n        }\n        if (Object.prototype.hasOwnProperty.call(options, 'providerConfigs')) {\n            request.providerConfigs = options.providerConfigs;\n        }\n        return request;\n    }\n    /**\n     * Validates the MultiFactorConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     */\n    static validate(options) {\n        const validKeys = {\n            state: true,\n            factorIds: true,\n            providerConfigs: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid MultiFactorConfig parameter.`);\n            }\n        }\n        // Validate content.\n        if (typeof options.state !== 'undefined' &&\n            options.state !== 'ENABLED' &&\n            options.state !== 'DISABLED') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.state\" must be either \"ENABLED\" or \"DISABLED\".');\n        }\n        if (typeof options.factorIds !== 'undefined') {\n            if (!validator.isArray(options.factorIds)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.factorIds\" must be an array of valid \"AuthFactorTypes\".');\n            }\n            // Validate content of array.\n            options.factorIds.forEach((factorId) => {\n                if (typeof AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId] === 'undefined') {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${factorId}\" is not a valid \"AuthFactorType\".`);\n                }\n            });\n        }\n        if (typeof options.providerConfigs !== 'undefined') {\n            if (!validator.isArray(options.providerConfigs)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.providerConfigs\" must be an array of valid \"MultiFactorProviderConfig.\"');\n            }\n            //Validate content of array.\n            options.providerConfigs.forEach((multiFactorProviderConfig) => {\n                if (typeof multiFactorProviderConfig === 'undefined' || !validator.isObject(multiFactorProviderConfig)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${multiFactorProviderConfig}\" is not a valid \"MultiFactorProviderConfig\" type.`);\n                }\n                const validProviderConfigKeys = {\n                    state: true,\n                    totpProviderConfig: true,\n                };\n                for (const key in multiFactorProviderConfig) {\n                    if (!(key in validProviderConfigKeys)) {\n                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid ProviderConfig parameter.`);\n                    }\n                }\n                if (typeof multiFactorProviderConfig.state === 'undefined' ||\n                    (multiFactorProviderConfig.state !== 'ENABLED' &&\n                        multiFactorProviderConfig.state !== 'DISABLED')) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.providerConfigs.state\" must be either \"ENABLED\" or \"DISABLED\".');\n                }\n                // Since TOTP is the only provider config available right now, not defining it will lead into an error\n                if (typeof multiFactorProviderConfig.totpProviderConfig === 'undefined') {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.providerConfigs.totpProviderConfig\" must be defined.');\n                }\n                const validTotpProviderConfigKeys = {\n                    adjacentIntervals: true,\n                };\n                for (const key in multiFactorProviderConfig.totpProviderConfig) {\n                    if (!(key in validTotpProviderConfigKeys)) {\n                        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid TotpProviderConfig parameter.`);\n                    }\n                }\n                const adjIntervals = multiFactorProviderConfig.totpProviderConfig.adjacentIntervals;\n                if (typeof adjIntervals !== 'undefined' &&\n                    (!Number.isInteger(adjIntervals) || adjIntervals < 0 || adjIntervals > 10)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"MultiFactorConfig.providerConfigs.totpProviderConfig.adjacentIntervals\" must' +\n                        ' be a valid number between 0 and 10 (both inclusive).');\n                }\n            });\n        }\n    }\n    /**\n     * The MultiFactorAuthConfig constructor.\n     *\n     * @param response - The server side response used to initialize the\n     *     MultiFactorAuthConfig object.\n     * @constructor\n     * @internal\n     */\n    constructor(response) {\n        if (typeof response.state === 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');\n        }\n        this.state = response.state;\n        this.factorIds = [];\n        (response.enabledProviders || []).forEach((enabledProvider) => {\n            // Ignore unsupported types. It is possible the current admin SDK version is\n            // not up to date and newer backend types are supported.\n            if (typeof AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider] !== 'undefined') {\n                this.factorIds.push(AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider]);\n            }\n        });\n        this.providerConfigs = [];\n        (response.providerConfigs || []).forEach((providerConfig) => {\n            if (typeof providerConfig !== 'undefined') {\n                if (typeof providerConfig.state === 'undefined' ||\n                    typeof providerConfig.totpProviderConfig === 'undefined' ||\n                    (typeof providerConfig.totpProviderConfig.adjacentIntervals !== 'undefined' &&\n                        typeof providerConfig.totpProviderConfig.adjacentIntervals !== 'number')) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');\n                }\n                this.providerConfigs.push(providerConfig);\n            }\n        });\n    }\n    /** Converts MultiFactorConfig to JSON object\n     * @returns The plain object representation of the multi-factor config instance. */\n    toJSON() {\n        return {\n            state: this.state,\n            factorIds: this.factorIds,\n            providerConfigs: this.providerConfigs,\n        };\n    }\n}\nexports.MultiFactorAuthConfig = MultiFactorAuthConfig;\n/**\n * Validates the provided map of test phone number / code pairs.\n * @param testPhoneNumbers - The phone number / code pairs to validate.\n */\nfunction validateTestPhoneNumbers(testPhoneNumbers) {\n    if (!validator.isObject(testPhoneNumbers)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"testPhoneNumbers\" must be a map of phone number / code pairs.');\n    }\n    if (Object.keys(testPhoneNumbers).length > exports.MAXIMUM_TEST_PHONE_NUMBERS) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);\n    }\n    for (const phoneNumber in testPhoneNumbers) {\n        // Validate phone number.\n        if (!validator.isPhoneNumber(phoneNumber)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `\"${phoneNumber}\" is not a valid E.164 standard compliant phone number.`);\n        }\n        // Validate code.\n        if (!validator.isString(testPhoneNumbers[phoneNumber]) ||\n            !/^[\\d]{6}$/.test(testPhoneNumbers[phoneNumber])) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `\"${testPhoneNumbers[phoneNumber]}\" is not a valid 6 digit code string.`);\n        }\n    }\n}\nexports.validateTestPhoneNumbers = validateTestPhoneNumbers;\n/**\n * Defines the email sign-in config class used to convert client side EmailSignInConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass EmailSignInConfig {\n    /**\n     * Static method to convert a client side request to a EmailSignInConfigServerRequest.\n     * Throws an error if validation fails.\n     *\n     * @param options - The options object to convert to a server request.\n     * @returns The resulting server request.\n     * @internal\n     */\n    static buildServerRequest(options) {\n        const request = {};\n        EmailSignInConfig.validate(options);\n        if (Object.prototype.hasOwnProperty.call(options, 'enabled')) {\n            request.allowPasswordSignup = options.enabled;\n        }\n        if (Object.prototype.hasOwnProperty.call(options, 'passwordRequired')) {\n            request.enableEmailLinkSignin = !options.passwordRequired;\n        }\n        return request;\n    }\n    /**\n     * Validates the EmailSignInConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     */\n    static validate(options) {\n        // TODO: Validate the request.\n        const validKeys = {\n            enabled: true,\n            passwordRequired: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `\"${key}\" is not a valid EmailSignInConfig parameter.`);\n            }\n        }\n        // Validate content.\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.passwordRequired !== 'undefined' &&\n            !validator.isBoolean(options.passwordRequired)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.passwordRequired\" must be a boolean.');\n        }\n    }\n    /**\n     * The EmailSignInConfig constructor.\n     *\n     * @param response - The server side response used to initialize the\n     *     EmailSignInConfig object.\n     * @constructor\n     */\n    constructor(response) {\n        if (typeof response.allowPasswordSignup === 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid email sign-in configuration response');\n        }\n        this.enabled = response.allowPasswordSignup;\n        this.passwordRequired = !response.enableEmailLinkSignin;\n    }\n    /** @returns The plain object representation of the email sign-in config. */\n    toJSON() {\n        return {\n            enabled: this.enabled,\n            passwordRequired: this.passwordRequired,\n        };\n    }\n}\nexports.EmailSignInConfig = EmailSignInConfig;\n/**\n * Defines the SAMLConfig class used to convert a client side configuration to its\n * server side representation.\n *\n * @internal\n */\nclass SAMLConfig {\n    /**\n     * Converts a client side request to a SAMLConfigServerRequest which is the format\n     * accepted by the backend server.\n     * Throws an error if validation fails. If the request is not a SAMLConfig request,\n     * returns null.\n     *\n     * @param options - The options object to convert to a server request.\n     * @param ignoreMissingFields - Whether to ignore missing fields.\n     * @returns The resulting server request or null if not valid.\n     */\n    static buildServerRequest(options, ignoreMissingFields = false) {\n        const makeRequest = validator.isNonNullObject(options) &&\n            (options.providerId || ignoreMissingFields);\n        if (!makeRequest) {\n            return null;\n        }\n        const request = {};\n        // Validate options.\n        SAMLConfig.validate(options, ignoreMissingFields);\n        request.enabled = options.enabled;\n        request.displayName = options.displayName;\n        // IdP config.\n        if (options.idpEntityId || options.ssoURL || options.x509Certificates) {\n            request.idpConfig = {\n                idpEntityId: options.idpEntityId,\n                ssoUrl: options.ssoURL,\n                signRequest: options.enableRequestSigning,\n                idpCertificates: typeof options.x509Certificates === 'undefined' ? undefined : [],\n            };\n            if (options.x509Certificates) {\n                for (const cert of (options.x509Certificates || [])) {\n                    request.idpConfig.idpCertificates.push({ x509Certificate: cert });\n                }\n            }\n        }\n        // RP config.\n        if (options.callbackURL || options.rpEntityId) {\n            request.spConfig = {\n                spEntityId: options.rpEntityId,\n                callbackUri: options.callbackURL,\n            };\n        }\n        return request;\n    }\n    /**\n     * Returns the provider ID corresponding to the resource name if available.\n     *\n     * @param resourceName - The server side resource name.\n     * @returns The provider ID corresponding to the resource, null otherwise.\n     */\n    static getProviderIdFromResourceName(resourceName) {\n        // name is of form projects/project1/inboundSamlConfigs/providerId1\n        const matchProviderRes = resourceName.match(/\\/inboundSamlConfigs\\/(saml\\..*)$/);\n        if (!matchProviderRes || matchProviderRes.length < 2) {\n            return null;\n        }\n        return matchProviderRes[1];\n    }\n    /**\n     * @param providerId - The provider ID to check.\n     * @returns Whether the provider ID corresponds to a SAML provider.\n     */\n    static isProviderId(providerId) {\n        return validator.isNonEmptyString(providerId) && providerId.indexOf('saml.') === 0;\n    }\n    /**\n     * Validates the SAMLConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     * @param ignoreMissingFields - Whether to ignore missing fields.\n     */\n    static validate(options, ignoreMissingFields = false) {\n        const validKeys = {\n            enabled: true,\n            displayName: true,\n            providerId: true,\n            idpEntityId: true,\n            ssoURL: true,\n            x509Certificates: true,\n            rpEntityId: true,\n            callbackURL: true,\n            enableRequestSigning: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig\" must be a valid non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SAML config parameter.`);\n            }\n        }\n        // Required fields.\n        if (validator.isNonEmptyString(options.providerId)) {\n            if (options.providerId.indexOf('saml.') !== 0) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n            }\n        }\n        else if (!ignoreMissingFields) {\n            // providerId is required and not provided correctly.\n            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n        }\n        if (!(ignoreMissingFields && typeof options.idpEntityId === 'undefined') &&\n            !validator.isNonEmptyString(options.idpEntityId)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.idpEntityId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.ssoURL === 'undefined') &&\n            !validator.isURL(options.ssoURL)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.ssoURL\" must be a valid URL string.');\n        }\n        if (!(ignoreMissingFields && typeof options.rpEntityId === 'undefined') &&\n            !validator.isNonEmptyString(options.rpEntityId)) {\n            throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG :\n                error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.rpEntityId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.callbackURL === 'undefined') &&\n            !validator.isURL(options.callbackURL)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.callbackURL\" must be a valid URL string.');\n        }\n        if (!(ignoreMissingFields && typeof options.x509Certificates === 'undefined') &&\n            !validator.isArray(options.x509Certificates)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n        }\n        (options.x509Certificates || []).forEach((cert) => {\n            if (!validator.isNonEmptyString(cert)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n            }\n        });\n        if (typeof options.enableRequestSigning !== 'undefined' &&\n            !validator.isBoolean(options.enableRequestSigning)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enableRequestSigning\" must be a boolean.');\n        }\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.displayName !== 'undefined' &&\n            !validator.isString(options.displayName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.displayName\" must be a valid string.');\n        }\n    }\n    /**\n     * The SAMLConfig constructor.\n     *\n     * @param response - The server side response used to initialize the SAMLConfig object.\n     * @constructor\n     */\n    constructor(response) {\n        if (!response ||\n            !response.idpConfig ||\n            !response.idpConfig.idpEntityId ||\n            !response.idpConfig.ssoUrl ||\n            !response.spConfig ||\n            !response.spConfig.spEntityId ||\n            !response.name ||\n            !(validator.isString(response.name) &&\n                SAMLConfig.getProviderIdFromResourceName(response.name))) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        const providerId = SAMLConfig.getProviderIdFromResourceName(response.name);\n        if (!providerId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        this.providerId = providerId;\n        // RP config.\n        this.rpEntityId = response.spConfig.spEntityId;\n        this.callbackURL = response.spConfig.callbackUri;\n        // IdP config.\n        this.idpEntityId = response.idpConfig.idpEntityId;\n        this.ssoURL = response.idpConfig.ssoUrl;\n        this.enableRequestSigning = !!response.idpConfig.signRequest;\n        const x509Certificates = [];\n        for (const cert of (response.idpConfig.idpCertificates || [])) {\n            if (cert.x509Certificate) {\n                x509Certificates.push(cert.x509Certificate);\n            }\n        }\n        this.x509Certificates = x509Certificates;\n        // When enabled is undefined, it takes its default value of false.\n        this.enabled = !!response.enabled;\n        this.displayName = response.displayName;\n    }\n    /** @returns The plain object representation of the SAMLConfig. */\n    toJSON() {\n        return {\n            enabled: this.enabled,\n            displayName: this.displayName,\n            providerId: this.providerId,\n            idpEntityId: this.idpEntityId,\n            ssoURL: this.ssoURL,\n            x509Certificates: (0, deep_copy_1.deepCopy)(this.x509Certificates),\n            rpEntityId: this.rpEntityId,\n            callbackURL: this.callbackURL,\n            enableRequestSigning: this.enableRequestSigning,\n        };\n    }\n}\nexports.SAMLConfig = SAMLConfig;\n/**\n * Defines the OIDCConfig class used to convert a client side configuration to its\n * server side representation.\n *\n * @internal\n */\nclass OIDCConfig {\n    /**\n     * Converts a client side request to a OIDCConfigServerRequest which is the format\n     * accepted by the backend server.\n     * Throws an error if validation fails. If the request is not a OIDCConfig request,\n     * returns null.\n     *\n     * @param options - The options object to convert to a server request.\n     * @param ignoreMissingFields - Whether to ignore missing fields.\n     * @returns The resulting server request or null if not valid.\n     */\n    static buildServerRequest(options, ignoreMissingFields = false) {\n        const makeRequest = validator.isNonNullObject(options) &&\n            (options.providerId || ignoreMissingFields);\n        if (!makeRequest) {\n            return null;\n        }\n        const request = {};\n        // Validate options.\n        OIDCConfig.validate(options, ignoreMissingFields);\n        request.enabled = options.enabled;\n        request.displayName = options.displayName;\n        request.issuer = options.issuer;\n        request.clientId = options.clientId;\n        if (typeof options.clientSecret !== 'undefined') {\n            request.clientSecret = options.clientSecret;\n        }\n        if (typeof options.responseType !== 'undefined') {\n            request.responseType = options.responseType;\n        }\n        return request;\n    }\n    /**\n     * Returns the provider ID corresponding to the resource name if available.\n     *\n     * @param resourceName - The server side resource name\n     * @returns The provider ID corresponding to the resource, null otherwise.\n     */\n    static getProviderIdFromResourceName(resourceName) {\n        // name is of form projects/project1/oauthIdpConfigs/providerId1\n        const matchProviderRes = resourceName.match(/\\/oauthIdpConfigs\\/(oidc\\..*)$/);\n        if (!matchProviderRes || matchProviderRes.length < 2) {\n            return null;\n        }\n        return matchProviderRes[1];\n    }\n    /**\n     * @param providerId - The provider ID to check.\n     * @returns Whether the provider ID corresponds to an OIDC provider.\n     */\n    static isProviderId(providerId) {\n        return validator.isNonEmptyString(providerId) && providerId.indexOf('oidc.') === 0;\n    }\n    /**\n     * Validates the OIDCConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     * @param ignoreMissingFields - Whether to ignore missing fields.\n     */\n    static validate(options, ignoreMissingFields = false) {\n        const validKeys = {\n            enabled: true,\n            displayName: true,\n            providerId: true,\n            clientId: true,\n            issuer: true,\n            clientSecret: true,\n            responseType: true,\n        };\n        const validResponseTypes = {\n            idToken: true,\n            code: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig\" must be a valid non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid OIDC config parameter.`);\n            }\n        }\n        // Required fields.\n        if (validator.isNonEmptyString(options.providerId)) {\n            if (options.providerId.indexOf('oidc.') !== 0) {\n                throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n            }\n        }\n        else if (!ignoreMissingFields) {\n            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n        }\n        if (!(ignoreMissingFields && typeof options.clientId === 'undefined') &&\n            !validator.isNonEmptyString(options.clientId)) {\n            throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '\"OIDCAuthProviderConfig.clientId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.issuer === 'undefined') &&\n            !validator.isURL(options.issuer)) {\n            throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.issuer\" must be a valid URL string.');\n        }\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.displayName !== 'undefined' &&\n            !validator.isString(options.displayName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.displayName\" must be a valid string.');\n        }\n        if (typeof options.clientSecret !== 'undefined' &&\n            !validator.isNonEmptyString(options.clientSecret)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.clientSecret\" must be a valid string.');\n        }\n        if (validator.isNonNullObject(options.responseType) && typeof options.responseType !== 'undefined') {\n            Object.keys(options.responseType).forEach((key) => {\n                if (!(key in validResponseTypes)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid OAuthResponseType parameter.`);\n                }\n            });\n            const idToken = options.responseType.idToken;\n            if (typeof idToken !== 'undefined' && !validator.isBoolean(idToken)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.idToken\" must be a boolean.');\n            }\n            const code = options.responseType.code;\n            if (typeof code !== 'undefined') {\n                if (!validator.isBoolean(code)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.code\" must be a boolean.');\n                }\n                // If code flow is enabled, client secret must be provided.\n                if (code && typeof options.clientSecret === 'undefined') {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET, 'The OAuth configuration client secret is required to enable OIDC code flow.');\n                }\n            }\n            const allKeys = Object.keys(options.responseType).length;\n            const enabledCount = Object.values(options.responseType).filter(Boolean).length;\n            // Only one of OAuth response types can be set to true.\n            if (allKeys > 1 && enabledCount !== 1) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE, 'Only exactly one OAuth responseType should be set to true.');\n            }\n        }\n    }\n    /**\n     * The OIDCConfig constructor.\n     *\n     * @param response - The server side response used to initialize the OIDCConfig object.\n     * @constructor\n     */\n    constructor(response) {\n        if (!response ||\n            !response.issuer ||\n            !response.clientId ||\n            !response.name ||\n            !(validator.isString(response.name) &&\n                OIDCConfig.getProviderIdFromResourceName(response.name))) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid OIDC configuration response');\n        }\n        const providerId = OIDCConfig.getProviderIdFromResourceName(response.name);\n        if (!providerId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        this.providerId = providerId;\n        this.clientId = response.clientId;\n        this.issuer = response.issuer;\n        // When enabled is undefined, it takes its default value of false.\n        this.enabled = !!response.enabled;\n        this.displayName = response.displayName;\n        if (typeof response.clientSecret !== 'undefined') {\n            this.clientSecret = response.clientSecret;\n        }\n        if (typeof response.responseType !== 'undefined') {\n            this.responseType = response.responseType;\n        }\n    }\n    /** @returns The plain object representation of the OIDCConfig. */\n    toJSON() {\n        return {\n            enabled: this.enabled,\n            displayName: this.displayName,\n            providerId: this.providerId,\n            issuer: this.issuer,\n            clientId: this.clientId,\n            clientSecret: (0, deep_copy_1.deepCopy)(this.clientSecret),\n            responseType: (0, deep_copy_1.deepCopy)(this.responseType),\n        };\n    }\n}\nexports.OIDCConfig = OIDCConfig;\n/**\n * Defines the SMSRegionConfig class used for validation.\n *\n * @internal\n */\nclass SmsRegionsAuthConfig {\n    static validate(options) {\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig\" must be a non-null object.');\n        }\n        const validKeys = {\n            allowlistOnly: true,\n            allowByDefault: true,\n        };\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig parameter.`);\n            }\n        }\n        // validate mutual exclusiveness of allowByDefault and allowlistOnly\n        if (typeof options.allowByDefault !== 'undefined' && typeof options.allowlistOnly !== 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'SmsRegionConfig cannot have both \"allowByDefault\" and \"allowlistOnly\" parameters.');\n        }\n        // validation for allowByDefault type\n        if (typeof options.allowByDefault !== 'undefined') {\n            const allowByDefaultValidKeys = {\n                disallowedRegions: true,\n            };\n            for (const key in options.allowByDefault) {\n                if (!(key in allowByDefaultValidKeys)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig.allowByDefault parameter.`);\n                }\n            }\n            // disallowedRegion can be empty.\n            if (typeof options.allowByDefault.disallowedRegions !== 'undefined'\n                && !validator.isArray(options.allowByDefault.disallowedRegions)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig.allowByDefault.disallowedRegions\" must be a valid string array.');\n            }\n        }\n        if (typeof options.allowlistOnly !== 'undefined') {\n            const allowListOnlyValidKeys = {\n                allowedRegions: true,\n            };\n            for (const key in options.allowlistOnly) {\n                if (!(key in allowListOnlyValidKeys)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig.allowlistOnly parameter.`);\n                }\n            }\n            // allowedRegions can be empty\n            if (typeof options.allowlistOnly.allowedRegions !== 'undefined'\n                && !validator.isArray(options.allowlistOnly.allowedRegions)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig.allowlistOnly.allowedRegions\" must be a valid string array.');\n            }\n        }\n    }\n}\nexports.SmsRegionsAuthConfig = SmsRegionsAuthConfig;\n/**\n * Defines the recaptcha config class used to convert client side RecaptchaConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass RecaptchaAuthConfig {\n    /**\n     * The RecaptchaAuthConfig constructor.\n     *\n     * @param response - The server side response used to initialize the\n     *     RecaptchaAuthConfig object.\n     * @constructor\n     * @internal\n     */\n    constructor(response) {\n        const filteredResponse = Object.fromEntries(Object.entries(response).filter(([, value]) => value !== undefined));\n        // Explicitly map the 'tollFraudManagedRules' to 'smsTollFraudManagedRules'\n        if (filteredResponse.tollFraudManagedRules !== undefined) {\n            this.smsTollFraudManagedRules = filteredResponse.tollFraudManagedRules;\n            delete filteredResponse.tollFraudManagedRules; // Remove it if necessary\n        }\n        // Assign the remaining properties directly\n        Object.assign(this, filteredResponse);\n    }\n    /**\n     * Builds a server request object from the client-side RecaptchaConfig.\n     * Converts client-side fields to their server-side equivalents.\n     *\n     * @param options - The client-side RecaptchaConfig object.\n     * @returns The server-side RecaptchaAuthServerConfig object.\n     */\n    static buildServerRequest(options) {\n        RecaptchaAuthConfig.validate(options); // Validate options before building request\n        const request = {};\n        if (typeof options.emailPasswordEnforcementState !== 'undefined') {\n            request.emailPasswordEnforcementState = options.emailPasswordEnforcementState;\n        }\n        if (typeof options.phoneEnforcementState !== 'undefined') {\n            request.phoneEnforcementState = options.phoneEnforcementState;\n        }\n        if (typeof options.managedRules !== 'undefined') {\n            request.managedRules = options.managedRules;\n        }\n        if (typeof options.recaptchaKeys !== 'undefined') {\n            request.recaptchaKeys = options.recaptchaKeys;\n        }\n        if (typeof options.useAccountDefender !== 'undefined') {\n            request.useAccountDefender = options.useAccountDefender;\n        }\n        if (typeof options.useSmsBotScore !== 'undefined') {\n            request.useSmsBotScore = options.useSmsBotScore;\n        }\n        if (typeof options.useSmsTollFraudProtection !== 'undefined') {\n            request.useSmsTollFraudProtection = options.useSmsTollFraudProtection;\n        }\n        if (typeof options.smsTollFraudManagedRules !== 'undefined') {\n            request.tollFraudManagedRules = options.smsTollFraudManagedRules; // Map client-side field to server-side\n        }\n        return request;\n    }\n    /**\n     * Validates the RecaptchaConfig options object. Throws an error on failure.\n     * @param options - The options object to validate.\n     */\n    static validate(options) {\n        const validKeys = {\n            emailPasswordEnforcementState: true,\n            phoneEnforcementState: true,\n            managedRules: true,\n            recaptchaKeys: true,\n            useAccountDefender: true,\n            useSmsBotScore: true,\n            useSmsTollFraudProtection: true,\n            smsTollFraudManagedRules: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig\" must be a non-null object.');\n        }\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid RecaptchaConfig parameter.`);\n            }\n        }\n        // Validation\n        if (typeof options.emailPasswordEnforcementState !== 'undefined') {\n            if (!validator.isNonEmptyString(options.emailPasswordEnforcementState)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"RecaptchaConfig.emailPasswordEnforcementState\" must be a valid non-empty string.');\n            }\n            if (options.emailPasswordEnforcementState !== 'OFF' &&\n                options.emailPasswordEnforcementState !== 'AUDIT' &&\n                options.emailPasswordEnforcementState !== 'ENFORCE') {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.emailPasswordEnforcementState\" must be either \"OFF\", \"AUDIT\" or \"ENFORCE\".');\n            }\n        }\n        if (typeof options.phoneEnforcementState !== 'undefined') {\n            if (!validator.isNonEmptyString(options.phoneEnforcementState)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"RecaptchaConfig.phoneEnforcementState\" must be a valid non-empty string.');\n            }\n            if (options.phoneEnforcementState !== 'OFF' &&\n                options.phoneEnforcementState !== 'AUDIT' &&\n                options.phoneEnforcementState !== 'ENFORCE') {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.phoneEnforcementState\" must be either \"OFF\", \"AUDIT\" or \"ENFORCE\".');\n            }\n        }\n        if (typeof options.managedRules !== 'undefined') {\n            // Validate array\n            if (!validator.isArray(options.managedRules)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.managedRules\" must be an array of valid \"RecaptchaManagedRule\".');\n            }\n            // Validate each rule of the array\n            options.managedRules.forEach((managedRule) => {\n                RecaptchaAuthConfig.validateManagedRule(managedRule);\n            });\n        }\n        if (typeof options.useAccountDefender !== 'undefined') {\n            if (!validator.isBoolean(options.useAccountDefender)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.useAccountDefender\" must be a boolean value\".');\n            }\n        }\n        if (typeof options.useSmsBotScore !== 'undefined') {\n            if (!validator.isBoolean(options.useSmsBotScore)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.useSmsBotScore\" must be a boolean value\".');\n            }\n        }\n        if (typeof options.useSmsTollFraudProtection !== 'undefined') {\n            if (!validator.isBoolean(options.useSmsTollFraudProtection)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.useSmsTollFraudProtection\" must be a boolean value\".');\n            }\n        }\n        if (typeof options.smsTollFraudManagedRules !== 'undefined') {\n            // Validate array\n            if (!validator.isArray(options.smsTollFraudManagedRules)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaConfig.smsTollFraudManagedRules\" must be an array of valid \"RecaptchaTollFraudManagedRule\".');\n            }\n            // Validate each rule of the array\n            options.smsTollFraudManagedRules.forEach((tollFraudManagedRule) => {\n                RecaptchaAuthConfig.validateTollFraudManagedRule(tollFraudManagedRule);\n            });\n        }\n    }\n    /**\n     * Validate each element in ManagedRule array\n     * @param options - The options object to validate.\n     */\n    static validateManagedRule(options) {\n        const validKeys = {\n            endScore: true,\n            action: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaManagedRule\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid RecaptchaManagedRule parameter.`);\n            }\n        }\n        // Validate content.\n        if (typeof options.action !== 'undefined' &&\n            options.action !== 'BLOCK') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaManagedRule.action\" must be \"BLOCK\".');\n        }\n    }\n    /**\n     * Validate each element in TollFraudManagedRule array\n     * @param options - The options object to validate.\n     */\n    static validateTollFraudManagedRule(options) {\n        const validKeys = {\n            startScore: true,\n            action: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaTollFraudManagedRule\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid RecaptchaTollFraudManagedRule parameter.`);\n            }\n        }\n        // Validate content.\n        if (typeof options.action !== 'undefined' &&\n            options.action !== 'BLOCK') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"RecaptchaTollFraudManagedRule.action\" must be \"BLOCK\".');\n        }\n    }\n}\nexports.RecaptchaAuthConfig = RecaptchaAuthConfig;\n/**\n * Defines the password policy config class used to convert client side PasswordPolicyConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass PasswordPolicyAuthConfig {\n    /**\n     * Static method to convert a client side request to a PasswordPolicyAuthServerConfig.\n     * Throws an error if validation fails.\n     *\n     * @param options - The options object to convert to a server request.\n     * @returns The resulting server request.\n     * @internal\n     */\n    static buildServerRequest(options) {\n        const request = {};\n        PasswordPolicyAuthConfig.validate(options);\n        if (Object.prototype.hasOwnProperty.call(options, 'enforcementState')) {\n            request.passwordPolicyEnforcementState = options.enforcementState;\n        }\n        request.forceUpgradeOnSignin = false;\n        if (Object.prototype.hasOwnProperty.call(options, 'forceUpgradeOnSignin')) {\n            request.forceUpgradeOnSignin = options.forceUpgradeOnSignin;\n        }\n        const constraintsRequest = {\n            containsUppercaseCharacter: false,\n            containsLowercaseCharacter: false,\n            containsNonAlphanumericCharacter: false,\n            containsNumericCharacter: false,\n            minPasswordLength: 6,\n            maxPasswordLength: 4096,\n        };\n        request.passwordPolicyVersions = [];\n        if (Object.prototype.hasOwnProperty.call(options, 'constraints')) {\n            if (options) {\n                if (options.constraints?.requireUppercase !== undefined) {\n                    constraintsRequest.containsUppercaseCharacter = options.constraints.requireUppercase;\n                }\n                if (options.constraints?.requireLowercase !== undefined) {\n                    constraintsRequest.containsLowercaseCharacter = options.constraints.requireLowercase;\n                }\n                if (options.constraints?.requireNonAlphanumeric !== undefined) {\n                    constraintsRequest.containsNonAlphanumericCharacter = options.constraints.requireNonAlphanumeric;\n                }\n                if (options.constraints?.requireNumeric !== undefined) {\n                    constraintsRequest.containsNumericCharacter = options.constraints.requireNumeric;\n                }\n                if (options.constraints?.minLength !== undefined) {\n                    constraintsRequest.minPasswordLength = options.constraints.minLength;\n                }\n                if (options.constraints?.maxLength !== undefined) {\n                    constraintsRequest.maxPasswordLength = options.constraints.maxLength;\n                }\n            }\n        }\n        request.passwordPolicyVersions.push({ customStrengthOptions: constraintsRequest });\n        return request;\n    }\n    /**\n     * Validates the PasswordPolicyConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     * @internal\n     */\n    static validate(options) {\n        const validKeys = {\n            enforcementState: true,\n            forceUpgradeOnSignin: true,\n            constraints: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid PasswordPolicyConfig parameter.`);\n            }\n        }\n        // Validate content.\n        if (typeof options.enforcementState === 'undefined' ||\n            !(options.enforcementState === 'ENFORCE' ||\n                options.enforcementState === 'OFF')) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.enforcementState\" must be either \"ENFORCE\" or \"OFF\".');\n        }\n        if (typeof options.forceUpgradeOnSignin !== 'undefined') {\n            if (!validator.isBoolean(options.forceUpgradeOnSignin)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.forceUpgradeOnSignin\" must be a boolean.');\n            }\n        }\n        if (typeof options.constraints !== 'undefined') {\n            if (options.enforcementState === 'ENFORCE' && !validator.isNonNullObject(options.constraints)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints\" must be a non-empty object.');\n            }\n            const validCharKeys = {\n                requireUppercase: true,\n                requireLowercase: true,\n                requireNumeric: true,\n                requireNonAlphanumeric: true,\n                minLength: true,\n                maxLength: true,\n            };\n            // Check for unsupported  attributes.\n            for (const key in options.constraints) {\n                if (!(key in validCharKeys)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid PasswordPolicyConfig.constraints parameter.`);\n                }\n            }\n            if (typeof options.constraints.requireUppercase !== 'undefined' &&\n                !validator.isBoolean(options.constraints.requireUppercase)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireUppercase\" must be a boolean.');\n            }\n            if (typeof options.constraints.requireLowercase !== 'undefined' &&\n                !validator.isBoolean(options.constraints.requireLowercase)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireLowercase\" must be a boolean.');\n            }\n            if (typeof options.constraints.requireNonAlphanumeric !== 'undefined' &&\n                !validator.isBoolean(options.constraints.requireNonAlphanumeric)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireNonAlphanumeric\"' +\n                    ' must be a boolean.');\n            }\n            if (typeof options.constraints.requireNumeric !== 'undefined' &&\n                !validator.isBoolean(options.constraints.requireNumeric)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.requireNumeric\" must be a boolean.');\n            }\n            if (typeof options.constraints.minLength === 'undefined') {\n                options.constraints.minLength = 6;\n            }\n            else if (!validator.isNumber(options.constraints.minLength)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.minLength\" must be a number.');\n            }\n            else {\n                if (!(options.constraints.minLength >= 6\n                    && options.constraints.minLength <= 30)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.minLength\"' +\n                        ' must be an integer between 6 and 30, inclusive.');\n                }\n            }\n            if (typeof options.constraints.maxLength === 'undefined') {\n                options.constraints.maxLength = 4096;\n            }\n            else if (!validator.isNumber(options.constraints.maxLength)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.maxLength\" must be a number.');\n            }\n            else {\n                if (!(options.constraints.maxLength >= options.constraints.minLength &&\n                    options.constraints.maxLength <= 4096)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints.maxLength\"' +\n                        ' must be greater than or equal to minLength and at max 4096.');\n                }\n            }\n        }\n        else {\n            if (options.enforcementState === 'ENFORCE') {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"PasswordPolicyConfig.constraints\" must be defined.');\n            }\n        }\n    }\n    /**\n     * The PasswordPolicyAuthConfig constructor.\n     *\n     * @param response - The server side response used to initialize the\n     *     PasswordPolicyAuthConfig object.\n     * @constructor\n     * @internal\n     */\n    constructor(response) {\n        if (typeof response.passwordPolicyEnforcementState === 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid password policy configuration response');\n        }\n        this.enforcementState = response.passwordPolicyEnforcementState;\n        let constraintsResponse = {};\n        if (typeof response.passwordPolicyVersions !== 'undefined') {\n            (response.passwordPolicyVersions || []).forEach((policyVersion) => {\n                constraintsResponse = {\n                    requireLowercase: policyVersion.customStrengthOptions?.containsLowercaseCharacter,\n                    requireUppercase: policyVersion.customStrengthOptions?.containsUppercaseCharacter,\n                    requireNonAlphanumeric: policyVersion.customStrengthOptions?.containsNonAlphanumericCharacter,\n                    requireNumeric: policyVersion.customStrengthOptions?.containsNumericCharacter,\n                    minLength: policyVersion.customStrengthOptions?.minPasswordLength,\n                    maxLength: policyVersion.customStrengthOptions?.maxPasswordLength,\n                };\n            });\n        }\n        this.constraints = constraintsResponse;\n        this.forceUpgradeOnSignin = response.forceUpgradeOnSignin ? true : false;\n    }\n}\nexports.PasswordPolicyAuthConfig = PasswordPolicyAuthConfig;\n/**\n * Defines the EmailPrivacyAuthConfig class used for validation.\n *\n * @internal\n */\nclass EmailPrivacyAuthConfig {\n    static validate(options) {\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"EmailPrivacyConfig\" must be a non-null object.');\n        }\n        const validKeys = {\n            enableImprovedEmailPrivacy: true,\n        };\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid \"EmailPrivacyConfig\" parameter.`);\n            }\n        }\n        if (typeof options.enableImprovedEmailPrivacy !== 'undefined'\n            && !validator.isBoolean(options.enableImprovedEmailPrivacy)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"EmailPrivacyConfig.enableImprovedEmailPrivacy\" must be a valid boolean value.');\n        }\n    }\n}\nexports.EmailPrivacyAuthConfig = EmailPrivacyAuthConfig;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}