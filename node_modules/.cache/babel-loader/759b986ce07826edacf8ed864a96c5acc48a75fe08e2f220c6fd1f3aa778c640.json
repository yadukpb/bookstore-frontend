{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DocumentReference = void 0;\nconst index_1 = require(\"../index\");\nconst path_1 = require(\"../path\");\nconst types_1 = require(\"../types\");\nconst collection_reference_1 = require(\"./collection-reference\");\nconst util_1 = require(\"../util\");\nconst validate_1 = require(\"../validate\");\nconst document_1 = require(\"../document\");\nconst trace_util_1 = require(\"../telemetry/trace-util\");\n/**\n * A DocumentReference refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist. A DocumentReference can\n * also be used to create a\n * [CollectionReference]{@link CollectionReference} to a\n * subcollection.\n *\n * @class DocumentReference\n */\nclass DocumentReference {\n  /**\n   * @private\n   * @internal\n   * @param _firestore The Firestore Database client.\n   * @param _path The Path of this reference.\n   * @param _converter The converter to use when serializing data.\n   */\n  constructor(_firestore,\n  /**\n   * @private\n   * @internal\n   **/\n  _path) {\n    let _converter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, types_1.defaultConverter)();\n    this._firestore = _firestore;\n    this._path = _path;\n    this._converter = _converter;\n  }\n  /**\n   * The string representation of the DocumentReference's location.\n   * @private\n   * @internal\n   * @type {string}\n   * @name DocumentReference#formattedName\n   */\n  get formattedName() {\n    const projectId = this.firestore.projectId;\n    const databaseId = this.firestore.databaseId;\n    return this._path.toQualifiedResourcePath(projectId, databaseId).formattedName;\n  }\n  /**\n   * The [Firestore]{@link Firestore} instance for the Firestore\n   * database (useful for performing transactions, etc.).\n   *\n   * @type {Firestore}\n   * @name DocumentReference#firestore\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   let firestore = documentReference.firestore;\n   *   console.log(`Root location for document is ${firestore.formattedName}`);\n   * });\n   * ```\n   */\n  get firestore() {\n    return this._firestore;\n  }\n  /**\n   * A string representing the path of the referenced document (relative\n   * to the root of the database).\n   *\n   * @type {string}\n   * @name DocumentReference#path\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   console.log(`Added document at '${documentReference.path}'`);\n   * });\n   * ```\n   */\n  get path() {\n    return this._path.relativeName;\n  }\n  /**\n   * The last path element of the referenced document.\n   *\n   * @type {string}\n   * @name DocumentReference#id\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   console.log(`Added document with name '${documentReference.id}'`);\n   * });\n   * ```\n   */\n  get id() {\n    return this._path.id;\n  }\n  /**\n   * Returns a resource path for this document.\n   * @private\n   * @internal\n   */\n  get _resourcePath() {\n    return this._path;\n  }\n  /**\n   * A reference to the collection to which this DocumentReference belongs.\n   *\n   * @name DocumentReference#parent\n   * @type {CollectionReference}\n   * @readonly\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   * let collectionRef = documentRef.parent;\n   *\n   * collectionRef.where('foo', '==', 'bar').get().then(results => {\n   *   console.log(`Found ${results.size} matches in parent collection`);\n   * }):\n   * ```\n   */\n  get parent() {\n    return new collection_reference_1.CollectionReference(this._firestore, this._path.parent(), this._converter);\n  }\n  /**\n   * Reads the document referred to by this DocumentReference.\n   *\n   * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\n   * DocumentSnapshot for the retrieved document on success. For missing\n   * documents, DocumentSnapshot.exists will be false. If the get() fails for\n   * other reasons, the Promise will be rejected.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     console.log('Document retrieved successfully.');\n   *   }\n   * });\n   * ```\n   */\n  get() {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_GET, () => {\n      return this._firestore.getAll(this).then(_ref => {\n        let [result] = _ref;\n        return result;\n      });\n    });\n  }\n  /**\n   * Gets a [CollectionReference]{@link CollectionReference} instance\n   * that refers to the collection at the specified path.\n   *\n   * @param {string} collectionPath A slash-separated path to a collection.\n   * @returns {CollectionReference} A reference to the new\n   * subcollection.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   * let subcollection = documentRef.collection('subcollection');\n   * console.log(`Path to subcollection: ${subcollection.path}`);\n   * ```\n   */\n  collection(collectionPath) {\n    (0, path_1.validateResourcePath)('collectionPath', collectionPath);\n    const path = this._path.append(collectionPath);\n    if (!path.isCollection) {\n      throw new Error(`Value for argument \"collectionPath\" must point to a collection, but was \"${collectionPath}\". Your path does not contain an odd number of components.`);\n    }\n    return new collection_reference_1.CollectionReference(this._firestore, path);\n  }\n  /**\n   * Fetches the subcollections that are direct children of this document.\n   *\n   * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n   * with an array of CollectionReferences.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.listCollections().then(collections => {\n   *   for (let collection of collections) {\n   *     console.log(`Found subcollection with id: ${collection.id}`);\n   *   }\n   * });\n   * ```\n   */\n  listCollections() {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_LIST_COLLECTIONS, () => {\n      const tag = (0, util_1.requestTag)();\n      return this.firestore.initializeIfNeeded(tag).then(() => {\n        const request = {\n          parent: this.formattedName,\n          // Setting `pageSize` to an arbitrarily large value lets the backend cap\n          // the page size (currently to 300). Note that the backend rejects\n          // MAX_INT32 (b/146883794).\n          pageSize: Math.pow(2, 16) - 1\n        };\n        return this._firestore.request('listCollectionIds', request, tag).then(collectionIds => {\n          const collections = [];\n          // We can just sort this list using the default comparator since it\n          // will only contain collection ids.\n          collectionIds.sort();\n          for (const collectionId of collectionIds) {\n            collections.push(this.collection(collectionId));\n          }\n          return collections;\n        });\n      });\n    });\n  }\n  /**\n   * Create a document with the provided object values. This will fail the write\n   * if a document exists at its location.\n   *\n   * @param {DocumentData} data An object that contains the fields and data to\n   * serialize as the document.\n   * @throws {Error} If the provided input is not a valid Firestore document or if the document already exists.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * write time of this create.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * documentRef.create({foo: 'bar'}).then((res) => {\n   *   console.log(`Document created at ${res.updateTime}`);\n   * }).catch((err) => {\n   *   console.log(`Failed to create document: ${err}`);\n   * });\n   * ```\n   */\n  create(data) {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_CREATE, () => {\n      const writeBatch = new index_1.WriteBatch(this._firestore);\n      return writeBatch.create(this, data).commit().then(_ref2 => {\n        let [writeResult] = _ref2;\n        return writeResult;\n      });\n    });\n  }\n  /**\n   * Deletes the document referred to by this `DocumentReference`.\n   *\n   * A delete for a non-existing document is treated as a success (unless\n   * lastUptimeTime is provided).\n   *\n   * @param {Precondition=} precondition A precondition to enforce for this\n   * delete.\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n   * document was last updated at lastUpdateTime. Fails the delete if the\n   * document was last updated at a different time.\n   * @param {boolean=} precondition.exists If set, enforces that the target\n   * document must or must not exist.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * delete time.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.delete().then(() => {\n   *   console.log('Document successfully deleted.');\n   * });\n   * ```\n   */\n  delete(precondition) {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_DELETE, () => {\n      const writeBatch = new index_1.WriteBatch(this._firestore);\n      return writeBatch.delete(this, precondition).commit().then(_ref3 => {\n        let [writeResult] = _ref3;\n        return writeResult;\n      });\n    });\n  }\n  /**\n   * Writes to the document referred to by this DocumentReference. If the\n   * document does not yet exist, it will be created. If you pass\n   * [SetOptions]{@link SetOptions}, the provided data can be merged into an\n   * existing document.\n   *\n   * @param {T|Partial<AppModelType>} data A map of the fields and values for\n   * the document.\n   * @param {SetOptions=} options An object to configure the set behavior.\n   * @param {boolean=} options.merge If true, set() merges the values specified\n   * in its data argument. Fields omitted from this set() call remain untouched.\n   * If your input sets any field to an empty map, all nested fields are\n   * overwritten.\n   * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\n   * set() only replaces the specified field paths. Any field path that is not\n   * specified is ignored and remains untouched. If your input sets any field to\n   * an empty map, all nested fields are overwritten.\n   * @throws {Error} If the provided input is not a valid Firestore document.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * write time of this set.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({foo: 'bar'}).then(res => {\n   *   console.log(`Document written at ${res.updateTime}`);\n   * });\n   * ```\n   */\n  set(data, options) {\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_SET, () => {\n      let writeBatch = new index_1.WriteBatch(this._firestore);\n      if (options) {\n        writeBatch = writeBatch.set(this, data, options);\n      } else {\n        writeBatch = writeBatch.set(this, data);\n      }\n      return writeBatch.commit().then(_ref4 => {\n        let [writeResult] = _ref4;\n        return writeResult;\n      });\n    });\n  }\n  /**\n   * Updates fields in the document referred to by this DocumentReference.\n   * If the document doesn't yet exist, the update fails and the returned\n   * Promise will be rejected.\n   *\n   * The update() method accepts either an object with field paths encoded as\n   * keys and field values encoded as values, or a variable number of arguments\n   * that alternate between field paths and field values.\n   *\n   * A Precondition restricting this update can be specified as the last\n   * argument.\n   *\n   * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n   * fields and values with which to update the document or the path of the\n   * first field to update.\n   * @param {\n   * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\n   * list of field paths and values to update or a Precondition to restrict\n   * this update.\n   * @throws {Error} If the provided input is not valid Firestore data.\n   * @returns {Promise.<WriteResult>} A Promise that resolves once the\n   * data has been successfully written to the backend.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.update({foo: 'bar'}).then(res => {\n   *   console.log(`Document updated at ${res.updateTime}`);\n   * });\n   * ```\n   */\n  update(dataOrField) {\n    for (var _len = arguments.length, preconditionOrValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      preconditionOrValues[_key - 1] = arguments[_key];\n    }\n    return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_UPDATE, () => {\n      // eslint-disable-next-line prefer-rest-params\n      (0, validate_1.validateMinNumberOfArguments)('DocumentReference.update', arguments, 1);\n      const writeBatch = new index_1.WriteBatch(this._firestore);\n      return writeBatch.update(this, dataOrField, ...preconditionOrValues).commit().then(_ref5 => {\n        let [writeResult] = _ref5;\n        return writeResult;\n      });\n    });\n  }\n  /**\n   * Attaches a listener for DocumentSnapshot events.\n   *\n   * @param {documentSnapshotCallback} onNext A callback to be called every\n   * time a new `DocumentSnapshot` is available.\n   * @param {errorCallback=} onError A callback to be called if the listen fails\n   * or is cancelled. No further callbacks will occur. If unset, errors will be\n   * logged to the console.\n   *\n   * @returns {function()} An unsubscribe function that can be called to cancel\n   * the snapshot listener.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(documentSnapshot.data());\n   *   }\n   * }, err => {\n   *   console.log(`Encountered error: ${err}`);\n   * });\n   *\n   * // Remove this listener.\n   * unsubscribe();\n   * ```\n   */\n  onSnapshot(onNext, onError) {\n    (0, validate_1.validateFunction)('onNext', onNext);\n    (0, validate_1.validateFunction)('onError', onError, {\n      optional: true\n    });\n    const watch = new (require('../watch').DocumentWatch)(this.firestore, this);\n    return watch.onSnapshot((readTime, size, docs) => {\n      for (const document of docs()) {\n        if (document.ref.path === this.path) {\n          onNext(document);\n          return;\n        }\n      }\n      // The document is missing.\n      const ref = new DocumentReference(this._firestore, this._path, this._converter);\n      const document = new document_1.DocumentSnapshotBuilder(ref);\n      document.readTime = readTime;\n      onNext(document.build());\n    }, onError || console.error);\n  }\n  /**\n   * Returns true if this `DocumentReference` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `DocumentReference` is equal to the provided\n   * value.\n   */\n  isEqual(other) {\n    return this === other || other instanceof DocumentReference && this._firestore === other._firestore && this._path.isEqual(other._path) && this._converter === other._converter;\n  }\n  /**\n   * Converts this DocumentReference to the Firestore Proto representation.\n   *\n   * @private\n   * @internal\n   */\n  toProto() {\n    return {\n      referenceValue: this.formattedName\n    };\n  }\n  /**\n   * Applies a custom data converter to this DocumentReference, allowing you to\n   * use your own custom model objects with Firestore. When you call set(),\n   * get(), etc. on the returned DocumentReference instance, the provided\n   * converter will convert between Firestore data of type `NewDbModelType` and\n   * your custom type `NewAppModelType`.\n   *\n   * Using the converter allows you to specify generic type arguments when\n   * storing and retrieving objects from Firestore.\n   *\n   * Passing in `null` as the converter parameter removes the current\n   * converter.\n   *\n   * @example\n   * ```\n   * class Post {\n   *   constructor(readonly title: string, readonly author: string) {}\n   *\n   *   toString(): string {\n   *     return this.title + ', by ' + this.author;\n   *   }\n   * }\n   *\n   * const postConverter = {\n   *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n   *     return {title: post.title, author: post.author};\n   *   },\n   *   fromFirestore(\n   *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\n   *   ): Post {\n   *     const data = snapshot.data();\n   *     return new Post(data.title, data.author);\n   *   }\n   * };\n   *\n   * const postSnap = await Firestore()\n   *   .collection('posts')\n   *   .withConverter(postConverter)\n   *   .doc().get();\n   * const post = postSnap.data();\n   * if (post !== undefined) {\n   *   post.title; // string\n   *   post.toString(); // Should be defined\n   *   post.someNonExistentProperty; // TS error\n   * }\n   *\n   * ```\n   * @param {FirestoreDataConverter | null} converter Converts objects to and\n   * from Firestore. Passing in `null` removes the current converter.\n   * @return A DocumentReference that uses the provided converter.\n   */\n  withConverter(converter) {\n    return new DocumentReference(this.firestore, this._path, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());\n  }\n}\nexports.DocumentReference = DocumentReference;","map":{"version":3,"names":["Object","defineProperty","exports","value","DocumentReference","index_1","require","path_1","types_1","collection_reference_1","util_1","validate_1","document_1","trace_util_1","constructor","_firestore","_path","_converter","defaultConverter","formattedName","projectId","firestore","databaseId","toQualifiedResourcePath","path","relativeName","id","_resourcePath","parent","CollectionReference","get","_traceUtil","startActiveSpan","SPAN_NAME_DOC_REF_GET","getAll","then","result","collection","collectionPath","validateResourcePath","append","isCollection","Error","listCollections","SPAN_NAME_DOC_REF_LIST_COLLECTIONS","tag","requestTag","initializeIfNeeded","request","pageSize","Math","pow","collectionIds","collections","sort","collectionId","push","create","data","SPAN_NAME_DOC_REF_CREATE","writeBatch","WriteBatch","commit","writeResult","delete","precondition","SPAN_NAME_DOC_REF_DELETE","set","options","SPAN_NAME_DOC_REF_SET","update","dataOrField","preconditionOrValues","SPAN_NAME_DOC_REF_UPDATE","validateMinNumberOfArguments","arguments","onSnapshot","onNext","onError","validateFunction","optional","watch","DocumentWatch","readTime","size","docs","document","ref","DocumentSnapshotBuilder","build","console","error","isEqual","other","toProto","referenceValue","withConverter","converter"],"sources":["/home/yadu/Music/Gifty/node_modules/@google-cloud/firestore/build/src/reference/document-reference.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DocumentReference = void 0;\nconst index_1 = require(\"../index\");\nconst path_1 = require(\"../path\");\nconst types_1 = require(\"../types\");\nconst collection_reference_1 = require(\"./collection-reference\");\nconst util_1 = require(\"../util\");\nconst validate_1 = require(\"../validate\");\nconst document_1 = require(\"../document\");\nconst trace_util_1 = require(\"../telemetry/trace-util\");\n/**\n * A DocumentReference refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist. A DocumentReference can\n * also be used to create a\n * [CollectionReference]{@link CollectionReference} to a\n * subcollection.\n *\n * @class DocumentReference\n */\nclass DocumentReference {\n    /**\n     * @private\n     * @internal\n     * @param _firestore The Firestore Database client.\n     * @param _path The Path of this reference.\n     * @param _converter The converter to use when serializing data.\n     */\n    constructor(_firestore, \n    /**\n     * @private\n     * @internal\n     **/\n    _path, \n    /**\n     * @internal\n     * @private\n     **/\n    _converter = (0, types_1.defaultConverter)()) {\n        this._firestore = _firestore;\n        this._path = _path;\n        this._converter = _converter;\n    }\n    /**\n     * The string representation of the DocumentReference's location.\n     * @private\n     * @internal\n     * @type {string}\n     * @name DocumentReference#formattedName\n     */\n    get formattedName() {\n        const projectId = this.firestore.projectId;\n        const databaseId = this.firestore.databaseId;\n        return this._path.toQualifiedResourcePath(projectId, databaseId)\n            .formattedName;\n    }\n    /**\n     * The [Firestore]{@link Firestore} instance for the Firestore\n     * database (useful for performing transactions, etc.).\n     *\n     * @type {Firestore}\n     * @name DocumentReference#firestore\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   let firestore = documentReference.firestore;\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\n     * });\n     * ```\n     */\n    get firestore() {\n        return this._firestore;\n    }\n    /**\n     * A string representing the path of the referenced document (relative\n     * to the root of the database).\n     *\n     * @type {string}\n     * @name DocumentReference#path\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document at '${documentReference.path}'`);\n     * });\n     * ```\n     */\n    get path() {\n        return this._path.relativeName;\n    }\n    /**\n     * The last path element of the referenced document.\n     *\n     * @type {string}\n     * @name DocumentReference#id\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document with name '${documentReference.id}'`);\n     * });\n     * ```\n     */\n    get id() {\n        return this._path.id;\n    }\n    /**\n     * Returns a resource path for this document.\n     * @private\n     * @internal\n     */\n    get _resourcePath() {\n        return this._path;\n    }\n    /**\n     * A reference to the collection to which this DocumentReference belongs.\n     *\n     * @name DocumentReference#parent\n     * @type {CollectionReference}\n     * @readonly\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     * let collectionRef = documentRef.parent;\n     *\n     * collectionRef.where('foo', '==', 'bar').get().then(results => {\n     *   console.log(`Found ${results.size} matches in parent collection`);\n     * }):\n     * ```\n     */\n    get parent() {\n        return new collection_reference_1.CollectionReference(this._firestore, this._path.parent(), this._converter);\n    }\n    /**\n     * Reads the document referred to by this DocumentReference.\n     *\n     * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\n     * DocumentSnapshot for the retrieved document on success. For missing\n     * documents, DocumentSnapshot.exists will be false. If the get() fails for\n     * other reasons, the Promise will be rejected.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log('Document retrieved successfully.');\n     *   }\n     * });\n     * ```\n     */\n    get() {\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_GET, () => {\n            return this._firestore.getAll(this).then(([result]) => result);\n        });\n    }\n    /**\n     * Gets a [CollectionReference]{@link CollectionReference} instance\n     * that refers to the collection at the specified path.\n     *\n     * @param {string} collectionPath A slash-separated path to a collection.\n     * @returns {CollectionReference} A reference to the new\n     * subcollection.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     * let subcollection = documentRef.collection('subcollection');\n     * console.log(`Path to subcollection: ${subcollection.path}`);\n     * ```\n     */\n    collection(collectionPath) {\n        (0, path_1.validateResourcePath)('collectionPath', collectionPath);\n        const path = this._path.append(collectionPath);\n        if (!path.isCollection) {\n            throw new Error(`Value for argument \"collectionPath\" must point to a collection, but was \"${collectionPath}\". Your path does not contain an odd number of components.`);\n        }\n        return new collection_reference_1.CollectionReference(this._firestore, path);\n    }\n    /**\n     * Fetches the subcollections that are direct children of this document.\n     *\n     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n     * with an array of CollectionReferences.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.listCollections().then(collections => {\n     *   for (let collection of collections) {\n     *     console.log(`Found subcollection with id: ${collection.id}`);\n     *   }\n     * });\n     * ```\n     */\n    listCollections() {\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_LIST_COLLECTIONS, () => {\n            const tag = (0, util_1.requestTag)();\n            return this.firestore.initializeIfNeeded(tag).then(() => {\n                const request = {\n                    parent: this.formattedName,\n                    // Setting `pageSize` to an arbitrarily large value lets the backend cap\n                    // the page size (currently to 300). Note that the backend rejects\n                    // MAX_INT32 (b/146883794).\n                    pageSize: Math.pow(2, 16) - 1,\n                };\n                return this._firestore\n                    .request('listCollectionIds', request, tag)\n                    .then(collectionIds => {\n                    const collections = [];\n                    // We can just sort this list using the default comparator since it\n                    // will only contain collection ids.\n                    collectionIds.sort();\n                    for (const collectionId of collectionIds) {\n                        collections.push(this.collection(collectionId));\n                    }\n                    return collections;\n                });\n            });\n        });\n    }\n    /**\n     * Create a document with the provided object values. This will fail the write\n     * if a document exists at its location.\n     *\n     * @param {DocumentData} data An object that contains the fields and data to\n     * serialize as the document.\n     * @throws {Error} If the provided input is not a valid Firestore document or if the document already exists.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this create.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * documentRef.create({foo: 'bar'}).then((res) => {\n     *   console.log(`Document created at ${res.updateTime}`);\n     * }).catch((err) => {\n     *   console.log(`Failed to create document: ${err}`);\n     * });\n     * ```\n     */\n    create(data) {\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_CREATE, () => {\n            const writeBatch = new index_1.WriteBatch(this._firestore);\n            return writeBatch\n                .create(this, data)\n                .commit()\n                .then(([writeResult]) => writeResult);\n        });\n    }\n    /**\n     * Deletes the document referred to by this `DocumentReference`.\n     *\n     * A delete for a non-existing document is treated as a success (unless\n     * lastUptimeTime is provided).\n     *\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the delete if the\n     * document was last updated at a different time.\n     * @param {boolean=} precondition.exists If set, enforces that the target\n     * document must or must not exist.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * delete time.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.delete().then(() => {\n     *   console.log('Document successfully deleted.');\n     * });\n     * ```\n     */\n    delete(precondition) {\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_DELETE, () => {\n            const writeBatch = new index_1.WriteBatch(this._firestore);\n            return writeBatch\n                .delete(this, precondition)\n                .commit()\n                .then(([writeResult]) => writeResult);\n        });\n    }\n    /**\n     * Writes to the document referred to by this DocumentReference. If the\n     * document does not yet exist, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into an\n     * existing document.\n     *\n     * @param {T|Partial<AppModelType>} data A map of the fields and values for\n     * the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge If true, set() merges the values specified\n     * in its data argument. Fields omitted from this set() call remain untouched.\n     * If your input sets any field to an empty map, all nested fields are\n     * overwritten.\n     * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched. If your input sets any field to\n     * an empty map, all nested fields are overwritten.\n     * @throws {Error} If the provided input is not a valid Firestore document.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this set.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({foo: 'bar'}).then(res => {\n     *   console.log(`Document written at ${res.updateTime}`);\n     * });\n     * ```\n     */\n    set(data, options) {\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_SET, () => {\n            let writeBatch = new index_1.WriteBatch(this._firestore);\n            if (options) {\n                writeBatch = writeBatch.set(this, data, options);\n            }\n            else {\n                writeBatch = writeBatch.set(this, data);\n            }\n            return writeBatch.commit().then(([writeResult]) => writeResult);\n        });\n    }\n    /**\n     * Updates fields in the document referred to by this DocumentReference.\n     * If the document doesn't yet exist, the update fails and the returned\n     * Promise will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {\n     * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\n     * list of field paths and values to update or a Precondition to restrict\n     * this update.\n     * @throws {Error} If the provided input is not valid Firestore data.\n     * @returns {Promise.<WriteResult>} A Promise that resolves once the\n     * data has been successfully written to the backend.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.update({foo: 'bar'}).then(res => {\n     *   console.log(`Document updated at ${res.updateTime}`);\n     * });\n     * ```\n     */\n    update(dataOrField, ...preconditionOrValues) {\n        return this._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_DOC_REF_UPDATE, () => {\n            // eslint-disable-next-line prefer-rest-params\n            (0, validate_1.validateMinNumberOfArguments)('DocumentReference.update', arguments, 1);\n            const writeBatch = new index_1.WriteBatch(this._firestore);\n            return writeBatch\n                .update(this, dataOrField, ...preconditionOrValues)\n                .commit()\n                .then(([writeResult]) => writeResult);\n        });\n    }\n    /**\n     * Attaches a listener for DocumentSnapshot events.\n     *\n     * @param {documentSnapshotCallback} onNext A callback to be called every\n     * time a new `DocumentSnapshot` is available.\n     * @param {errorCallback=} onError A callback to be called if the listen fails\n     * or is cancelled. No further callbacks will occur. If unset, errors will be\n     * logged to the console.\n     *\n     * @returns {function()} An unsubscribe function that can be called to cancel\n     * the snapshot listener.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(documentSnapshot.data());\n     *   }\n     * }, err => {\n     *   console.log(`Encountered error: ${err}`);\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     * ```\n     */\n    onSnapshot(onNext, onError) {\n        (0, validate_1.validateFunction)('onNext', onNext);\n        (0, validate_1.validateFunction)('onError', onError, { optional: true });\n        const watch = new (require('../watch').DocumentWatch)(this.firestore, this);\n        return watch.onSnapshot((readTime, size, docs) => {\n            for (const document of docs()) {\n                if (document.ref.path === this.path) {\n                    onNext(document);\n                    return;\n                }\n            }\n            // The document is missing.\n            const ref = new DocumentReference(this._firestore, this._path, this._converter);\n            const document = new document_1.DocumentSnapshotBuilder(ref);\n            document.readTime = readTime;\n            onNext(document.build());\n        }, onError || console.error);\n    }\n    /**\n     * Returns true if this `DocumentReference` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentReference` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof DocumentReference &&\n                this._firestore === other._firestore &&\n                this._path.isEqual(other._path) &&\n                this._converter === other._converter));\n    }\n    /**\n     * Converts this DocumentReference to the Firestore Proto representation.\n     *\n     * @private\n     * @internal\n     */\n    toProto() {\n        return { referenceValue: this.formattedName };\n    }\n    /**\n     * Applies a custom data converter to this DocumentReference, allowing you to\n     * use your own custom model objects with Firestore. When you call set(),\n     * get(), etc. on the returned DocumentReference instance, the provided\n     * converter will convert between Firestore data of type `NewDbModelType` and\n     * your custom type `NewAppModelType`.\n     *\n     * Using the converter allows you to specify generic type arguments when\n     * storing and retrieving objects from Firestore.\n     *\n     * Passing in `null` as the converter parameter removes the current\n     * converter.\n     *\n     * @example\n     * ```\n     * class Post {\n     *   constructor(readonly title: string, readonly author: string) {}\n     *\n     *   toString(): string {\n     *     return this.title + ', by ' + this.author;\n     *   }\n     * }\n     *\n     * const postConverter = {\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n     *     return {title: post.title, author: post.author};\n     *   },\n     *   fromFirestore(\n     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\n     *   ): Post {\n     *     const data = snapshot.data();\n     *     return new Post(data.title, data.author);\n     *   }\n     * };\n     *\n     * const postSnap = await Firestore()\n     *   .collection('posts')\n     *   .withConverter(postConverter)\n     *   .doc().get();\n     * const post = postSnap.data();\n     * if (post !== undefined) {\n     *   post.title; // string\n     *   post.toString(); // Should be defined\n     *   post.someNonExistentProperty; // TS error\n     * }\n     *\n     * ```\n     * @param {FirestoreDataConverter | null} converter Converts objects to and\n     * from Firestore. Passing in `null` removes the current converter.\n     * @return A DocumentReference that uses the provided converter.\n     */\n    withConverter(converter) {\n        return new DocumentReference(this.firestore, this._path, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());\n    }\n}\nexports.DocumentReference = DocumentReference;\n//# sourceMappingURL=document-reference.js.map"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,iBAAiB,GAAG,KAAK,CAAC;AAClC,MAAMC,OAAO,GAAGC,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMC,MAAM,GAAGD,OAAO,CAAC,SAAS,CAAC;AACjC,MAAME,OAAO,GAAGF,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMG,sBAAsB,GAAGH,OAAO,CAAC,wBAAwB,CAAC;AAChE,MAAMI,MAAM,GAAGJ,OAAO,CAAC,SAAS,CAAC;AACjC,MAAMK,UAAU,GAAGL,OAAO,CAAC,aAAa,CAAC;AACzC,MAAMM,UAAU,GAAGN,OAAO,CAAC,aAAa,CAAC;AACzC,MAAMO,YAAY,GAAGP,OAAO,CAAC,yBAAyB,CAAC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMF,iBAAiB,CAAC;EACpB;AACJ;AACA;AACA;AACA;AACA;AACA;EACIU,WAAW,CAACC,UAAU;EACtB;AACJ;AACA;AACA;EACIC,KAAK,EAKyC;IAAA,IAA9CC,UAAU,uEAAG,CAAC,CAAC,EAAET,OAAO,CAACU,gBAAgB,GAAG;IACxC,IAAI,CAACH,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,UAAU,GAAGA,UAAU;EAChC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIE,aAAa,GAAG;IAChB,MAAMC,SAAS,GAAG,IAAI,CAACC,SAAS,CAACD,SAAS;IAC1C,MAAME,UAAU,GAAG,IAAI,CAACD,SAAS,CAACC,UAAU;IAC5C,OAAO,IAAI,CAACN,KAAK,CAACO,uBAAuB,CAACH,SAAS,EAAEE,UAAU,CAAC,CAC3DH,aAAa;EACtB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIE,SAAS,GAAG;IACZ,OAAO,IAAI,CAACN,UAAU;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIS,IAAI,GAAG;IACP,OAAO,IAAI,CAACR,KAAK,CAACS,YAAY;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,EAAE,GAAG;IACL,OAAO,IAAI,CAACV,KAAK,CAACU,EAAE;EACxB;EACA;AACJ;AACA;AACA;AACA;EACI,IAAIC,aAAa,GAAG;IAChB,OAAO,IAAI,CAACX,KAAK;EACrB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIY,MAAM,GAAG;IACT,OAAO,IAAInB,sBAAsB,CAACoB,mBAAmB,CAAC,IAAI,CAACd,UAAU,EAAE,IAAI,CAACC,KAAK,CAACY,MAAM,EAAE,EAAE,IAAI,CAACX,UAAU,CAAC;EAChH;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIa,GAAG,GAAG;IACF,OAAO,IAAI,CAACf,UAAU,CAACgB,UAAU,CAACC,eAAe,CAACnB,YAAY,CAACoB,qBAAqB,EAAE,MAAM;MACxF,OAAO,IAAI,CAAClB,UAAU,CAACmB,MAAM,CAAC,IAAI,CAAC,CAACC,IAAI,CAAC;QAAA,IAAC,CAACC,MAAM,CAAC;QAAA,OAAKA,MAAM;MAAA,EAAC;IAClE,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,UAAU,CAACC,cAAc,EAAE;IACvB,CAAC,CAAC,EAAE/B,MAAM,CAACgC,oBAAoB,EAAE,gBAAgB,EAAED,cAAc,CAAC;IAClE,MA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"},"metadata":{},"sourceType":"script","externalDependencies":[]}