{"ast":null,"code":"/*! firebase-admin v12.7.0 */\n\"use strict\";\n\n/*!\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JwtErrorCode = exports.JwtError = exports.decodeJwt = exports.verifyJwtSignature = exports.EmulatorSignatureVerifier = exports.PublicKeySignatureVerifier = exports.UrlKeyFetcher = exports.JwksFetcher = exports.ALGORITHM_RS256 = void 0;\nconst validator = require(\"./validator\");\nconst jwt = require(\"jsonwebtoken\");\nconst jwks = require(\"jwks-rsa\");\nconst api_request_1 = require(\"../utils/api-request\");\nexports.ALGORITHM_RS256 = 'RS256';\n// `jsonwebtoken` converts errors from the `getKey` callback to its own `JsonWebTokenError` type\n// and prefixes the error message with the following. Use the prefix to identify errors thrown\n// from the key provider callback.\n// https://github.com/auth0/node-jsonwebtoken/blob/d71e383862fc735991fd2e759181480f066bf138/verify.js#L96\nconst JWT_CALLBACK_ERROR_PREFIX = 'error in secret or public key callback: ';\nconst NO_MATCHING_KID_ERROR_MESSAGE = 'no-matching-kid-error';\nconst NO_KID_IN_HEADER_ERROR_MESSAGE = 'no-kid-in-header-error';\nconst HOUR_IN_SECONDS = 3600;\nclass JwksFetcher {\n  constructor(jwksUrl, httpAgent) {\n    this.publicKeysExpireAt = 0;\n    if (!validator.isURL(jwksUrl)) {\n      throw new Error('The provided JWKS URL is not a valid URL.');\n    }\n    this.client = jwks({\n      jwksUri: jwksUrl,\n      cache: false,\n      requestAgent: httpAgent\n    });\n  }\n  fetchPublicKeys() {\n    if (this.shouldRefresh()) {\n      return this.refresh();\n    }\n    return Promise.resolve(this.publicKeys);\n  }\n  shouldRefresh() {\n    return !this.publicKeys || this.publicKeysExpireAt <= Date.now();\n  }\n  refresh() {\n    return this.client.getSigningKeys().then(signingKeys => {\n      // reset expire at from previous set of keys.\n      this.publicKeysExpireAt = 0;\n      const newKeys = signingKeys.reduce((map, signingKey) => {\n        map[signingKey.kid] = signingKey.getPublicKey();\n        return map;\n      }, {});\n      this.publicKeysExpireAt = Date.now() + HOUR_IN_SECONDS * 6 * 1000;\n      this.publicKeys = newKeys;\n      return newKeys;\n    }).catch(err => {\n      throw new Error(`Error fetching Json Web Keys: ${err.message}`);\n    });\n  }\n}\nexports.JwksFetcher = JwksFetcher;\n/**\n * Class to fetch public keys from a client certificates URL.\n */\nclass UrlKeyFetcher {\n  constructor(clientCertUrl, httpAgent) {\n    this.clientCertUrl = clientCertUrl;\n    this.httpAgent = httpAgent;\n    this.publicKeysExpireAt = 0;\n    if (!validator.isURL(clientCertUrl)) {\n      throw new Error('The provided public client certificate URL is not a valid URL.');\n    }\n  }\n  /**\n   * Fetches the public keys for the Google certs.\n   *\n   * @returns A promise fulfilled with public keys for the Google certs.\n   */\n  fetchPublicKeys() {\n    if (this.shouldRefresh()) {\n      return this.refresh();\n    }\n    return Promise.resolve(this.publicKeys);\n  }\n  /**\n   * Checks if the cached public keys need to be refreshed.\n   *\n   * @returns Whether the keys should be fetched from the client certs url or not.\n   */\n  shouldRefresh() {\n    return !this.publicKeys || this.publicKeysExpireAt <= Date.now();\n  }\n  refresh() {\n    const client = new api_request_1.HttpClient();\n    const request = {\n      method: 'GET',\n      url: this.clientCertUrl,\n      httpAgent: this.httpAgent\n    };\n    return client.send(request).then(resp => {\n      if (!resp.isJson() || resp.data.error) {\n        // Treat all non-json messages and messages with an 'error' field as\n        // error responses.\n        throw new api_request_1.RequestResponseError(resp);\n      }\n      // reset expire at from previous set of keys.\n      this.publicKeysExpireAt = 0;\n      if (Object.prototype.hasOwnProperty.call(resp.headers, 'cache-control')) {\n        const cacheControlHeader = resp.headers['cache-control'];\n        const parts = cacheControlHeader.split(',');\n        parts.forEach(part => {\n          const subParts = part.trim().split('=');\n          if (subParts[0] === 'max-age') {\n            const maxAge = +subParts[1];\n            this.publicKeysExpireAt = Date.now() + maxAge * 1000;\n          }\n        });\n      }\n      this.publicKeys = resp.data;\n      return resp.data;\n    }).catch(err => {\n      if (err instanceof api_request_1.RequestResponseError) {\n        let errorMessage = 'Error fetching public keys for Google certs: ';\n        const resp = err.response;\n        if (resp.isJson() && resp.data.error) {\n          errorMessage += `${resp.data.error}`;\n          if (resp.data.error_description) {\n            errorMessage += ' (' + resp.data.error_description + ')';\n          }\n        } else {\n          errorMessage += `${resp.text}`;\n        }\n        throw new Error(errorMessage);\n      }\n      throw err;\n    });\n  }\n}\nexports.UrlKeyFetcher = UrlKeyFetcher;\n/**\n * Class for verifying JWT signature with a public key.\n */\nclass PublicKeySignatureVerifier {\n  constructor(keyFetcher) {\n    this.keyFetcher = keyFetcher;\n    if (!validator.isNonNullObject(keyFetcher)) {\n      throw new Error('The provided key fetcher is not an object or null.');\n    }\n  }\n  static withCertificateUrl(clientCertUrl, httpAgent) {\n    return new PublicKeySignatureVerifier(new UrlKeyFetcher(clientCertUrl, httpAgent));\n  }\n  static withJwksUrl(jwksUrl, httpAgent) {\n    return new PublicKeySignatureVerifier(new JwksFetcher(jwksUrl, httpAgent));\n  }\n  verify(token) {\n    if (!validator.isString(token)) {\n      return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n    }\n    return verifyJwtSignature(token, getKeyCallback(this.keyFetcher), {\n      algorithms: [exports.ALGORITHM_RS256]\n    }).catch(error => {\n      if (error.code === JwtErrorCode.NO_KID_IN_HEADER) {\n        // No kid in JWT header. Try with all the public keys.\n        return this.verifyWithoutKid(token);\n      }\n      throw error;\n    });\n  }\n  verifyWithoutKid(token) {\n    return this.keyFetcher.fetchPublicKeys().then(publicKeys => this.verifyWithAllKeys(token, publicKeys));\n  }\n  verifyWithAllKeys(token, keys) {\n    const promises = [];\n    Object.values(keys).forEach(key => {\n      const result = verifyJwtSignature(token, key).then(() => true).catch(error => {\n        if (error.code === JwtErrorCode.TOKEN_EXPIRED) {\n          throw error;\n        }\n        return false;\n      });\n      promises.push(result);\n    });\n    return Promise.all(promises).then(result => {\n      if (result.every(r => r === false)) {\n        throw new JwtError(JwtErrorCode.INVALID_SIGNATURE, 'Invalid token signature.');\n      }\n    });\n  }\n}\nexports.PublicKeySignatureVerifier = PublicKeySignatureVerifier;\n/**\n * Class for verifying unsigned (emulator) JWTs.\n */\nclass EmulatorSignatureVerifier {\n  verify(token) {\n    // Signature checks skipped for emulator; no need to fetch public keys.\n    return verifyJwtSignature(token, undefined, {\n      algorithms: ['none']\n    });\n  }\n}\nexports.EmulatorSignatureVerifier = EmulatorSignatureVerifier;\n/**\n * Provides a callback to fetch public keys.\n *\n * @param fetcher - KeyFetcher to fetch the keys from.\n * @returns A callback function that can be used to get keys in `jsonwebtoken`.\n */\nfunction getKeyCallback(fetcher) {\n  return (header, callback) => {\n    if (!header.kid) {\n      callback(new Error(NO_KID_IN_HEADER_ERROR_MESSAGE));\n    }\n    const kid = header.kid || '';\n    fetcher.fetchPublicKeys().then(publicKeys => {\n      if (!Object.prototype.hasOwnProperty.call(publicKeys, kid)) {\n        callback(new Error(NO_MATCHING_KID_ERROR_MESSAGE));\n      } else {\n        callback(null, publicKeys[kid]);\n      }\n    }).catch(error => {\n      callback(error);\n    });\n  };\n}\n/**\n * Verifies the signature of a JWT using the provided secret or a function to fetch\n * the secret or public key.\n *\n * @param token - The JWT to be verified.\n * @param secretOrPublicKey - The secret or a function to fetch the secret or public key.\n * @param options - JWT verification options.\n * @returns A Promise resolving for a token with a valid signature.\n */\nfunction verifyJwtSignature(token, secretOrPublicKey, options) {\n  if (!validator.isString(token)) {\n    return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n  }\n  return new Promise((resolve, reject) => {\n    jwt.verify(token, secretOrPublicKey, options, error => {\n      if (!error) {\n        return resolve();\n      }\n      if (error.name === 'TokenExpiredError') {\n        return reject(new JwtError(JwtErrorCode.TOKEN_EXPIRED, 'The provided token has expired. Get a fresh token from your ' + 'client app and try again.'));\n      } else if (error.name === 'JsonWebTokenError') {\n        if (error.message && error.message.includes(JWT_CALLBACK_ERROR_PREFIX)) {\n          const message = error.message.split(JWT_CALLBACK_ERROR_PREFIX).pop() || 'Error fetching public keys.';\n          let code = JwtErrorCode.KEY_FETCH_ERROR;\n          if (message === NO_MATCHING_KID_ERROR_MESSAGE) {\n            code = JwtErrorCode.NO_MATCHING_KID;\n          } else if (message === NO_KID_IN_HEADER_ERROR_MESSAGE) {\n            code = JwtErrorCode.NO_KID_IN_HEADER;\n          }\n          return reject(new JwtError(code, message));\n        }\n      }\n      return reject(new JwtError(JwtErrorCode.INVALID_SIGNATURE, error.message));\n    });\n  });\n}\nexports.verifyJwtSignature = verifyJwtSignature;\n/**\n * Decodes general purpose Firebase JWTs.\n *\n * @param jwtToken - JWT token to be decoded.\n * @returns Decoded token containing the header and payload.\n */\nfunction decodeJwt(jwtToken) {\n  if (!validator.isString(jwtToken)) {\n    return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n  }\n  const fullDecodedToken = jwt.decode(jwtToken, {\n    complete: true\n  });\n  if (!fullDecodedToken) {\n    return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'Decoding token failed.'));\n  }\n  const header = fullDecodedToken?.header;\n  const payload = fullDecodedToken?.payload;\n  return Promise.resolve({\n    header,\n    payload\n  });\n}\nexports.decodeJwt = decodeJwt;\n/**\n * Jwt error code structure.\n *\n * @param code - The error code.\n * @param message - The error message.\n * @constructor\n */\nclass JwtError extends Error {\n  constructor(code, message) {\n    super(message);\n    this.code = code;\n    this.message = message;\n    this.__proto__ = JwtError.prototype;\n  }\n}\nexports.JwtError = JwtError;\n/**\n * JWT error codes.\n */\nvar JwtErrorCode;\n(function (JwtErrorCode) {\n  JwtErrorCode[\"INVALID_ARGUMENT\"] = \"invalid-argument\";\n  JwtErrorCode[\"INVALID_CREDENTIAL\"] = \"invalid-credential\";\n  JwtErrorCode[\"TOKEN_EXPIRED\"] = \"token-expired\";\n  JwtErrorCode[\"INVALID_SIGNATURE\"] = \"invalid-token\";\n  JwtErrorCode[\"NO_MATCHING_KID\"] = \"no-matching-kid-error\";\n  JwtErrorCode[\"NO_KID_IN_HEADER\"] = \"no-kid-error\";\n  JwtErrorCode[\"KEY_FETCH_ERROR\"] = \"key-fetch-error\";\n})(JwtErrorCode || (exports.JwtErrorCode = JwtErrorCode = {}));","map":{"version":3,"names":["Object","defineProperty","exports","value","JwtErrorCode","JwtError","decodeJwt","verifyJwtSignature","EmulatorSignatureVerifier","PublicKeySignatureVerifier","UrlKeyFetcher","JwksFetcher","ALGORITHM_RS256","validator","require","jwt","jwks","api_request_1","JWT_CALLBACK_ERROR_PREFIX","NO_MATCHING_KID_ERROR_MESSAGE","NO_KID_IN_HEADER_ERROR_MESSAGE","HOUR_IN_SECONDS","constructor","jwksUrl","httpAgent","publicKeysExpireAt","isURL","Error","client","jwksUri","cache","requestAgent","fetchPublicKeys","shouldRefresh","refresh","Promise","resolve","publicKeys","Date","now","getSigningKeys","then","signingKeys","newKeys","reduce","map","signingKey","kid","getPublicKey","catch","err","message","clientCertUrl","HttpClient","request","method","url","send","resp","isJson","data","error","RequestResponseError","prototype","hasOwnProperty","call","headers","cacheControlHeader","parts","split","forEach","part","subParts","trim","maxAge","errorMessage","response","error_description","text","keyFetcher","isNonNullObject","withCertificateUrl","withJwksUrl","verify","token","isString","reject","INVALID_ARGUMENT","getKeyCallback","algorithms","code","NO_KID_IN_HEADER","verifyWithoutKid","verifyWithAllKeys","keys","promises","values","key","result","TOKEN_EXPIRED","push","all","every","r","INVALID_SIGNATURE","undefined","fetcher","header","callback","secretOrPublicKey","options","name","includes","pop","KEY_FETCH_ERROR","NO_MATCHING_KID","jwtToken","fullDecodedToken","decode","complete","payload","__proto__"],"sources":["/home/yadu/Music/Gifty/node_modules/firebase-admin/lib/utils/jwt.js"],"sourcesContent":["/*! firebase-admin v12.7.0 */\n\"use strict\";\n/*!\n * Copyright 2021 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JwtErrorCode = exports.JwtError = exports.decodeJwt = exports.verifyJwtSignature = exports.EmulatorSignatureVerifier = exports.PublicKeySignatureVerifier = exports.UrlKeyFetcher = exports.JwksFetcher = exports.ALGORITHM_RS256 = void 0;\nconst validator = require(\"./validator\");\nconst jwt = require(\"jsonwebtoken\");\nconst jwks = require(\"jwks-rsa\");\nconst api_request_1 = require(\"../utils/api-request\");\nexports.ALGORITHM_RS256 = 'RS256';\n// `jsonwebtoken` converts errors from the `getKey` callback to its own `JsonWebTokenError` type\n// and prefixes the error message with the following. Use the prefix to identify errors thrown\n// from the key provider callback.\n// https://github.com/auth0/node-jsonwebtoken/blob/d71e383862fc735991fd2e759181480f066bf138/verify.js#L96\nconst JWT_CALLBACK_ERROR_PREFIX = 'error in secret or public key callback: ';\nconst NO_MATCHING_KID_ERROR_MESSAGE = 'no-matching-kid-error';\nconst NO_KID_IN_HEADER_ERROR_MESSAGE = 'no-kid-in-header-error';\nconst HOUR_IN_SECONDS = 3600;\nclass JwksFetcher {\n    constructor(jwksUrl, httpAgent) {\n        this.publicKeysExpireAt = 0;\n        if (!validator.isURL(jwksUrl)) {\n            throw new Error('The provided JWKS URL is not a valid URL.');\n        }\n        this.client = jwks({\n            jwksUri: jwksUrl,\n            cache: false,\n            requestAgent: httpAgent,\n        });\n    }\n    fetchPublicKeys() {\n        if (this.shouldRefresh()) {\n            return this.refresh();\n        }\n        return Promise.resolve(this.publicKeys);\n    }\n    shouldRefresh() {\n        return !this.publicKeys || this.publicKeysExpireAt <= Date.now();\n    }\n    refresh() {\n        return this.client.getSigningKeys()\n            .then((signingKeys) => {\n            // reset expire at from previous set of keys.\n            this.publicKeysExpireAt = 0;\n            const newKeys = signingKeys.reduce((map, signingKey) => {\n                map[signingKey.kid] = signingKey.getPublicKey();\n                return map;\n            }, {});\n            this.publicKeysExpireAt = Date.now() + (HOUR_IN_SECONDS * 6 * 1000);\n            this.publicKeys = newKeys;\n            return newKeys;\n        }).catch((err) => {\n            throw new Error(`Error fetching Json Web Keys: ${err.message}`);\n        });\n    }\n}\nexports.JwksFetcher = JwksFetcher;\n/**\n * Class to fetch public keys from a client certificates URL.\n */\nclass UrlKeyFetcher {\n    constructor(clientCertUrl, httpAgent) {\n        this.clientCertUrl = clientCertUrl;\n        this.httpAgent = httpAgent;\n        this.publicKeysExpireAt = 0;\n        if (!validator.isURL(clientCertUrl)) {\n            throw new Error('The provided public client certificate URL is not a valid URL.');\n        }\n    }\n    /**\n     * Fetches the public keys for the Google certs.\n     *\n     * @returns A promise fulfilled with public keys for the Google certs.\n     */\n    fetchPublicKeys() {\n        if (this.shouldRefresh()) {\n            return this.refresh();\n        }\n        return Promise.resolve(this.publicKeys);\n    }\n    /**\n     * Checks if the cached public keys need to be refreshed.\n     *\n     * @returns Whether the keys should be fetched from the client certs url or not.\n     */\n    shouldRefresh() {\n        return !this.publicKeys || this.publicKeysExpireAt <= Date.now();\n    }\n    refresh() {\n        const client = new api_request_1.HttpClient();\n        const request = {\n            method: 'GET',\n            url: this.clientCertUrl,\n            httpAgent: this.httpAgent,\n        };\n        return client.send(request).then((resp) => {\n            if (!resp.isJson() || resp.data.error) {\n                // Treat all non-json messages and messages with an 'error' field as\n                // error responses.\n                throw new api_request_1.RequestResponseError(resp);\n            }\n            // reset expire at from previous set of keys.\n            this.publicKeysExpireAt = 0;\n            if (Object.prototype.hasOwnProperty.call(resp.headers, 'cache-control')) {\n                const cacheControlHeader = resp.headers['cache-control'];\n                const parts = cacheControlHeader.split(',');\n                parts.forEach((part) => {\n                    const subParts = part.trim().split('=');\n                    if (subParts[0] === 'max-age') {\n                        const maxAge = +subParts[1];\n                        this.publicKeysExpireAt = Date.now() + (maxAge * 1000);\n                    }\n                });\n            }\n            this.publicKeys = resp.data;\n            return resp.data;\n        }).catch((err) => {\n            if (err instanceof api_request_1.RequestResponseError) {\n                let errorMessage = 'Error fetching public keys for Google certs: ';\n                const resp = err.response;\n                if (resp.isJson() && resp.data.error) {\n                    errorMessage += `${resp.data.error}`;\n                    if (resp.data.error_description) {\n                        errorMessage += ' (' + resp.data.error_description + ')';\n                    }\n                }\n                else {\n                    errorMessage += `${resp.text}`;\n                }\n                throw new Error(errorMessage);\n            }\n            throw err;\n        });\n    }\n}\nexports.UrlKeyFetcher = UrlKeyFetcher;\n/**\n * Class for verifying JWT signature with a public key.\n */\nclass PublicKeySignatureVerifier {\n    constructor(keyFetcher) {\n        this.keyFetcher = keyFetcher;\n        if (!validator.isNonNullObject(keyFetcher)) {\n            throw new Error('The provided key fetcher is not an object or null.');\n        }\n    }\n    static withCertificateUrl(clientCertUrl, httpAgent) {\n        return new PublicKeySignatureVerifier(new UrlKeyFetcher(clientCertUrl, httpAgent));\n    }\n    static withJwksUrl(jwksUrl, httpAgent) {\n        return new PublicKeySignatureVerifier(new JwksFetcher(jwksUrl, httpAgent));\n    }\n    verify(token) {\n        if (!validator.isString(token)) {\n            return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n        }\n        return verifyJwtSignature(token, getKeyCallback(this.keyFetcher), { algorithms: [exports.ALGORITHM_RS256] })\n            .catch((error) => {\n            if (error.code === JwtErrorCode.NO_KID_IN_HEADER) {\n                // No kid in JWT header. Try with all the public keys.\n                return this.verifyWithoutKid(token);\n            }\n            throw error;\n        });\n    }\n    verifyWithoutKid(token) {\n        return this.keyFetcher.fetchPublicKeys()\n            .then(publicKeys => this.verifyWithAllKeys(token, publicKeys));\n    }\n    verifyWithAllKeys(token, keys) {\n        const promises = [];\n        Object.values(keys).forEach((key) => {\n            const result = verifyJwtSignature(token, key)\n                .then(() => true)\n                .catch((error) => {\n                if (error.code === JwtErrorCode.TOKEN_EXPIRED) {\n                    throw error;\n                }\n                return false;\n            });\n            promises.push(result);\n        });\n        return Promise.all(promises)\n            .then((result) => {\n            if (result.every((r) => r === false)) {\n                throw new JwtError(JwtErrorCode.INVALID_SIGNATURE, 'Invalid token signature.');\n            }\n        });\n    }\n}\nexports.PublicKeySignatureVerifier = PublicKeySignatureVerifier;\n/**\n * Class for verifying unsigned (emulator) JWTs.\n */\nclass EmulatorSignatureVerifier {\n    verify(token) {\n        // Signature checks skipped for emulator; no need to fetch public keys.\n        return verifyJwtSignature(token, undefined, { algorithms: ['none'] });\n    }\n}\nexports.EmulatorSignatureVerifier = EmulatorSignatureVerifier;\n/**\n * Provides a callback to fetch public keys.\n *\n * @param fetcher - KeyFetcher to fetch the keys from.\n * @returns A callback function that can be used to get keys in `jsonwebtoken`.\n */\nfunction getKeyCallback(fetcher) {\n    return (header, callback) => {\n        if (!header.kid) {\n            callback(new Error(NO_KID_IN_HEADER_ERROR_MESSAGE));\n        }\n        const kid = header.kid || '';\n        fetcher.fetchPublicKeys().then((publicKeys) => {\n            if (!Object.prototype.hasOwnProperty.call(publicKeys, kid)) {\n                callback(new Error(NO_MATCHING_KID_ERROR_MESSAGE));\n            }\n            else {\n                callback(null, publicKeys[kid]);\n            }\n        })\n            .catch(error => {\n            callback(error);\n        });\n    };\n}\n/**\n * Verifies the signature of a JWT using the provided secret or a function to fetch\n * the secret or public key.\n *\n * @param token - The JWT to be verified.\n * @param secretOrPublicKey - The secret or a function to fetch the secret or public key.\n * @param options - JWT verification options.\n * @returns A Promise resolving for a token with a valid signature.\n */\nfunction verifyJwtSignature(token, secretOrPublicKey, options) {\n    if (!validator.isString(token)) {\n        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n    }\n    return new Promise((resolve, reject) => {\n        jwt.verify(token, secretOrPublicKey, options, (error) => {\n            if (!error) {\n                return resolve();\n            }\n            if (error.name === 'TokenExpiredError') {\n                return reject(new JwtError(JwtErrorCode.TOKEN_EXPIRED, 'The provided token has expired. Get a fresh token from your ' +\n                    'client app and try again.'));\n            }\n            else if (error.name === 'JsonWebTokenError') {\n                if (error.message && error.message.includes(JWT_CALLBACK_ERROR_PREFIX)) {\n                    const message = error.message.split(JWT_CALLBACK_ERROR_PREFIX).pop() || 'Error fetching public keys.';\n                    let code = JwtErrorCode.KEY_FETCH_ERROR;\n                    if (message === NO_MATCHING_KID_ERROR_MESSAGE) {\n                        code = JwtErrorCode.NO_MATCHING_KID;\n                    }\n                    else if (message === NO_KID_IN_HEADER_ERROR_MESSAGE) {\n                        code = JwtErrorCode.NO_KID_IN_HEADER;\n                    }\n                    return reject(new JwtError(code, message));\n                }\n            }\n            return reject(new JwtError(JwtErrorCode.INVALID_SIGNATURE, error.message));\n        });\n    });\n}\nexports.verifyJwtSignature = verifyJwtSignature;\n/**\n * Decodes general purpose Firebase JWTs.\n *\n * @param jwtToken - JWT token to be decoded.\n * @returns Decoded token containing the header and payload.\n */\nfunction decodeJwt(jwtToken) {\n    if (!validator.isString(jwtToken)) {\n        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'The provided token must be a string.'));\n    }\n    const fullDecodedToken = jwt.decode(jwtToken, {\n        complete: true,\n    });\n    if (!fullDecodedToken) {\n        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, 'Decoding token failed.'));\n    }\n    const header = fullDecodedToken?.header;\n    const payload = fullDecodedToken?.payload;\n    return Promise.resolve({ header, payload });\n}\nexports.decodeJwt = decodeJwt;\n/**\n * Jwt error code structure.\n *\n * @param code - The error code.\n * @param message - The error message.\n * @constructor\n */\nclass JwtError extends Error {\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n        this.message = message;\n        this.__proto__ = JwtError.prototype;\n    }\n}\nexports.JwtError = JwtError;\n/**\n * JWT error codes.\n */\nvar JwtErrorCode;\n(function (JwtErrorCode) {\n    JwtErrorCode[\"INVALID_ARGUMENT\"] = \"invalid-argument\";\n    JwtErrorCode[\"INVALID_CREDENTIAL\"] = \"invalid-credential\";\n    JwtErrorCode[\"TOKEN_EXPIRED\"] = \"token-expired\";\n    JwtErrorCode[\"INVALID_SIGNATURE\"] = \"invalid-token\";\n    JwtErrorCode[\"NO_MATCHING_KID\"] = \"no-matching-kid-error\";\n    JwtErrorCode[\"NO_KID_IN_HEADER\"] = \"no-kid-error\";\n    JwtErrorCode[\"KEY_FETCH_ERROR\"] = \"key-fetch-error\";\n})(JwtErrorCode || (exports.JwtErrorCode = JwtErrorCode = {}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}