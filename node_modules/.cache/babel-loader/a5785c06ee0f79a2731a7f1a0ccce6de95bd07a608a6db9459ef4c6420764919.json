{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregateQuery = void 0;\nconst assert = require(\"assert\");\nconst deepEqual = require(\"fast-deep-equal\");\nconst aggregate_1 = require(\"../aggregate\");\nconst timestamp_1 = require(\"../timestamp\");\nconst util_1 = require(\"../util\");\nconst query_profile_1 = require(\"../query-profile\");\nconst logger_1 = require(\"../logger\");\nconst aggregate_query_snapshot_1 = require(\"./aggregate-query-snapshot\");\nconst stream_1 = require(\"stream\");\nconst trace_util_1 = require(\"../telemetry/trace-util\");\n/**\n * A query that calculates aggregations over an underlying query.\n */\nclass AggregateQuery {\n  /**\n   * @internal\n   * @param _query The query whose aggregations will be calculated by this\n   * object.\n   * @param _aggregates The aggregations that will be performed by this query.\n   */\n  constructor(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _query, _aggregates) {\n    this._query = _query;\n    this._aggregates = _aggregates;\n    this.clientAliasToServerAliasMap = {};\n    this.serverAliasToClientAliasMap = {};\n    // Client-side aliases may be too long and exceed the 1500-byte string size limit.\n    // Such long strings do not need to be transferred over the wire either.\n    // The client maps the user's alias to a short form alias and send that to the server.\n    let aggregationNum = 0;\n    for (const clientAlias in this._aggregates) {\n      if (Object.prototype.hasOwnProperty.call(this._aggregates, clientAlias)) {\n        const serverAlias = `aggregate_${aggregationNum++}`;\n        this.clientAliasToServerAliasMap[clientAlias] = serverAlias;\n        this.serverAliasToClientAliasMap[serverAlias] = clientAlias;\n      }\n    }\n  }\n  /** The query whose aggregations will be calculated by this object. */\n  get query() {\n    return this._query;\n  }\n  /**\n   * Executes this query.\n   *\n   * @return A promise that will be resolved with the results of the query.\n   */\n  async get() {\n    return this._query._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_AGGREGATION_QUERY_GET, async () => {\n      const {\n        result\n      } = await this._get();\n      return result;\n    });\n  }\n  /**\n   * Internal get() method that accepts an optional transaction options and\n   * returns a snapshot with transaction and explain metadata.\n   *\n   * @private\n   * @internal\n   * @param transactionOrReadTime A transaction ID, options to start a new\n   *  transaction, or timestamp to use as read time.\n   */\n  async _get(transactionOrReadTime) {\n    const response = await this._getResponse(transactionOrReadTime);\n    if (!response.result) {\n      throw new Error('No AggregateQuery results');\n    }\n    return response;\n  }\n  /**\n   * Internal get() method that accepts an optional transaction id, and returns\n   * transaction metadata.\n   *\n   * @private\n   * @internal\n   * @param transactionOrReadTime A transaction ID, options to start a new\n   *  transaction, or timestamp to use as read time.\n   */\n  _getResponse(transactionOrReadTime, explainOptions) {\n    // Capture the error stack to preserve stack tracing across async calls.\n    const stack = Error().stack;\n    return new Promise((resolve, reject) => {\n      const output = {};\n      const stream = this._stream(transactionOrReadTime, explainOptions);\n      stream.on('error', err => {\n        reject((0, util_1.wrapError)(err, stack));\n      });\n      stream.on('data', data => {\n        if (data.transaction) {\n          output.transaction = data.transaction;\n        }\n        if (data.explainMetrics) {\n          output.explainMetrics = data.explainMetrics;\n        }\n        if (data.result) {\n          output.result = data.result;\n        }\n      });\n      stream.on('end', () => {\n        stream.destroy();\n        resolve(output);\n      });\n    });\n  }\n  /**\n   * Internal streaming method that accepts an optional transaction ID.\n   *\n   * BEWARE: If `transactionOrReadTime` is `ITransactionOptions`, then the first\n   * response in the stream will be a transaction response.\n   *\n   * @private\n   * @internal\n   * @param transactionOrReadTime A transaction ID, options to start a new\n   *  transaction, or timestamp to use as read time.\n   * @param explainOptions Options to use for explaining the query (if any).\n   * @returns A stream of document results optionally preceded by a transaction response.\n   */\n  _stream(transactionOrReadTime, explainOptions) {\n    const tag = (0, util_1.requestTag)();\n    const firestore = this._query.firestore;\n    const stream = new stream_1.Transform({\n      objectMode: true,\n      transform: (proto, enc, callback) => {\n        var _a;\n        const output = {};\n        // Proto comes with zero-length buffer by default\n        if ((_a = proto.transaction) === null || _a === void 0 ? void 0 : _a.length) {\n          output.transaction = proto.transaction;\n        }\n        if (proto.explainMetrics) {\n          output.explainMetrics = query_profile_1.ExplainMetrics._fromProto(proto.explainMetrics, firestore._serializer);\n        }\n        if (proto.result) {\n          const readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n          const data = this.decodeResult(proto.result);\n          output.result = new aggregate_query_snapshot_1.AggregateQuerySnapshot(this, readTime, data);\n        }\n        callback(undefined, output);\n      }\n    });\n    firestore.initializeIfNeeded(tag).then(async () => {\n      // `toProto()` might throw an exception. We rely on the behavior of an\n      // async function to convert this exception into the rejected Promise we\n      // catch below.\n      const request = this.toProto(transactionOrReadTime, explainOptions);\n      const backendStream = await firestore.requestStream('runAggregationQuery', /* bidirectional= */false, request, tag);\n      stream.on('close', () => {\n        backendStream.resume();\n        backendStream.end();\n      });\n      backendStream.on('error', err => {\n        // TODO(group-by) When group-by queries are supported for aggregates\n        // consider implementing retries if the stream is making progress\n        // receiving results for groups. See the use of lastReceivedDocument\n        // in the retry strategy for runQuery.\n        // Also note that explain queries should not be retried.\n        backendStream.unpipe(stream);\n        (0, logger_1.logger)('AggregateQuery._stream', tag, 'AggregateQuery failed with stream error:', err);\n        this._query._firestore._traceUtil.currentSpan().addEvent(`${trace_util_1.SPAN_NAME_RUN_AGGREGATION_QUERY}: Error.`, {\n          'error.message': err.message\n        });\n        stream.destroy(err);\n      });\n      backendStream.resume();\n      backendStream.pipe(stream);\n    }).catch(e => stream.destroy(e));\n    return stream;\n  }\n  /**\n   * Internal method to decode values within result.\n   * @private\n   */\n  decodeResult(proto) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const data = {};\n    const fields = proto.aggregateFields;\n    if (fields) {\n      const serializer = this._query.firestore._serializer;\n      for (const prop of Object.keys(fields)) {\n        const alias = this.serverAliasToClientAliasMap[prop];\n        assert(alias !== null && alias !== undefined, `'${prop}' not present in server-client alias mapping.`);\n        if (this._aggregates[alias] === undefined) {\n          throw new Error(`Unexpected alias [${prop}] in result aggregate result`);\n        }\n        data[alias] = serializer.decodeValue(fields[prop]);\n      }\n    }\n    return data;\n  }\n  /**\n   * Internal method for serializing a query to its RunAggregationQuery proto\n   * representation with an optional transaction id.\n   *\n   * @private\n   * @internal\n   * @returns Serialized JSON for the query.\n   */\n  toProto(transactionOrReadTime, explainOptions) {\n    const queryProto = this._query.toProto();\n    const runQueryRequest = {\n      parent: queryProto.parent,\n      structuredAggregationQuery: {\n        structuredQuery: queryProto.structuredQuery,\n        aggregations: (0, util_1.mapToArray)(this._aggregates, (aggregate, clientAlias) => {\n          const serverAlias = this.clientAliasToServerAliasMap[clientAlias];\n          assert(serverAlias !== null && serverAlias !== undefined, `'${clientAlias}' not present in client-server alias mapping.`);\n          return new aggregate_1.Aggregate(serverAlias, aggregate.aggregateType, aggregate._field).toProto();\n        })\n      }\n    };\n    if (transactionOrReadTime instanceof Uint8Array) {\n      runQueryRequest.transaction = transactionOrReadTime;\n    } else if (transactionOrReadTime instanceof timestamp_1.Timestamp) {\n      runQueryRequest.readTime = transactionOrReadTime;\n    } else if (transactionOrReadTime) {\n      runQueryRequest.newTransaction = transactionOrReadTime;\n    }\n    if (explainOptions) {\n      runQueryRequest.explainOptions = explainOptions;\n    }\n    return runQueryRequest;\n  }\n  /**\n   * Compares this object with the given object for equality.\n   *\n   * This object is considered \"equal\" to the other object if and only if\n   * `other` performs the same aggregations as this `AggregateQuery` and\n   * the underlying Query of `other` compares equal to that of this object\n   * using `Query.isEqual()`.\n   *\n   * @param other The object to compare to this object for equality.\n   * @return `true` if this object is \"equal\" to the given object, as\n   * defined above, or `false` otherwise.\n   */\n  isEqual(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof AggregateQuery)) {\n      return false;\n    }\n    if (!this.query.isEqual(other.query)) {\n      return false;\n    }\n    return deepEqual(this._aggregates, other._aggregates);\n  }\n  /**\n   * Plans and optionally executes this query. Returns a Promise that will be\n   * resolved with the planner information, statistics from the query\n   * execution (if any), and the query results (if any).\n   *\n   * @return A Promise that will be resolved with the planner information,\n   * statistics from the query execution (if any), and the query results (if any).\n   */\n  async explain(options) {\n    const {\n      result,\n      explainMetrics\n    } = await this._getResponse(undefined, options || {});\n    if (!explainMetrics) {\n      throw new Error('No explain results');\n    }\n    return new query_profile_1.ExplainResults(explainMetrics, result || null);\n  }\n}\nexports.AggregateQuery = AggregateQuery;","map":{"version":3,"names":["Object","defineProperty","exports","value","AggregateQuery","assert","require","deepEqual","aggregate_1","timestamp_1","util_1","query_profile_1","logger_1","aggregate_query_snapshot_1","stream_1","trace_util_1","constructor","_query","_aggregates","clientAliasToServerAliasMap","serverAliasToClientAliasMap","aggregationNum","clientAlias","prototype","hasOwnProperty","call","serverAlias","query","get","_firestore","_traceUtil","startActiveSpan","SPAN_NAME_AGGREGATION_QUERY_GET","result","_get","transactionOrReadTime","response","_getResponse","Error","explainOptions","stack","Promise","resolve","reject","output","stream","_stream","on","err","wrapError","data","transaction","explainMetrics","destroy","tag","requestTag","firestore","Transform","objectMode","transform","proto","enc","callback","_a","length","ExplainMetrics","_fromProto","_serializer","readTime","Timestamp","fromProto","decodeResult","AggregateQuerySnapshot","undefined","initializeIfNeeded","then","request","toProto","backendStream","requestStream","resume","end","unpipe","logger","currentSpan","addEvent","SPAN_NAME_RUN_AGGREGATION_QUERY","message","pipe","catch","e","fields","aggregateFields","serializer","prop","keys","alias","decodeValue","queryProto","runQueryRequest","parent","structuredAggregationQuery","structuredQuery","aggregations","mapToArray","aggregate","Aggregate","aggregateType","_field","Uint8Array","newTransaction","isEqual","other","explain","options","ExplainResults"],"sources":["/home/yadu/Music/Gifty/node_modules/@google-cloud/firestore/build/src/reference/aggregate-query.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2024 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AggregateQuery = void 0;\nconst assert = require(\"assert\");\nconst deepEqual = require(\"fast-deep-equal\");\nconst aggregate_1 = require(\"../aggregate\");\nconst timestamp_1 = require(\"../timestamp\");\nconst util_1 = require(\"../util\");\nconst query_profile_1 = require(\"../query-profile\");\nconst logger_1 = require(\"../logger\");\nconst aggregate_query_snapshot_1 = require(\"./aggregate-query-snapshot\");\nconst stream_1 = require(\"stream\");\nconst trace_util_1 = require(\"../telemetry/trace-util\");\n/**\n * A query that calculates aggregations over an underlying query.\n */\nclass AggregateQuery {\n    /**\n     * @internal\n     * @param _query The query whose aggregations will be calculated by this\n     * object.\n     * @param _aggregates The aggregations that will be performed by this query.\n     */\n    constructor(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _query, _aggregates) {\n        this._query = _query;\n        this._aggregates = _aggregates;\n        this.clientAliasToServerAliasMap = {};\n        this.serverAliasToClientAliasMap = {};\n        // Client-side aliases may be too long and exceed the 1500-byte string size limit.\n        // Such long strings do not need to be transferred over the wire either.\n        // The client maps the user's alias to a short form alias and send that to the server.\n        let aggregationNum = 0;\n        for (const clientAlias in this._aggregates) {\n            if (Object.prototype.hasOwnProperty.call(this._aggregates, clientAlias)) {\n                const serverAlias = `aggregate_${aggregationNum++}`;\n                this.clientAliasToServerAliasMap[clientAlias] = serverAlias;\n                this.serverAliasToClientAliasMap[serverAlias] = clientAlias;\n            }\n        }\n    }\n    /** The query whose aggregations will be calculated by this object. */\n    get query() {\n        return this._query;\n    }\n    /**\n     * Executes this query.\n     *\n     * @return A promise that will be resolved with the results of the query.\n     */\n    async get() {\n        return this._query._firestore._traceUtil.startActiveSpan(trace_util_1.SPAN_NAME_AGGREGATION_QUERY_GET, async () => {\n            const { result } = await this._get();\n            return result;\n        });\n    }\n    /**\n     * Internal get() method that accepts an optional transaction options and\n     * returns a snapshot with transaction and explain metadata.\n     *\n     * @private\n     * @internal\n     * @param transactionOrReadTime A transaction ID, options to start a new\n     *  transaction, or timestamp to use as read time.\n     */\n    async _get(transactionOrReadTime) {\n        const response = await this._getResponse(transactionOrReadTime);\n        if (!response.result) {\n            throw new Error('No AggregateQuery results');\n        }\n        return response;\n    }\n    /**\n     * Internal get() method that accepts an optional transaction id, and returns\n     * transaction metadata.\n     *\n     * @private\n     * @internal\n     * @param transactionOrReadTime A transaction ID, options to start a new\n     *  transaction, or timestamp to use as read time.\n     */\n    _getResponse(transactionOrReadTime, explainOptions) {\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        return new Promise((resolve, reject) => {\n            const output = {};\n            const stream = this._stream(transactionOrReadTime, explainOptions);\n            stream.on('error', err => {\n                reject((0, util_1.wrapError)(err, stack));\n            });\n            stream.on('data', (data) => {\n                if (data.transaction) {\n                    output.transaction = data.transaction;\n                }\n                if (data.explainMetrics) {\n                    output.explainMetrics = data.explainMetrics;\n                }\n                if (data.result) {\n                    output.result = data.result;\n                }\n            });\n            stream.on('end', () => {\n                stream.destroy();\n                resolve(output);\n            });\n        });\n    }\n    /**\n     * Internal streaming method that accepts an optional transaction ID.\n     *\n     * BEWARE: If `transactionOrReadTime` is `ITransactionOptions`, then the first\n     * response in the stream will be a transaction response.\n     *\n     * @private\n     * @internal\n     * @param transactionOrReadTime A transaction ID, options to start a new\n     *  transaction, or timestamp to use as read time.\n     * @param explainOptions Options to use for explaining the query (if any).\n     * @returns A stream of document results optionally preceded by a transaction response.\n     */\n    _stream(transactionOrReadTime, explainOptions) {\n        const tag = (0, util_1.requestTag)();\n        const firestore = this._query.firestore;\n        const stream = new stream_1.Transform({\n            objectMode: true,\n            transform: (proto, enc, callback) => {\n                var _a;\n                const output = {};\n                // Proto comes with zero-length buffer by default\n                if ((_a = proto.transaction) === null || _a === void 0 ? void 0 : _a.length) {\n                    output.transaction = proto.transaction;\n                }\n                if (proto.explainMetrics) {\n                    output.explainMetrics = query_profile_1.ExplainMetrics._fromProto(proto.explainMetrics, firestore._serializer);\n                }\n                if (proto.result) {\n                    const readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n                    const data = this.decodeResult(proto.result);\n                    output.result = new aggregate_query_snapshot_1.AggregateQuerySnapshot(this, readTime, data);\n                }\n                callback(undefined, output);\n            },\n        });\n        firestore\n            .initializeIfNeeded(tag)\n            .then(async () => {\n            // `toProto()` might throw an exception. We rely on the behavior of an\n            // async function to convert this exception into the rejected Promise we\n            // catch below.\n            const request = this.toProto(transactionOrReadTime, explainOptions);\n            const backendStream = await firestore.requestStream('runAggregationQuery', \n            /* bidirectional= */ false, request, tag);\n            stream.on('close', () => {\n                backendStream.resume();\n                backendStream.end();\n            });\n            backendStream.on('error', err => {\n                // TODO(group-by) When group-by queries are supported for aggregates\n                // consider implementing retries if the stream is making progress\n                // receiving results for groups. See the use of lastReceivedDocument\n                // in the retry strategy for runQuery.\n                // Also note that explain queries should not be retried.\n                backendStream.unpipe(stream);\n                (0, logger_1.logger)('AggregateQuery._stream', tag, 'AggregateQuery failed with stream error:', err);\n                this._query._firestore._traceUtil\n                    .currentSpan()\n                    .addEvent(`${trace_util_1.SPAN_NAME_RUN_AGGREGATION_QUERY}: Error.`, {\n                    'error.message': err.message,\n                });\n                stream.destroy(err);\n            });\n            backendStream.resume();\n            backendStream.pipe(stream);\n        })\n            .catch(e => stream.destroy(e));\n        return stream;\n    }\n    /**\n     * Internal method to decode values within result.\n     * @private\n     */\n    decodeResult(proto) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const data = {};\n        const fields = proto.aggregateFields;\n        if (fields) {\n            const serializer = this._query.firestore._serializer;\n            for (const prop of Object.keys(fields)) {\n                const alias = this.serverAliasToClientAliasMap[prop];\n                assert(alias !== null && alias !== undefined, `'${prop}' not present in server-client alias mapping.`);\n                if (this._aggregates[alias] === undefined) {\n                    throw new Error(`Unexpected alias [${prop}] in result aggregate result`);\n                }\n                data[alias] = serializer.decodeValue(fields[prop]);\n            }\n        }\n        return data;\n    }\n    /**\n     * Internal method for serializing a query to its RunAggregationQuery proto\n     * representation with an optional transaction id.\n     *\n     * @private\n     * @internal\n     * @returns Serialized JSON for the query.\n     */\n    toProto(transactionOrReadTime, explainOptions) {\n        const queryProto = this._query.toProto();\n        const runQueryRequest = {\n            parent: queryProto.parent,\n            structuredAggregationQuery: {\n                structuredQuery: queryProto.structuredQuery,\n                aggregations: (0, util_1.mapToArray)(this._aggregates, (aggregate, clientAlias) => {\n                    const serverAlias = this.clientAliasToServerAliasMap[clientAlias];\n                    assert(serverAlias !== null && serverAlias !== undefined, `'${clientAlias}' not present in client-server alias mapping.`);\n                    return new aggregate_1.Aggregate(serverAlias, aggregate.aggregateType, aggregate._field).toProto();\n                }),\n            },\n        };\n        if (transactionOrReadTime instanceof Uint8Array) {\n            runQueryRequest.transaction = transactionOrReadTime;\n        }\n        else if (transactionOrReadTime instanceof timestamp_1.Timestamp) {\n            runQueryRequest.readTime = transactionOrReadTime;\n        }\n        else if (transactionOrReadTime) {\n            runQueryRequest.newTransaction = transactionOrReadTime;\n        }\n        if (explainOptions) {\n            runQueryRequest.explainOptions = explainOptions;\n        }\n        return runQueryRequest;\n    }\n    /**\n     * Compares this object with the given object for equality.\n     *\n     * This object is considered \"equal\" to the other object if and only if\n     * `other` performs the same aggregations as this `AggregateQuery` and\n     * the underlying Query of `other` compares equal to that of this object\n     * using `Query.isEqual()`.\n     *\n     * @param other The object to compare to this object for equality.\n     * @return `true` if this object is \"equal\" to the given object, as\n     * defined above, or `false` otherwise.\n     */\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof AggregateQuery)) {\n            return false;\n        }\n        if (!this.query.isEqual(other.query)) {\n            return false;\n        }\n        return deepEqual(this._aggregates, other._aggregates);\n    }\n    /**\n     * Plans and optionally executes this query. Returns a Promise that will be\n     * resolved with the planner information, statistics from the query\n     * execution (if any), and the query results (if any).\n     *\n     * @return A Promise that will be resolved with the planner information,\n     * statistics from the query execution (if any), and the query results (if any).\n     */\n    async explain(options) {\n        const { result, explainMetrics } = await this._getResponse(undefined, options || {});\n        if (!explainMetrics) {\n            throw new Error('No explain results');\n        }\n        return new query_profile_1.ExplainResults(explainMetrics, result || null);\n    }\n}\nexports.AggregateQuery = AggregateQuery;\n//# sourceMappingURL=aggregate-query.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}