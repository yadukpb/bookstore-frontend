{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamProxy = exports.StreamType = void 0;\nconst googleError_1 = require(\"../googleError\");\nconst streamingRetryRequest_1 = require(\"../streamingRetryRequest\");\nconst status_1 = require(\"../status\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst duplexify = require('duplexify');\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst retryRequest = require('retry-request');\n/**\n * The type of gRPC streaming.\n * @enum {number}\n */\nvar StreamType;\n(function (StreamType) {\n  /** Client sends a single request, server streams responses. */\n  StreamType[StreamType[\"SERVER_STREAMING\"] = 1] = \"SERVER_STREAMING\";\n  /** Client streams requests, server returns a single response. */\n  StreamType[StreamType[\"CLIENT_STREAMING\"] = 2] = \"CLIENT_STREAMING\";\n  /** Both client and server stream objects. */\n  StreamType[StreamType[\"BIDI_STREAMING\"] = 3] = \"BIDI_STREAMING\";\n})(StreamType || (exports.StreamType = StreamType = {}));\nclass StreamProxy extends duplexify {\n  /**\n   * StreamProxy is a proxy to gRPC-streaming method.\n   *\n   * @private\n   * @constructor\n   * @param {StreamType} type - the type of gRPC stream.\n   * @param {ApiCallback} callback - the callback for further API call.\n   */\n  constructor(type, callback, rest, gaxServerStreamingRetries) {\n    super(undefined, undefined, {\n      objectMode: true,\n      readable: type !== StreamType.CLIENT_STREAMING,\n      writable: type !== StreamType.SERVER_STREAMING\n    });\n    this.retries = 0;\n    this.type = type;\n    this._callback = callback;\n    this._isCancelCalled = false;\n    this._responseHasSent = false;\n    this.rest = rest;\n    this.gaxServerStreamingRetries = gaxServerStreamingRetries;\n  }\n  shouldRetryRequest(error, retry) {\n    const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n    let shouldRetry = this.defaultShouldRetry(e, retry);\n    if (retry.shouldRetryFn) {\n      shouldRetry = retry.shouldRetryFn(e);\n    }\n    return shouldRetry;\n  }\n  cancel() {\n    if (this.stream) {\n      this.stream.cancel();\n    } else {\n      this._isCancelCalled = true;\n    }\n  }\n  retry(stream, retry) {\n    let retryArgument = this.argument;\n    if (typeof retry.getResumptionRequestFn === 'function') {\n      const resumptionRetryArgument = retry.getResumptionRequestFn(retryArgument);\n      if (resumptionRetryArgument !== undefined) {\n        retryArgument = resumptionRetryArgument;\n      }\n    }\n    this.resetStreams(stream);\n    const newStream = this.apiCall(retryArgument, this._callback);\n    this.stream = newStream;\n    this.streamHandoffHelper(newStream, retry);\n    return newStream;\n  }\n  /**\n   * Helper function to handle total timeout + max retry check for server streaming retries\n   * @param {number} deadline - the current retry deadline\n   * @param {number} maxRetries - maximum total number of retries\n   * @param {number} totalTimeoutMillis - total timeout in milliseconds\n   */\n  throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, totalTimeoutMillis) {\n    const now = new Date();\n    if (this.prevDeadline !== undefined && deadline && now.getTime() >= this.prevDeadline) {\n      const error = new googleError_1.GoogleError(`Total timeout of API exceeded ${totalTimeoutMillis} milliseconds before any response was received.`);\n      error.code = status_1.Status.DEADLINE_EXCEEDED;\n      this.emit('error', error);\n      this.destroy();\n      // Without throwing error you get unhandled error since we are returning a new stream\n      // There might be a better way to do this\n      throw error;\n    }\n    if (this.retries && this.retries >= maxRetries) {\n      const error = new googleError_1.GoogleError('Exceeded maximum number of retries before any ' + 'response was received');\n      error.code = status_1.Status.DEADLINE_EXCEEDED;\n      this.emit('error', error);\n      this.destroy();\n      throw error;\n    }\n  }\n  /**\n   * Error handler for server streaming retries\n   * @param {CancellableStream} stream - the stream being retried\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   * @param {Error} error - error to handle\n   */\n  streamHandoffErrorHandler(stream, retry, error) {\n    let retryStream = this.stream;\n    const delayMult = retry.backoffSettings.retryDelayMultiplier;\n    const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n    const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n    const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n    let delay = retry.backoffSettings.initialRetryDelayMillis;\n    let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n    let now = new Date();\n    let deadline = 0;\n    if (retry.backoffSettings.totalTimeoutMillis) {\n      deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n    }\n    const maxRetries = retry.backoffSettings.maxRetries;\n    try {\n      this.throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, retry.backoffSettings.totalTimeoutMillis);\n    } catch (error) {\n      return;\n    }\n    this.retries++;\n    if (this.shouldRetryRequest(error, retry)) {\n      const toSleep = Math.random() * delay;\n      setTimeout(() => {\n        now = new Date();\n        delay = Math.min(delay * delayMult, maxDelay);\n        const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n        const rpcTimeout = maxTimeout ? maxTimeout : 0;\n        this.prevDeadline = deadline;\n        const newDeadline = deadline ? deadline - now.getTime() : 0;\n        timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n      }, toSleep);\n    } else {\n      const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n      e.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n      // for some reason this error must be emitted here\n      // instead of the destroy, otherwise the error event\n      // is swallowed\n      this.emit('error', e);\n      this.destroy();\n      return;\n    }\n    retryStream = this.retry(stream, retry);\n    this.stream = retryStream;\n    return;\n  }\n  /**\n   * Used during server streaming retries to handle\n   * event forwarding, errors, and/or stream closure\n   * @param {CancellableStream} stream - the stream that we're doing the retry on\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  streamHandoffHelper(stream, retry) {\n    let enteredError = false;\n    this.eventForwardHelper(stream);\n    stream.on('error', error => {\n      enteredError = true;\n      this.streamHandoffErrorHandler(stream, retry, error);\n    });\n    stream.on('data', data => {\n      this.retries = 0;\n      this.emit.bind(this, 'data')(data);\n    });\n    stream.on('end', () => {\n      if (!enteredError) {\n        enteredError = true;\n        this.emit('end');\n        this.cancel();\n      }\n    });\n  }\n  eventForwardHelper(stream) {\n    const eventsToForward = ['metadata', 'response', 'status'];\n    eventsToForward.forEach(event => {\n      stream.on(event, this.emit.bind(this, event));\n    });\n  }\n  statusMetadataHelper(stream) {\n    // gRPC is guaranteed emit the 'status' event but not 'metadata', and 'status' is the last event to emit.\n    // Emit the 'response' event if stream has no 'metadata' event.\n    // This avoids the stream swallowing the other events, such as 'end'.\n    stream.on('status', () => {\n      if (!this._responseHasSent) {\n        stream.emit('response', {\n          code: 200,\n          details: '',\n          message: 'OK'\n        });\n      }\n    });\n    // We also want to supply the status data as 'response' event to support\n    // the behavior of google-cloud-node expects.\n    // see:\n    // https://github.com/GoogleCloudPlatform/google-cloud-node/pull/1775#issuecomment-259141029\n    // https://github.com/GoogleCloudPlatform/google-cloud-node/blob/116436fa789d8b0f7fc5100b19b424e3ec63e6bf/packages/common/src/grpc-service.js#L355\n    stream.on('metadata', metadata => {\n      // Create a response object with succeeds.\n      // TODO: unify this logic with the decoration of gRPC response when it's\n      // added. see: https://github.com/googleapis/gax-nodejs/issues/65\n      stream.emit('response', {\n        code: 200,\n        details: '',\n        message: 'OK',\n        metadata\n      });\n      this._responseHasSent = true;\n    });\n  }\n  /**\n   * Forward events from an API request stream to the user's stream.\n   * @param {Stream} stream - The API request stream.\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  forwardEvents(stream) {\n    this.eventForwardHelper(stream);\n    this.statusMetadataHelper(stream);\n    stream.on('error', error => {\n      googleError_1.GoogleError.parseGRPCStatusDetails(error);\n    });\n  }\n  defaultShouldRetry(error, retry) {\n    if (retry.retryCodes.length > 0 && retry.retryCodes.indexOf(error.code) < 0 || retry.retryCodes.length === 0) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Forward events from an API request stream to the user's stream.\n   * @param {Stream} stream - The API request stream.\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function eshould retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  forwardEventsWithRetries(stream, retry) {\n    let retryStream = this.stream;\n    this.eventForwardHelper(stream);\n    this.statusMetadataHelper(stream);\n    stream.on('error', error => {\n      const timeout = retry.backoffSettings.totalTimeoutMillis;\n      const maxRetries = retry.backoffSettings.maxRetries;\n      if (maxRetries && maxRetries > 0 || timeout && timeout > 0) {\n        if (this.shouldRetryRequest(error, retry)) {\n          if (maxRetries && timeout) {\n            const newError = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' + 'in backoffSettings.');\n            newError.code = status_1.Status.INVALID_ARGUMENT;\n            this.emit('error', newError);\n            this.destroy();\n            return; //end chunk\n          } else {\n            this.retries++;\n            retryStream = this.retry(stream, retry);\n            this.stream = retryStream;\n            return retryStream;\n          }\n        } else {\n          const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n          e.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n          this.destroy(e);\n          return; // end chunk\n        }\n      } else {\n        if (maxRetries === 0) {\n          const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n          e.note = 'Max retries is set to zero.';\n          this.destroy(e);\n          return; // end chunk\n        }\n\n        return googleError_1.GoogleError.parseGRPCStatusDetails(error);\n      }\n    });\n    return retryStream;\n  }\n  /**\n   * Resets the target stream as part of the retry process\n   * @param {CancellableStream} requestStream - the stream to end\n   */\n  resetStreams(requestStream) {\n    if (requestStream) {\n      requestStream.cancel && requestStream.cancel();\n      if (requestStream.destroy) {\n        requestStream.destroy();\n      } else if (requestStream.end) {\n        // TODO: not used in server streaming, but likely needed\n        // if we want to add BIDI or client side streaming\n        requestStream.end();\n      }\n    }\n  }\n  /**\n   * Specifies the target stream.\n   * @param {ApiCall} apiCall - the API function to be called.\n   * @param {Object} argument - the argument to be passed to the apiCall.\n   * @param {RetryOptions} retry - Configures the exceptions upon which the\n   *   function should retry, and the parameters to the exponential backoff retry\n   *   algorithm.\n   */\n  setStream(apiCall, argument) {\n    let retryRequestOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let retry = arguments.length > 3 ? arguments[3] : undefined;\n    this.apiCall = apiCall;\n    this.argument = argument;\n    if (this.type === StreamType.SERVER_STREAMING) {\n      if (this.rest) {\n        const stream = apiCall(argument, this._callback);\n        this.stream = stream;\n        this.setReadable(stream);\n      } else if (this.gaxServerStreamingRetries) {\n        const retryStream = (0, streamingRetryRequest_1.streamingRetryRequest)({\n          request: () => {\n            if (this._isCancelCalled) {\n              if (this.stream) {\n                this.stream.cancel();\n              }\n              return;\n            }\n            const stream = apiCall(argument, this._callback);\n            this.stream = stream;\n            this.stream = this.forwardEventsWithRetries(stream, retry);\n            return this.stream;\n          }\n        });\n        this.setReadable(retryStream);\n      } else {\n        const retryStream = retryRequest(null, {\n          objectMode: true,\n          request: () => {\n            if (this._isCancelCalled) {\n              if (this.stream) {\n                this.stream.cancel();\n              }\n              return;\n            }\n            const stream = apiCall(argument, this._callback);\n            this.stream = stream;\n            this.forwardEvents(stream);\n            return stream;\n          },\n          retries: retryRequestOptions.retries,\n          currentRetryAttempt: retryRequestOptions.currentRetryAttempt,\n          noResponseRetries: retryRequestOptions.noResponseRetries,\n          shouldRetryFn: retryRequestOptions.shouldRetryFn\n        });\n        this.setReadable(retryStream);\n      }\n      return;\n    }\n    const stream = apiCall(argument, this._callback);\n    this.stream = stream;\n    this.forwardEvents(stream);\n    if (this.type === StreamType.CLIENT_STREAMING) {\n      this.setWritable(stream);\n    }\n    if (this.type === StreamType.BIDI_STREAMING) {\n      this.setReadable(stream);\n      this.setWritable(stream);\n    }\n    if (this._isCancelCalled && this.stream) {\n      this.stream.cancel();\n    }\n  }\n}\nexports.StreamProxy = StreamProxy;","map":{"version":3,"names":["Object","defineProperty","exports","value","StreamProxy","StreamType","googleError_1","require","streamingRetryRequest_1","status_1","duplexify","retryRequest","constructor","type","callback","rest","gaxServerStreamingRetries","undefined","objectMode","readable","CLIENT_STREAMING","writable","SERVER_STREAMING","retries","_callback","_isCancelCalled","_responseHasSent","shouldRetryRequest","error","retry","e","GoogleError","parseGRPCStatusDetails","shouldRetry","defaultShouldRetry","shouldRetryFn","cancel","stream","retryArgument","argument","getResumptionRequestFn","resumptionRetryArgument","resetStreams","newStream","apiCall","streamHandoffHelper","throwIfMaxRetriesOrTotalTimeoutExceeded","deadline","maxRetries","totalTimeoutMillis","now","Date","prevDeadline","getTime","code","Status","DEADLINE_EXCEEDED","emit","destroy","streamHandoffErrorHandler","retryStream","delayMult","backoffSettings","retryDelayMultiplier","maxDelay","maxRetryDelayMillis","timeoutMult","rpcTimeoutMultiplier","maxTimeout","maxRpcTimeoutMillis","delay","initialRetryDelayMillis","timeout","initialRpcTimeoutMillis","toSleep","Math","random","setTimeout","min","timeoutCal","rpcTimeout","newDeadline","note","enteredError","eventForwardHelper","on","data","bind","eventsToForward","forEach","event","statusMetadataHelper","details","message","metadata","forwardEvents","retryCodes","length","indexOf","forwardEventsWithRetries","newError","INVALID_ARGUMENT","requestStream","end","setStream","retryRequestOptions","setReadable","streamingRetryRequest","request","currentRetryAttempt","noResponseRetries","setWritable","BIDI_STREAMING"],"sources":["/home/yadu/Music/Gifty/node_modules/google-gax/build/src/streamingCalls/streaming.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StreamProxy = exports.StreamType = void 0;\nconst googleError_1 = require(\"../googleError\");\nconst streamingRetryRequest_1 = require(\"../streamingRetryRequest\");\nconst status_1 = require(\"../status\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst duplexify = require('duplexify');\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst retryRequest = require('retry-request');\n/**\n * The type of gRPC streaming.\n * @enum {number}\n */\nvar StreamType;\n(function (StreamType) {\n    /** Client sends a single request, server streams responses. */\n    StreamType[StreamType[\"SERVER_STREAMING\"] = 1] = \"SERVER_STREAMING\";\n    /** Client streams requests, server returns a single response. */\n    StreamType[StreamType[\"CLIENT_STREAMING\"] = 2] = \"CLIENT_STREAMING\";\n    /** Both client and server stream objects. */\n    StreamType[StreamType[\"BIDI_STREAMING\"] = 3] = \"BIDI_STREAMING\";\n})(StreamType || (exports.StreamType = StreamType = {}));\nclass StreamProxy extends duplexify {\n    /**\n     * StreamProxy is a proxy to gRPC-streaming method.\n     *\n     * @private\n     * @constructor\n     * @param {StreamType} type - the type of gRPC stream.\n     * @param {ApiCallback} callback - the callback for further API call.\n     */\n    constructor(type, callback, rest, gaxServerStreamingRetries) {\n        super(undefined, undefined, {\n            objectMode: true,\n            readable: type !== StreamType.CLIENT_STREAMING,\n            writable: type !== StreamType.SERVER_STREAMING,\n        });\n        this.retries = 0;\n        this.type = type;\n        this._callback = callback;\n        this._isCancelCalled = false;\n        this._responseHasSent = false;\n        this.rest = rest;\n        this.gaxServerStreamingRetries = gaxServerStreamingRetries;\n    }\n    shouldRetryRequest(error, retry) {\n        const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n        let shouldRetry = this.defaultShouldRetry(e, retry);\n        if (retry.shouldRetryFn) {\n            shouldRetry = retry.shouldRetryFn(e);\n        }\n        return shouldRetry;\n    }\n    cancel() {\n        if (this.stream) {\n            this.stream.cancel();\n        }\n        else {\n            this._isCancelCalled = true;\n        }\n    }\n    retry(stream, retry) {\n        let retryArgument = this.argument;\n        if (typeof retry.getResumptionRequestFn === 'function') {\n            const resumptionRetryArgument = retry.getResumptionRequestFn(retryArgument);\n            if (resumptionRetryArgument !== undefined) {\n                retryArgument = resumptionRetryArgument;\n            }\n        }\n        this.resetStreams(stream);\n        const newStream = this.apiCall(retryArgument, this._callback);\n        this.stream = newStream;\n        this.streamHandoffHelper(newStream, retry);\n        return newStream;\n    }\n    /**\n     * Helper function to handle total timeout + max retry check for server streaming retries\n     * @param {number} deadline - the current retry deadline\n     * @param {number} maxRetries - maximum total number of retries\n     * @param {number} totalTimeoutMillis - total timeout in milliseconds\n     */\n    throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, totalTimeoutMillis) {\n        const now = new Date();\n        if (this.prevDeadline !== undefined &&\n            deadline &&\n            now.getTime() >= this.prevDeadline) {\n            const error = new googleError_1.GoogleError(`Total timeout of API exceeded ${totalTimeoutMillis} milliseconds before any response was received.`);\n            error.code = status_1.Status.DEADLINE_EXCEEDED;\n            this.emit('error', error);\n            this.destroy();\n            // Without throwing error you get unhandled error since we are returning a new stream\n            // There might be a better way to do this\n            throw error;\n        }\n        if (this.retries && this.retries >= maxRetries) {\n            const error = new googleError_1.GoogleError('Exceeded maximum number of retries before any ' +\n                'response was received');\n            error.code = status_1.Status.DEADLINE_EXCEEDED;\n            this.emit('error', error);\n            this.destroy();\n            throw error;\n        }\n    }\n    /**\n     * Error handler for server streaming retries\n     * @param {CancellableStream} stream - the stream being retried\n     * @param {RetryOptions} retry - Configures the exceptions upon which the\n     *   function should retry, and the parameters to the exponential backoff retry\n     *   algorithm.\n     * @param {Error} error - error to handle\n     */\n    streamHandoffErrorHandler(stream, retry, error) {\n        let retryStream = this.stream;\n        const delayMult = retry.backoffSettings.retryDelayMultiplier;\n        const maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n        const timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n        const maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n        let delay = retry.backoffSettings.initialRetryDelayMillis;\n        let timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n        let now = new Date();\n        let deadline = 0;\n        if (retry.backoffSettings.totalTimeoutMillis) {\n            deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n        }\n        const maxRetries = retry.backoffSettings.maxRetries;\n        try {\n            this.throwIfMaxRetriesOrTotalTimeoutExceeded(deadline, maxRetries, retry.backoffSettings.totalTimeoutMillis);\n        }\n        catch (error) {\n            return;\n        }\n        this.retries++;\n        if (this.shouldRetryRequest(error, retry)) {\n            const toSleep = Math.random() * delay;\n            setTimeout(() => {\n                now = new Date();\n                delay = Math.min(delay * delayMult, maxDelay);\n                const timeoutCal = timeout && timeoutMult ? timeout * timeoutMult : 0;\n                const rpcTimeout = maxTimeout ? maxTimeout : 0;\n                this.prevDeadline = deadline;\n                const newDeadline = deadline ? deadline - now.getTime() : 0;\n                timeout = Math.min(timeoutCal, rpcTimeout, newDeadline);\n            }, toSleep);\n        }\n        else {\n            const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n            e.note =\n                'Exception occurred in retry method that was ' +\n                    'not classified as transient';\n            // for some reason this error must be emitted here\n            // instead of the destroy, otherwise the error event\n            // is swallowed\n            this.emit('error', e);\n            this.destroy();\n            return;\n        }\n        retryStream = this.retry(stream, retry);\n        this.stream = retryStream;\n        return;\n    }\n    /**\n     * Used during server streaming retries to handle\n     * event forwarding, errors, and/or stream closure\n     * @param {CancellableStream} stream - the stream that we're doing the retry on\n     * @param {RetryOptions} retry - Configures the exceptions upon which the\n     *   function should retry, and the parameters to the exponential backoff retry\n     *   algorithm.\n     */\n    streamHandoffHelper(stream, retry) {\n        let enteredError = false;\n        this.eventForwardHelper(stream);\n        stream.on('error', error => {\n            enteredError = true;\n            this.streamHandoffErrorHandler(stream, retry, error);\n        });\n        stream.on('data', (data) => {\n            this.retries = 0;\n            this.emit.bind(this, 'data')(data);\n        });\n        stream.on('end', () => {\n            if (!enteredError) {\n                enteredError = true;\n                this.emit('end');\n                this.cancel();\n            }\n        });\n    }\n    eventForwardHelper(stream) {\n        const eventsToForward = ['metadata', 'response', 'status'];\n        eventsToForward.forEach(event => {\n            stream.on(event, this.emit.bind(this, event));\n        });\n    }\n    statusMetadataHelper(stream) {\n        // gRPC is guaranteed emit the 'status' event but not 'metadata', and 'status' is the last event to emit.\n        // Emit the 'response' event if stream has no 'metadata' event.\n        // This avoids the stream swallowing the other events, such as 'end'.\n        stream.on('status', () => {\n            if (!this._responseHasSent) {\n                stream.emit('response', {\n                    code: 200,\n                    details: '',\n                    message: 'OK',\n                });\n            }\n        });\n        // We also want to supply the status data as 'response' event to support\n        // the behavior of google-cloud-node expects.\n        // see:\n        // https://github.com/GoogleCloudPlatform/google-cloud-node/pull/1775#issuecomment-259141029\n        // https://github.com/GoogleCloudPlatform/google-cloud-node/blob/116436fa789d8b0f7fc5100b19b424e3ec63e6bf/packages/common/src/grpc-service.js#L355\n        stream.on('metadata', metadata => {\n            // Create a response object with succeeds.\n            // TODO: unify this logic with the decoration of gRPC response when it's\n            // added. see: https://github.com/googleapis/gax-nodejs/issues/65\n            stream.emit('response', {\n                code: 200,\n                details: '',\n                message: 'OK',\n                metadata,\n            });\n            this._responseHasSent = true;\n        });\n    }\n    /**\n     * Forward events from an API request stream to the user's stream.\n     * @param {Stream} stream - The API request stream.\n     * @param {RetryOptions} retry - Configures the exceptions upon which the\n     *   function should retry, and the parameters to the exponential backoff retry\n     *   algorithm.\n     */\n    forwardEvents(stream) {\n        this.eventForwardHelper(stream);\n        this.statusMetadataHelper(stream);\n        stream.on('error', error => {\n            googleError_1.GoogleError.parseGRPCStatusDetails(error);\n        });\n    }\n    defaultShouldRetry(error, retry) {\n        if ((retry.retryCodes.length > 0 &&\n            retry.retryCodes.indexOf(error.code) < 0) ||\n            retry.retryCodes.length === 0) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Forward events from an API request stream to the user's stream.\n     * @param {Stream} stream - The API request stream.\n     * @param {RetryOptions} retry - Configures the exceptions upon which the\n     *   function eshould retry, and the parameters to the exponential backoff retry\n     *   algorithm.\n     */\n    forwardEventsWithRetries(stream, retry) {\n        let retryStream = this.stream;\n        this.eventForwardHelper(stream);\n        this.statusMetadataHelper(stream);\n        stream.on('error', error => {\n            const timeout = retry.backoffSettings.totalTimeoutMillis;\n            const maxRetries = retry.backoffSettings.maxRetries;\n            if ((maxRetries && maxRetries > 0) || (timeout && timeout > 0)) {\n                if (this.shouldRetryRequest(error, retry)) {\n                    if (maxRetries && timeout) {\n                        const newError = new googleError_1.GoogleError('Cannot set both totalTimeoutMillis and maxRetries ' +\n                            'in backoffSettings.');\n                        newError.code = status_1.Status.INVALID_ARGUMENT;\n                        this.emit('error', newError);\n                        this.destroy();\n                        return; //end chunk\n                    }\n                    else {\n                        this.retries++;\n                        retryStream = this.retry(stream, retry);\n                        this.stream = retryStream;\n                        return retryStream;\n                    }\n                }\n                else {\n                    const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n                    e.note =\n                        'Exception occurred in retry method that was ' +\n                            'not classified as transient';\n                    this.destroy(e);\n                    return; // end chunk\n                }\n            }\n            else {\n                if (maxRetries === 0) {\n                    const e = googleError_1.GoogleError.parseGRPCStatusDetails(error);\n                    e.note = 'Max retries is set to zero.';\n                    this.destroy(e);\n                    return; // end chunk\n                }\n                return googleError_1.GoogleError.parseGRPCStatusDetails(error);\n            }\n        });\n        return retryStream;\n    }\n    /**\n     * Resets the target stream as part of the retry process\n     * @param {CancellableStream} requestStream - the stream to end\n     */\n    resetStreams(requestStream) {\n        if (requestStream) {\n            requestStream.cancel && requestStream.cancel();\n            if (requestStream.destroy) {\n                requestStream.destroy();\n            }\n            else if (requestStream.end) {\n                // TODO: not used in server streaming, but likely needed\n                // if we want to add BIDI or client side streaming\n                requestStream.end();\n            }\n        }\n    }\n    /**\n     * Specifies the target stream.\n     * @param {ApiCall} apiCall - the API function to be called.\n     * @param {Object} argument - the argument to be passed to the apiCall.\n     * @param {RetryOptions} retry - Configures the exceptions upon which the\n     *   function should retry, and the parameters to the exponential backoff retry\n     *   algorithm.\n     */\n    setStream(apiCall, argument, retryRequestOptions = {}, retry) {\n        this.apiCall = apiCall;\n        this.argument = argument;\n        if (this.type === StreamType.SERVER_STREAMING) {\n            if (this.rest) {\n                const stream = apiCall(argument, this._callback);\n                this.stream = stream;\n                this.setReadable(stream);\n            }\n            else if (this.gaxServerStreamingRetries) {\n                const retryStream = (0, streamingRetryRequest_1.streamingRetryRequest)({\n                    request: () => {\n                        if (this._isCancelCalled) {\n                            if (this.stream) {\n                                this.stream.cancel();\n                            }\n                            return;\n                        }\n                        const stream = apiCall(argument, this._callback);\n                        this.stream = stream;\n                        this.stream = this.forwardEventsWithRetries(stream, retry);\n                        return this.stream;\n                    },\n                });\n                this.setReadable(retryStream);\n            }\n            else {\n                const retryStream = retryRequest(null, {\n                    objectMode: true,\n                    request: () => {\n                        if (this._isCancelCalled) {\n                            if (this.stream) {\n                                this.stream.cancel();\n                            }\n                            return;\n                        }\n                        const stream = apiCall(argument, this._callback);\n                        this.stream = stream;\n                        this.forwardEvents(stream);\n                        return stream;\n                    },\n                    retries: retryRequestOptions.retries,\n                    currentRetryAttempt: retryRequestOptions.currentRetryAttempt,\n                    noResponseRetries: retryRequestOptions.noResponseRetries,\n                    shouldRetryFn: retryRequestOptions.shouldRetryFn,\n                });\n                this.setReadable(retryStream);\n            }\n            return;\n        }\n        const stream = apiCall(argument, this._callback);\n        this.stream = stream;\n        this.forwardEvents(stream);\n        if (this.type === StreamType.CLIENT_STREAMING) {\n            this.setWritable(stream);\n        }\n        if (this.type === StreamType.BIDI_STREAMING) {\n            this.setReadable(stream);\n            this.setWritable(stream);\n        }\n        if (this._isCancelCalled && this.stream) {\n            this.stream.cancel();\n        }\n    }\n}\nexports.StreamProxy = StreamProxy;\n//# sourceMappingURL=streaming.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}