{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n  return ar;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.asyncMemoizer = void 0;\nvar lru_cache_1 = __importDefault(require(\"lru-cache\"));\nvar events_1 = require(\"events\");\nvar lodash_clonedeep_1 = __importDefault(require(\"lodash.clonedeep\"));\nvar freeze_1 = require(\"./freeze\");\nvar sync_1 = require(\"./sync\");\nfunction asyncMemoizer(options) {\n  var cache = new lru_cache_1.default(options);\n  var load = options.load;\n  var hash = options.hash;\n  var bypass = options.bypass;\n  var itemMaxAge = options.itemMaxAge;\n  var freeze = options.freeze;\n  var clone = options.clone;\n  var queueMaxAge = options.queueMaxAge || 1000;\n  var loading = new Map();\n  var emitter = new events_1.EventEmitter();\n  var memoizerMethods = Object.assign({\n    del: del,\n    reset: function () {\n      return cache.reset();\n    },\n    keys: cache.keys.bind(cache),\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter)\n  }, options);\n  if (options.disable) {\n    return Object.assign(load, memoizerMethods);\n  }\n  function del() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var key = hash.apply(void 0, __spread(args));\n    cache.del(key);\n  }\n  function add(key, parameters, result) {\n    if (freeze) {\n      result.forEach(freeze_1.deepFreeze);\n    }\n    if (itemMaxAge) {\n      cache.set(key, result, itemMaxAge.apply(void 0, __spread(parameters.concat(result))));\n    } else {\n      cache.set(key, result);\n    }\n  }\n  function runCallbacks(callbacks, args) {\n    var e_1, _a;\n    try {\n      for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\n        var callback = callbacks_1_1.value;\n        // Simulate async call when returning from cache\n        // and yield between callback resolution\n        if (clone) {\n          setImmediate.apply(void 0, __spread([callback], args.map(lodash_clonedeep_1.default)));\n        } else {\n          setImmediate.apply(void 0, __spread([callback], args));\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n  function emit(event) {\n    var parameters = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      parameters[_i - 1] = arguments[_i];\n    }\n    emitter.emit.apply(emitter, __spread([event], parameters));\n  }\n  function memoizedFunction() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var parameters = args.slice(0, -1);\n    var callback = args.slice(-1).pop();\n    var key;\n    if (bypass && bypass.apply(void 0, __spread(parameters))) {\n      emit.apply(void 0, __spread(['miss'], parameters));\n      return load.apply(void 0, __spread(args));\n    }\n    if (parameters.length === 0 && !hash) {\n      //the load function only receives callback.\n      key = '_';\n    } else {\n      key = hash.apply(void 0, __spread(parameters));\n    }\n    var fromCache = cache.get(key);\n    if (fromCache) {\n      emit.apply(void 0, __spread(['hit'], parameters));\n      // found, invoke callback\n      return runCallbacks([callback], [null].concat(fromCache));\n    }\n    var pendingLoad = loading.get(key);\n    if (pendingLoad && pendingLoad.expiresAt > Date.now()) {\n      // request already in progress, queue and return\n      pendingLoad.queue.push(callback);\n      emit.apply(void 0, __spread(['queue'], parameters));\n      return;\n    }\n    emit.apply(void 0, __spread(['miss'], parameters));\n    var started = Date.now();\n    // no pending request or not resolved before expiration\n    // create a new queue and invoke load\n    var queue = [callback];\n    loading.set(key, {\n      queue: queue,\n      expiresAt: started + queueMaxAge\n    });\n    var loadHandler = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var err = args[0];\n      if (!err) {\n        add(key, parameters, args.slice(1));\n      }\n      // this can potentially delete a different queue than `queue` if\n      // this callback was called after expiration.\n      // that will only cause a new call to be performed and a new queue to be\n      // created\n      loading.delete(key);\n      emit.apply(void 0, __spread(['loaded', Date.now() - started], parameters));\n      runCallbacks(queue, args);\n    };\n    load.apply(void 0, __spread(parameters, [loadHandler]));\n  }\n  ;\n  return Object.assign(memoizedFunction, memoizerMethods);\n}\nexports.asyncMemoizer = asyncMemoizer;\nasyncMemoizer.sync = sync_1.syncMemoizer;","map":{"version":3,"mappings":"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","names":["asyncMemoizer","options","cache","lru_cache_1","load","hash","bypass","itemMaxAge","freeze","clone","queueMaxAge","loading","Map","emitter","events_1","memoizerMethods","Object","assign","del","reset","keys","bind","on","once","disable","_i","args","key","add","parameters","result","forEach","freeze_1","set","concat","runCallbacks","callbacks","callback","setImmediate","map","lodash_clonedeep_1","emit","event","memoizedFunction","slice","pop","length","fromCache","get","pendingLoad","expiresAt","Date","now","queue","push","started","loadHandler","err","delete","exports","sync","sync_1"],"sources":["../src/async.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script","externalDependencies":[]}