{"ast":null,"code":"/*! firebase-admin v12.7.0 */\n/*!\n * Copyright 2024 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConditionEvaluator = void 0;\nconst remote_config_api_1 = require(\"./remote-config-api\");\nconst farmhash = require(\"farmhash-modern\");\n/**\n * Encapsulates condition evaluation logic to simplify organization and\n * facilitate testing.\n *\n * @internal\n */\nclass ConditionEvaluator {\n  evaluateConditions(namedConditions, context) {\n    // The order of the conditions is significant.\n    // A JS Map preserves the order of insertion (\"Iteration happens in insertion order\"\n    // - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#description).\n    const evaluatedConditions = new Map();\n    for (const namedCondition of namedConditions) {\n      evaluatedConditions.set(namedCondition.name, this.evaluateCondition(namedCondition.condition, context));\n    }\n    return evaluatedConditions;\n  }\n  evaluateCondition(condition, context) {\n    let nestingLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    if (nestingLevel >= ConditionEvaluator.MAX_CONDITION_RECURSION_DEPTH) {\n      // TODO: add logging once we have a wrapped logger.\n      return false;\n    }\n    if (condition.orCondition) {\n      return this.evaluateOrCondition(condition.orCondition, context, nestingLevel + 1);\n    }\n    if (condition.andCondition) {\n      return this.evaluateAndCondition(condition.andCondition, context, nestingLevel + 1);\n    }\n    if (condition.true) {\n      return true;\n    }\n    if (condition.false) {\n      return false;\n    }\n    if (condition.percent) {\n      return this.evaluatePercentCondition(condition.percent, context);\n    }\n    if (condition.customSignal) {\n      return this.evaluateCustomSignalCondition(condition.customSignal, context);\n    }\n    // TODO: add logging once we have a wrapped logger.\n    return false;\n  }\n  evaluateOrCondition(orCondition, context, nestingLevel) {\n    const subConditions = orCondition.conditions || [];\n    for (const subCondition of subConditions) {\n      // Recursive call.\n      const result = this.evaluateCondition(subCondition, context, nestingLevel + 1);\n      // Short-circuit the evaluation result for true.\n      if (result) {\n        return result;\n      }\n    }\n    return false;\n  }\n  evaluateAndCondition(andCondition, context, nestingLevel) {\n    const subConditions = andCondition.conditions || [];\n    for (const subCondition of subConditions) {\n      // Recursive call.\n      const result = this.evaluateCondition(subCondition, context, nestingLevel + 1);\n      // Short-circuit the evaluation result for false.\n      if (!result) {\n        return result;\n      }\n    }\n    return true;\n  }\n  evaluatePercentCondition(percentCondition, context) {\n    if (!context.randomizationId) {\n      // TODO: add logging once we have a wrapped logger.\n      return false;\n    }\n    // This is the entry point for processing percent condition data from the response.\n    // We're not using a proto library, so we can't assume undefined fields have\n    // default values.\n    const {\n      seed,\n      percentOperator,\n      microPercent,\n      microPercentRange\n    } = percentCondition;\n    if (!percentOperator) {\n      // TODO: add logging once we have a wrapped logger.\n      return false;\n    }\n    const normalizedMicroPercent = microPercent || 0;\n    const normalizedMicroPercentUpperBound = microPercentRange?.microPercentUpperBound || 0;\n    const normalizedMicroPercentLowerBound = microPercentRange?.microPercentLowerBound || 0;\n    const seedPrefix = seed && seed.length > 0 ? `${seed}.` : '';\n    const stringToHash = `${seedPrefix}${context.randomizationId}`;\n    const hash64 = ConditionEvaluator.hashSeededRandomizationId(stringToHash);\n    const instanceMicroPercentile = hash64 % BigInt(100 * 1000000);\n    switch (percentOperator) {\n      case remote_config_api_1.PercentConditionOperator.LESS_OR_EQUAL:\n        return instanceMicroPercentile <= normalizedMicroPercent;\n      case remote_config_api_1.PercentConditionOperator.GREATER_THAN:\n        return instanceMicroPercentile > normalizedMicroPercent;\n      case remote_config_api_1.PercentConditionOperator.BETWEEN:\n        return instanceMicroPercentile > normalizedMicroPercentLowerBound && instanceMicroPercentile <= normalizedMicroPercentUpperBound;\n      case remote_config_api_1.PercentConditionOperator.UNKNOWN:\n      default:\n        break;\n    }\n    // TODO: add logging once we have a wrapped logger.\n    return false;\n  }\n  static hashSeededRandomizationId(seededRandomizationId) {\n    // For consistency with the Remote Config fetch endpoint's percent condition behavior\n    // we use Farmhash's fingerprint64 algorithm and interpret the resulting unsigned value\n    // as a signed value.\n    let hash64 = BigInt.asIntN(64, farmhash.fingerprint64(seededRandomizationId));\n    // Manually negate the hash if its value is less than 0, since Math.abs doesn't\n    // support BigInt.\n    if (hash64 < 0) {\n      hash64 = -hash64;\n    }\n    return hash64;\n  }\n  evaluateCustomSignalCondition(customSignalCondition, context) {\n    const {\n      customSignalOperator,\n      customSignalKey,\n      targetCustomSignalValues\n    } = customSignalCondition;\n    if (!customSignalOperator || !customSignalKey || !targetCustomSignalValues) {\n      // TODO: add logging once we have a wrapped logger.\n      return false;\n    }\n    if (!targetCustomSignalValues.length) {\n      return false;\n    }\n    // Extract the value of the signal from the evaluation context.\n    const actualCustomSignalValue = context[customSignalKey];\n    if (actualCustomSignalValue == undefined) {\n      return false;\n    }\n    switch (customSignalOperator) {\n      case remote_config_api_1.CustomSignalOperator.STRING_CONTAINS:\n        return compareStrings(targetCustomSignalValues, actualCustomSignalValue, (target, actual) => actual.includes(target));\n      case remote_config_api_1.CustomSignalOperator.STRING_DOES_NOT_CONTAIN:\n        return !compareStrings(targetCustomSignalValues, actualCustomSignalValue, (target, actual) => actual.includes(target));\n      case remote_config_api_1.CustomSignalOperator.STRING_EXACTLY_MATCHES:\n        return compareStrings(targetCustomSignalValues, actualCustomSignalValue, (target, actual) => actual.trim() === target.trim());\n      case remote_config_api_1.CustomSignalOperator.STRING_CONTAINS_REGEX:\n        return compareStrings(targetCustomSignalValues, actualCustomSignalValue, (target, actual) => new RegExp(target).test(actual));\n      // For numeric operators only one target value is allowed.\n      case remote_config_api_1.CustomSignalOperator.NUMERIC_LESS_THAN:\n        return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], r => r < 0);\n      case remote_config_api_1.CustomSignalOperator.NUMERIC_LESS_EQUAL:\n        return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], r => r <= 0);\n      case remote_config_api_1.CustomSignalOperator.NUMERIC_EQUAL:\n        return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], r => r === 0);\n      case remote_config_api_1.CustomSignalOperator.NUMERIC_NOT_EQUAL:\n        return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], r => r !== 0);\n      case remote_config_api_1.CustomSignalOperator.NUMERIC_GREATER_THAN:\n        return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], r => r > 0);\n      case remote_config_api_1.CustomSignalOperator.NUMERIC_GREATER_EQUAL:\n        return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], r => r >= 0);\n      // For semantic operators only one target value is allowed.\n      case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_LESS_THAN:\n        return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], r => r < 0);\n      case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_LESS_EQUAL:\n        return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], r => r <= 0);\n      case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_EQUAL:\n        return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], r => r === 0);\n      case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_NOT_EQUAL:\n        return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], r => r !== 0);\n      case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_GREATER_THAN:\n        return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], r => r > 0);\n      case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_GREATER_EQUAL:\n        return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], r => r >= 0);\n    }\n    // TODO: add logging once we have a wrapped logger.\n    return false;\n  }\n}\nexports.ConditionEvaluator = ConditionEvaluator;\nConditionEvaluator.MAX_CONDITION_RECURSION_DEPTH = 10;\n// Compares the actual string value of a signal against a list of target\n// values. If any of the target values are a match, returns true.\nfunction compareStrings(targetValues, actualValue, predicateFn) {\n  const actual = String(actualValue);\n  return targetValues.some(target => predicateFn(target, actual));\n}\n// Compares two numbers against each other.\n// Calls the predicate function with  -1, 0, 1 if actual is less than, equal to, or greater than target.\nfunction compareNumbers(actualValue, targetValue, predicateFn) {\n  const target = Number(targetValue);\n  const actual = Number(actualValue);\n  if (isNaN(target) || isNaN(actual)) {\n    return false;\n  }\n  return predicateFn(actual < target ? -1 : actual > target ? 1 : 0);\n}\n// Max number of segments a numeric version can have. This is enforced by the server as well.\nconst MAX_LENGTH = 5;\n// Compares semantic version strings against each other.\n// Calls the predicate function with  -1, 0, 1 if actual is less than, equal to, or greater than target.\nfunction compareSemanticVersions(actualValue, targetValue, predicateFn) {\n  const version1 = String(actualValue).split('.').map(Number);\n  const version2 = targetValue.split('.').map(Number);\n  for (let i = 0; i < MAX_LENGTH; i++) {\n    // Check to see if segments are present. Note that these may be present and be NaN.\n    const version1HasSegment = version1[i] !== undefined;\n    const version2HasSegment = version2[i] !== undefined;\n    // If both are undefined, we've consumed everything and they're equal.\n    if (!version1HasSegment && !version2HasSegment) return predicateFn(0);\n    // Insert zeros if undefined for easier comparison.\n    if (!version1HasSegment) version1[i] = 0;\n    if (!version2HasSegment) version2[i] = 0;\n    // At this point, if either segment is NaN, we return false directly.\n    if (isNaN(version1[i]) || isNaN(version2[i])) return false;\n    // Check if we have a difference in segments. Otherwise continue to next segment.\n    if (version1[i] < version2[i]) return predicateFn(-1);\n    if (version1[i] > version2[i]) return predicateFn(1);\n  }\n  return false;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ConditionEvaluator","remote_config_api_1","require","farmhash","evaluateConditions","namedConditions","context","evaluatedConditions","Map","namedCondition","set","name","evaluateCondition","condition","nestingLevel","MAX_CONDITION_RECURSION_DEPTH","orCondition","evaluateOrCondition","andCondition","evaluateAndCondition","true","false","percent","evaluatePercentCondition","customSignal","evaluateCustomSignalCondition","subConditions","conditions","subCondition","result","percentCondition","randomizationId","seed","percentOperator","microPercent","microPercentRange","normalizedMicroPercent","normalizedMicroPercentUpperBound","microPercentUpperBound","normalizedMicroPercentLowerBound","microPercentLowerBound","seedPrefix","length","stringToHash","hash64","hashSeededRandomizationId","instanceMicroPercentile","BigInt","PercentConditionOperator","LESS_OR_EQUAL","GREATER_THAN","BETWEEN","UNKNOWN","seededRandomizationId","asIntN","fingerprint64","customSignalCondition","customSignalOperator","customSignalKey","targetCustomSignalValues","actualCustomSignalValue","undefined","CustomSignalOperator","STRING_CONTAINS","compareStrings","target","actual","includes","STRING_DOES_NOT_CONTAIN","STRING_EXACTLY_MATCHES","trim","STRING_CONTAINS_REGEX","RegExp","test","NUMERIC_LESS_THAN","compareNumbers","r","NUMERIC_LESS_EQUAL","NUMERIC_EQUAL","NUMERIC_NOT_EQUAL","NUMERIC_GREATER_THAN","NUMERIC_GREATER_EQUAL","SEMANTIC_VERSION_LESS_THAN","compareSemanticVersions","SEMANTIC_VERSION_LESS_EQUAL","SEMANTIC_VERSION_EQUAL","SEMANTIC_VERSION_NOT_EQUAL","SEMANTIC_VERSION_GREATER_THAN","SEMANTIC_VERSION_GREATER_EQUAL","targetValues","actualValue","predicateFn","String","some","targetValue","Number","isNaN","MAX_LENGTH","version1","split","map","version2","i","version1HasSegment","version2HasSegment"],"sources":["/home/yadu/Music/Gifty/node_modules/firebase-admin/lib/remote-config/condition-evaluator-internal.js"],"sourcesContent":["/*! firebase-admin v12.7.0 */\n/*!\n * Copyright 2024 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConditionEvaluator = void 0;\nconst remote_config_api_1 = require(\"./remote-config-api\");\nconst farmhash = require(\"farmhash-modern\");\n/**\n * Encapsulates condition evaluation logic to simplify organization and\n * facilitate testing.\n *\n * @internal\n */\nclass ConditionEvaluator {\n    evaluateConditions(namedConditions, context) {\n        // The order of the conditions is significant.\n        // A JS Map preserves the order of insertion (\"Iteration happens in insertion order\"\n        // - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#description).\n        const evaluatedConditions = new Map();\n        for (const namedCondition of namedConditions) {\n            evaluatedConditions.set(namedCondition.name, this.evaluateCondition(namedCondition.condition, context));\n        }\n        return evaluatedConditions;\n    }\n    evaluateCondition(condition, context, nestingLevel = 0) {\n        if (nestingLevel >= ConditionEvaluator.MAX_CONDITION_RECURSION_DEPTH) {\n            // TODO: add logging once we have a wrapped logger.\n            return false;\n        }\n        if (condition.orCondition) {\n            return this.evaluateOrCondition(condition.orCondition, context, nestingLevel + 1);\n        }\n        if (condition.andCondition) {\n            return this.evaluateAndCondition(condition.andCondition, context, nestingLevel + 1);\n        }\n        if (condition.true) {\n            return true;\n        }\n        if (condition.false) {\n            return false;\n        }\n        if (condition.percent) {\n            return this.evaluatePercentCondition(condition.percent, context);\n        }\n        if (condition.customSignal) {\n            return this.evaluateCustomSignalCondition(condition.customSignal, context);\n        }\n        // TODO: add logging once we have a wrapped logger.\n        return false;\n    }\n    evaluateOrCondition(orCondition, context, nestingLevel) {\n        const subConditions = orCondition.conditions || [];\n        for (const subCondition of subConditions) {\n            // Recursive call.\n            const result = this.evaluateCondition(subCondition, context, nestingLevel + 1);\n            // Short-circuit the evaluation result for true.\n            if (result) {\n                return result;\n            }\n        }\n        return false;\n    }\n    evaluateAndCondition(andCondition, context, nestingLevel) {\n        const subConditions = andCondition.conditions || [];\n        for (const subCondition of subConditions) {\n            // Recursive call.\n            const result = this.evaluateCondition(subCondition, context, nestingLevel + 1);\n            // Short-circuit the evaluation result for false.\n            if (!result) {\n                return result;\n            }\n        }\n        return true;\n    }\n    evaluatePercentCondition(percentCondition, context) {\n        if (!context.randomizationId) {\n            // TODO: add logging once we have a wrapped logger.\n            return false;\n        }\n        // This is the entry point for processing percent condition data from the response.\n        // We're not using a proto library, so we can't assume undefined fields have\n        // default values.\n        const { seed, percentOperator, microPercent, microPercentRange } = percentCondition;\n        if (!percentOperator) {\n            // TODO: add logging once we have a wrapped logger.\n            return false;\n        }\n        const normalizedMicroPercent = microPercent || 0;\n        const normalizedMicroPercentUpperBound = microPercentRange?.microPercentUpperBound || 0;\n        const normalizedMicroPercentLowerBound = microPercentRange?.microPercentLowerBound || 0;\n        const seedPrefix = seed && seed.length > 0 ? `${seed}.` : '';\n        const stringToHash = `${seedPrefix}${context.randomizationId}`;\n        const hash64 = ConditionEvaluator.hashSeededRandomizationId(stringToHash);\n        const instanceMicroPercentile = hash64 % BigInt(100 * 1000000);\n        switch (percentOperator) {\n            case remote_config_api_1.PercentConditionOperator.LESS_OR_EQUAL:\n                return instanceMicroPercentile <= normalizedMicroPercent;\n            case remote_config_api_1.PercentConditionOperator.GREATER_THAN:\n                return instanceMicroPercentile > normalizedMicroPercent;\n            case remote_config_api_1.PercentConditionOperator.BETWEEN:\n                return instanceMicroPercentile > normalizedMicroPercentLowerBound\n                    && instanceMicroPercentile <= normalizedMicroPercentUpperBound;\n            case remote_config_api_1.PercentConditionOperator.UNKNOWN:\n            default:\n                break;\n        }\n        // TODO: add logging once we have a wrapped logger.\n        return false;\n    }\n    static hashSeededRandomizationId(seededRandomizationId) {\n        // For consistency with the Remote Config fetch endpoint's percent condition behavior\n        // we use Farmhash's fingerprint64 algorithm and interpret the resulting unsigned value\n        // as a signed value.\n        let hash64 = BigInt.asIntN(64, farmhash.fingerprint64(seededRandomizationId));\n        // Manually negate the hash if its value is less than 0, since Math.abs doesn't\n        // support BigInt.\n        if (hash64 < 0) {\n            hash64 = -hash64;\n        }\n        return hash64;\n    }\n    evaluateCustomSignalCondition(customSignalCondition, context) {\n        const { customSignalOperator, customSignalKey, targetCustomSignalValues, } = customSignalCondition;\n        if (!customSignalOperator || !customSignalKey || !targetCustomSignalValues) {\n            // TODO: add logging once we have a wrapped logger.\n            return false;\n        }\n        if (!targetCustomSignalValues.length) {\n            return false;\n        }\n        // Extract the value of the signal from the evaluation context.\n        const actualCustomSignalValue = context[customSignalKey];\n        if (actualCustomSignalValue == undefined) {\n            return false;\n        }\n        switch (customSignalOperator) {\n            case remote_config_api_1.CustomSignalOperator.STRING_CONTAINS:\n                return compareStrings(targetCustomSignalValues, actualCustomSignalValue, (target, actual) => actual.includes(target));\n            case remote_config_api_1.CustomSignalOperator.STRING_DOES_NOT_CONTAIN:\n                return !compareStrings(targetCustomSignalValues, actualCustomSignalValue, (target, actual) => actual.includes(target));\n            case remote_config_api_1.CustomSignalOperator.STRING_EXACTLY_MATCHES:\n                return compareStrings(targetCustomSignalValues, actualCustomSignalValue, (target, actual) => actual.trim() === target.trim());\n            case remote_config_api_1.CustomSignalOperator.STRING_CONTAINS_REGEX:\n                return compareStrings(targetCustomSignalValues, actualCustomSignalValue, (target, actual) => new RegExp(target).test(actual));\n            // For numeric operators only one target value is allowed.\n            case remote_config_api_1.CustomSignalOperator.NUMERIC_LESS_THAN:\n                return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r < 0);\n            case remote_config_api_1.CustomSignalOperator.NUMERIC_LESS_EQUAL:\n                return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r <= 0);\n            case remote_config_api_1.CustomSignalOperator.NUMERIC_EQUAL:\n                return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r === 0);\n            case remote_config_api_1.CustomSignalOperator.NUMERIC_NOT_EQUAL:\n                return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r !== 0);\n            case remote_config_api_1.CustomSignalOperator.NUMERIC_GREATER_THAN:\n                return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r > 0);\n            case remote_config_api_1.CustomSignalOperator.NUMERIC_GREATER_EQUAL:\n                return compareNumbers(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r >= 0);\n            // For semantic operators only one target value is allowed.\n            case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_LESS_THAN:\n                return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r < 0);\n            case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_LESS_EQUAL:\n                return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r <= 0);\n            case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_EQUAL:\n                return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r === 0);\n            case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_NOT_EQUAL:\n                return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r !== 0);\n            case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_GREATER_THAN:\n                return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r > 0);\n            case remote_config_api_1.CustomSignalOperator.SEMANTIC_VERSION_GREATER_EQUAL:\n                return compareSemanticVersions(actualCustomSignalValue, targetCustomSignalValues[0], (r) => r >= 0);\n        }\n        // TODO: add logging once we have a wrapped logger.\n        return false;\n    }\n}\nexports.ConditionEvaluator = ConditionEvaluator;\nConditionEvaluator.MAX_CONDITION_RECURSION_DEPTH = 10;\n// Compares the actual string value of a signal against a list of target\n// values. If any of the target values are a match, returns true.\nfunction compareStrings(targetValues, actualValue, predicateFn) {\n    const actual = String(actualValue);\n    return targetValues.some((target) => predicateFn(target, actual));\n}\n// Compares two numbers against each other.\n// Calls the predicate function with  -1, 0, 1 if actual is less than, equal to, or greater than target.\nfunction compareNumbers(actualValue, targetValue, predicateFn) {\n    const target = Number(targetValue);\n    const actual = Number(actualValue);\n    if (isNaN(target) || isNaN(actual)) {\n        return false;\n    }\n    return predicateFn(actual < target ? -1 : actual > target ? 1 : 0);\n}\n// Max number of segments a numeric version can have. This is enforced by the server as well.\nconst MAX_LENGTH = 5;\n// Compares semantic version strings against each other.\n// Calls the predicate function with  -1, 0, 1 if actual is less than, equal to, or greater than target.\nfunction compareSemanticVersions(actualValue, targetValue, predicateFn) {\n    const version1 = String(actualValue).split('.').map(Number);\n    const version2 = targetValue.split('.').map(Number);\n    for (let i = 0; i < MAX_LENGTH; i++) {\n        // Check to see if segments are present. Note that these may be present and be NaN.\n        const version1HasSegment = version1[i] !== undefined;\n        const version2HasSegment = version2[i] !== undefined;\n        // If both are undefined, we've consumed everything and they're equal.\n        if (!version1HasSegment && !version2HasSegment)\n            return predicateFn(0);\n        // Insert zeros if undefined for easier comparison.\n        if (!version1HasSegment)\n            version1[i] = 0;\n        if (!version2HasSegment)\n            version2[i] = 0;\n        // At this point, if either segment is NaN, we return false directly.\n        if (isNaN(version1[i]) || isNaN(version2[i]))\n            return false;\n        // Check if we have a difference in segments. Otherwise continue to next segment.\n        if (version1[i] < version2[i])\n            return predicateFn(-1);\n        if (version1[i] > version2[i])\n            return predicateFn(1);\n    }\n    return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}