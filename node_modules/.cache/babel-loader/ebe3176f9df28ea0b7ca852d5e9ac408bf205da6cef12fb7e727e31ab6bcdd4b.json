{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChangeStreamCursor = void 0;\nconst change_stream_1 = require(\"../change_stream\");\nconst constants_1 = require(\"../constants\");\nconst aggregate_1 = require(\"../operations/aggregate\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst utils_1 = require(\"../utils\");\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\n/** @internal */\nclass ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {\n  constructor(client, namespace) {\n    let pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(client, namespace, options);\n    this.pipeline = pipeline;\n    this.changeStreamCursorOptions = options;\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime ?? null;\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);\n  }\n  get resumeToken() {\n    return this._resumeToken;\n  }\n  get resumeOptions() {\n    const options = {\n      ...this.changeStreamCursorOptions\n    };\n    for (const key of ['resumeAfter', 'startAfter', 'startAtOperationTime']) {\n      delete options[key];\n    }\n    if (this.resumeToken != null) {\n      if (this.changeStreamCursorOptions.startAfter && !this.hasReceived) {\n        options.startAfter = this.resumeToken;\n      } else {\n        options.resumeAfter = this.resumeToken;\n      }\n    } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {\n      options.startAtOperationTime = this.startAtOperationTime;\n    }\n    return options;\n  }\n  cacheResumeToken(resumeToken) {\n    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n      this.resumeToken = this.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n    this.hasReceived = true;\n  }\n  _processBatch(response) {\n    const {\n      postBatchResumeToken\n    } = response;\n    if (postBatchResumeToken) {\n      this.postBatchResumeToken = postBatchResumeToken;\n      if (response.batchSize === 0) {\n        this.resumeToken = postBatchResumeToken;\n      }\n    }\n  }\n  clone() {\n    return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {\n      ...this.cursorOptions\n    });\n  }\n  async _initialize(session) {\n    const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {\n      ...this.cursorOptions,\n      ...this.changeStreamCursorOptions,\n      session\n    });\n    const response = await (0, execute_operation_1.executeOperation)(session.client, aggregateOperation);\n    const server = aggregateOperation.server;\n    this.maxWireVersion = (0, utils_1.maxWireVersion)(server);\n    if (this.startAtOperationTime == null && this.changeStreamCursorOptions.resumeAfter == null && this.changeStreamCursorOptions.startAfter == null && this.maxWireVersion >= 7) {\n      this.startAtOperationTime = response.operationTime;\n    }\n    this._processBatch(response);\n    this.emit(constants_1.INIT, response);\n    this.emit(constants_1.RESPONSE);\n    return {\n      server,\n      session,\n      response\n    };\n  }\n  async getMore(batchSize) {\n    const response = await super.getMore(batchSize);\n    this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);\n    this._processBatch(response);\n    this.emit(change_stream_1.ChangeStream.MORE, response);\n    this.emit(change_stream_1.ChangeStream.RESPONSE);\n    return response;\n  }\n}\nexports.ChangeStreamCursor = ChangeStreamCursor;","map":{"version":3,"mappings":"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","names":["ChangeStreamCursor","abstract_cursor_1","constructor","client","namespace","pipeline","options","changeStreamCursorOptions","_resumeToken","startAtOperationTime","startAfter","resumeToken","resumeAfter","token","emit","change_stream_1","RESUME_TOKEN_CHANGED","resumeOptions","key","hasReceived","server","cacheResumeToken","bufferedCount","postBatchResumeToken","_processBatch","response","batchSize","clone","cursorOptions","_initialize","session","aggregateOperation","aggregate_1","maxWireVersion","operationTime","constants_1","getMore","MORE","RESPONSE","exports"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/cursor/change_stream_cursor.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport {\n  ChangeStream,\n  type ChangeStreamDocument,\n  type ChangeStreamEvents,\n  type OperationTime,\n  type ResumeToken\n} from '../change_stream';\nimport { type CursorResponse } from '../cmap/wire_protocol/responses';\nimport { INIT, RESPONSE } from '../constants';\nimport type { MongoClient } from '../mongo_client';\nimport { AggregateOperation } from '../operations/aggregate';\nimport type { CollationOptions } from '../operations/command';\nimport { executeOperation } from '../operations/execute_operation';\nimport type { ClientSession } from '../sessions';\nimport { maxWireVersion, type MongoDBNamespace } from '../utils';\nimport {\n  AbstractCursor,\n  type AbstractCursorOptions,\n  type InitialCursorResponse\n} from './abstract_cursor';\n\n/** @internal */\nexport interface ChangeStreamCursorOptions extends AbstractCursorOptions {\n  startAtOperationTime?: OperationTime;\n  resumeAfter?: ResumeToken;\n  startAfter?: ResumeToken;\n  maxAwaitTimeMS?: number;\n  collation?: CollationOptions;\n  fullDocument?: string;\n}\n\n/** @internal */\nexport class ChangeStreamCursor<\n  TSchema extends Document = Document,\n  TChange extends Document = ChangeStreamDocument<TSchema>\n> extends AbstractCursor<TChange, ChangeStreamEvents> {\n  private _resumeToken: ResumeToken;\n  private startAtOperationTime: OperationTime | null;\n  private hasReceived?: boolean;\n  private readonly changeStreamCursorOptions: ChangeStreamCursorOptions;\n  private postBatchResumeToken?: ResumeToken;\n  private readonly pipeline: Document[];\n\n  /**\n   * @internal\n   *\n   * used to determine change stream resumability\n   */\n  maxWireVersion: number | undefined;\n\n  constructor(\n    client: MongoClient,\n    namespace: MongoDBNamespace,\n    pipeline: Document[] = [],\n    options: ChangeStreamCursorOptions = {}\n  ) {\n    super(client, namespace, options);\n\n    this.pipeline = pipeline;\n    this.changeStreamCursorOptions = options;\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime ?? null;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token: ResumeToken) {\n    this._resumeToken = token;\n    this.emit(ChangeStream.RESUME_TOKEN_CHANGED, token);\n  }\n\n  get resumeToken(): ResumeToken {\n    return this._resumeToken;\n  }\n\n  get resumeOptions(): ChangeStreamCursorOptions {\n    const options: ChangeStreamCursorOptions = {\n      ...this.changeStreamCursorOptions\n    };\n\n    for (const key of ['resumeAfter', 'startAfter', 'startAtOperationTime'] as const) {\n      delete options[key];\n    }\n\n    if (this.resumeToken != null) {\n      if (this.changeStreamCursorOptions.startAfter && !this.hasReceived) {\n        options.startAfter = this.resumeToken;\n      } else {\n        options.resumeAfter = this.resumeToken;\n      }\n    } else if (this.startAtOperationTime != null && maxWireVersion(this.server) >= 7) {\n      options.startAtOperationTime = this.startAtOperationTime;\n    }\n\n    return options;\n  }\n\n  cacheResumeToken(resumeToken: ResumeToken): void {\n    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n      this.resumeToken = this.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n    this.hasReceived = true;\n  }\n\n  _processBatch(response: CursorResponse): void {\n    const { postBatchResumeToken } = response;\n    if (postBatchResumeToken) {\n      this.postBatchResumeToken = postBatchResumeToken;\n\n      if (response.batchSize === 0) {\n        this.resumeToken = postBatchResumeToken;\n      }\n    }\n  }\n\n  clone(): AbstractCursor<TChange> {\n    return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {\n      ...this.cursorOptions\n    });\n  }\n\n  async _initialize(session: ClientSession): Promise<InitialCursorResponse> {\n    const aggregateOperation = new AggregateOperation(this.namespace, this.pipeline, {\n      ...this.cursorOptions,\n      ...this.changeStreamCursorOptions,\n      session\n    });\n\n    const response = await executeOperation(session.client, aggregateOperation);\n\n    const server = aggregateOperation.server;\n    this.maxWireVersion = maxWireVersion(server);\n\n    if (\n      this.startAtOperationTime == null &&\n      this.changeStreamCursorOptions.resumeAfter == null &&\n      this.changeStreamCursorOptions.startAfter == null &&\n      this.maxWireVersion >= 7\n    ) {\n      this.startAtOperationTime = response.operationTime;\n    }\n\n    this._processBatch(response);\n\n    this.emit(INIT, response);\n    this.emit(RESPONSE);\n\n    return { server, session, response };\n  }\n\n  override async getMore(batchSize: number): Promise<CursorResponse> {\n    const response = await super.getMore(batchSize);\n\n    this.maxWireVersion = maxWireVersion(this.server);\n    this._processBatch(response);\n\n    this.emit(ChangeStream.MORE, response);\n    this.emit(ChangeStream.RESPONSE);\n    return response;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}