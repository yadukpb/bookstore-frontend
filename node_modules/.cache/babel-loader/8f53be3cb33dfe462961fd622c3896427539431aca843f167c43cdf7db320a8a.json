{"ast":null,"code":"\"use strict\";\n\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _HashStreamValidator_crc32cHash, _HashStreamValidator_md5Hash, _HashStreamValidator_md5Digest;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HashStreamValidator = void 0;\nconst crypto_1 = require(\"crypto\");\nconst stream_1 = require(\"stream\");\nconst crc32c_js_1 = require(\"./crc32c.js\");\nconst file_js_1 = require(\"./file.js\");\nclass HashStreamValidator extends stream_1.Transform {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.updateHashesOnly = false;\n    _HashStreamValidator_crc32cHash.set(this, undefined);\n    _HashStreamValidator_md5Hash.set(this, undefined);\n    _HashStreamValidator_md5Digest.set(this, '');\n    this.crc32cEnabled = !!options.crc32c;\n    this.md5Enabled = !!options.md5;\n    this.updateHashesOnly = !!options.updateHashesOnly;\n    this.crc32cExpected = options.crc32cExpected;\n    this.md5Expected = options.md5Expected;\n    if (this.crc32cEnabled) {\n      if (options.crc32cInstance) {\n        __classPrivateFieldSet(this, _HashStreamValidator_crc32cHash, options.crc32cInstance, \"f\");\n      } else {\n        const crc32cGenerator = options.crc32cGenerator || crc32c_js_1.CRC32C_DEFAULT_VALIDATOR_GENERATOR;\n        __classPrivateFieldSet(this, _HashStreamValidator_crc32cHash, crc32cGenerator(), \"f\");\n      }\n    }\n    if (this.md5Enabled) {\n      __classPrivateFieldSet(this, _HashStreamValidator_md5Hash, (0, crypto_1.createHash)('md5'), \"f\");\n    }\n  }\n  /**\n   * Return the current CRC32C value, if available.\n   */\n  get crc32c() {\n    var _a;\n    return (_a = __classPrivateFieldGet(this, _HashStreamValidator_crc32cHash, \"f\")) === null || _a === void 0 ? void 0 : _a.toString();\n  }\n  _flush(callback) {\n    if (__classPrivateFieldGet(this, _HashStreamValidator_md5Hash, \"f\")) {\n      __classPrivateFieldSet(this, _HashStreamValidator_md5Digest, __classPrivateFieldGet(this, _HashStreamValidator_md5Hash, \"f\").digest('base64'), \"f\");\n    }\n    if (this.updateHashesOnly) {\n      callback();\n      return;\n    }\n    // If we're doing validation, assume the worst-- a data integrity\n    // mismatch. If not, these tests won't be performed, and we can assume\n    // the best.\n    // We must check if the server decompressed the data on serve because hash\n    // validation is not possible in this case.\n    let failed = this.crc32cEnabled || this.md5Enabled;\n    if (this.crc32cEnabled && this.crc32cExpected) {\n      failed = !this.test('crc32c', this.crc32cExpected);\n    }\n    if (this.md5Enabled && this.md5Expected) {\n      failed = !this.test('md5', this.md5Expected);\n    }\n    if (failed) {\n      const mismatchError = new file_js_1.RequestError(file_js_1.FileExceptionMessages.DOWNLOAD_MISMATCH);\n      mismatchError.code = 'CONTENT_DOWNLOAD_MISMATCH';\n      callback(mismatchError);\n    } else {\n      callback();\n    }\n  }\n  _transform(chunk, encoding, callback) {\n    this.push(chunk, encoding);\n    try {\n      if (__classPrivateFieldGet(this, _HashStreamValidator_crc32cHash, \"f\")) __classPrivateFieldGet(this, _HashStreamValidator_crc32cHash, \"f\").update(chunk);\n      if (__classPrivateFieldGet(this, _HashStreamValidator_md5Hash, \"f\")) __classPrivateFieldGet(this, _HashStreamValidator_md5Hash, \"f\").update(chunk);\n      callback();\n    } catch (e) {\n      callback(e);\n    }\n  }\n  test(hash, sum) {\n    const check = Buffer.isBuffer(sum) ? sum.toString('base64') : sum;\n    if (hash === 'crc32c' && __classPrivateFieldGet(this, _HashStreamValidator_crc32cHash, \"f\")) {\n      return __classPrivateFieldGet(this, _HashStreamValidator_crc32cHash, \"f\").validate(check);\n    }\n    if (hash === 'md5' && __classPrivateFieldGet(this, _HashStreamValidator_md5Hash, \"f\")) {\n      return __classPrivateFieldGet(this, _HashStreamValidator_md5Digest, \"f\") === check;\n    }\n    return false;\n  }\n}\nexports.HashStreamValidator = HashStreamValidator;\n_HashStreamValidator_crc32cHash = new WeakMap(), _HashStreamValidator_md5Hash = new WeakMap(), _HashStreamValidator_md5Digest = new WeakMap();","map":{"version":3,"names":["__classPrivateFieldSet","receiver","state","value","kind","f","TypeError","has","call","set","__classPrivateFieldGet","get","_HashStreamValidator_crc32cHash","_HashStreamValidator_md5Hash","_HashStreamValidator_md5Digest","Object","defineProperty","exports","HashStreamValidator","crypto_1","require","stream_1","crc32c_js_1","file_js_1","Transform","constructor","options","updateHashesOnly","undefined","crc32cEnabled","crc32c","md5Enabled","md5","crc32cExpected","md5Expected","crc32cInstance","crc32cGenerator","CRC32C_DEFAULT_VALIDATOR_GENERATOR","createHash","_a","toString","_flush","callback","digest","failed","test","mismatchError","RequestError","FileExceptionMessages","DOWNLOAD_MISMATCH","code","_transform","chunk","encoding","push","update","e","hash","sum","check","Buffer","isBuffer","validate","WeakMap"],"sources":["/home/yadu/Music/Gifty/node_modules/@google-cloud/storage/build/cjs/src/hash-stream-validator.js"],"sourcesContent":["\"use strict\";\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _HashStreamValidator_crc32cHash, _HashStreamValidator_md5Hash, _HashStreamValidator_md5Digest;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HashStreamValidator = void 0;\nconst crypto_1 = require(\"crypto\");\nconst stream_1 = require(\"stream\");\nconst crc32c_js_1 = require(\"./crc32c.js\");\nconst file_js_1 = require(\"./file.js\");\nclass HashStreamValidator extends stream_1.Transform {\n    constructor(options = {}) {\n        super();\n        this.updateHashesOnly = false;\n        _HashStreamValidator_crc32cHash.set(this, undefined);\n        _HashStreamValidator_md5Hash.set(this, undefined);\n        _HashStreamValidator_md5Digest.set(this, '');\n        this.crc32cEnabled = !!options.crc32c;\n        this.md5Enabled = !!options.md5;\n        this.updateHashesOnly = !!options.updateHashesOnly;\n        this.crc32cExpected = options.crc32cExpected;\n        this.md5Expected = options.md5Expected;\n        if (this.crc32cEnabled) {\n            if (options.crc32cInstance) {\n                __classPrivateFieldSet(this, _HashStreamValidator_crc32cHash, options.crc32cInstance, \"f\");\n            }\n            else {\n                const crc32cGenerator = options.crc32cGenerator || crc32c_js_1.CRC32C_DEFAULT_VALIDATOR_GENERATOR;\n                __classPrivateFieldSet(this, _HashStreamValidator_crc32cHash, crc32cGenerator(), \"f\");\n            }\n        }\n        if (this.md5Enabled) {\n            __classPrivateFieldSet(this, _HashStreamValidator_md5Hash, (0, crypto_1.createHash)('md5'), \"f\");\n        }\n    }\n    /**\n     * Return the current CRC32C value, if available.\n     */\n    get crc32c() {\n        var _a;\n        return (_a = __classPrivateFieldGet(this, _HashStreamValidator_crc32cHash, \"f\")) === null || _a === void 0 ? void 0 : _a.toString();\n    }\n    _flush(callback) {\n        if (__classPrivateFieldGet(this, _HashStreamValidator_md5Hash, \"f\")) {\n            __classPrivateFieldSet(this, _HashStreamValidator_md5Digest, __classPrivateFieldGet(this, _HashStreamValidator_md5Hash, \"f\").digest('base64'), \"f\");\n        }\n        if (this.updateHashesOnly) {\n            callback();\n            return;\n        }\n        // If we're doing validation, assume the worst-- a data integrity\n        // mismatch. If not, these tests won't be performed, and we can assume\n        // the best.\n        // We must check if the server decompressed the data on serve because hash\n        // validation is not possible in this case.\n        let failed = this.crc32cEnabled || this.md5Enabled;\n        if (this.crc32cEnabled && this.crc32cExpected) {\n            failed = !this.test('crc32c', this.crc32cExpected);\n        }\n        if (this.md5Enabled && this.md5Expected) {\n            failed = !this.test('md5', this.md5Expected);\n        }\n        if (failed) {\n            const mismatchError = new file_js_1.RequestError(file_js_1.FileExceptionMessages.DOWNLOAD_MISMATCH);\n            mismatchError.code = 'CONTENT_DOWNLOAD_MISMATCH';\n            callback(mismatchError);\n        }\n        else {\n            callback();\n        }\n    }\n    _transform(chunk, encoding, callback) {\n        this.push(chunk, encoding);\n        try {\n            if (__classPrivateFieldGet(this, _HashStreamValidator_crc32cHash, \"f\"))\n                __classPrivateFieldGet(this, _HashStreamValidator_crc32cHash, \"f\").update(chunk);\n            if (__classPrivateFieldGet(this, _HashStreamValidator_md5Hash, \"f\"))\n                __classPrivateFieldGet(this, _HashStreamValidator_md5Hash, \"f\").update(chunk);\n            callback();\n        }\n        catch (e) {\n            callback(e);\n        }\n    }\n    test(hash, sum) {\n        const check = Buffer.isBuffer(sum) ? sum.toString('base64') : sum;\n        if (hash === 'crc32c' && __classPrivateFieldGet(this, _HashStreamValidator_crc32cHash, \"f\")) {\n            return __classPrivateFieldGet(this, _HashStreamValidator_crc32cHash, \"f\").validate(check);\n        }\n        if (hash === 'md5' && __classPrivateFieldGet(this, _HashStreamValidator_md5Hash, \"f\")) {\n            return __classPrivateFieldGet(this, _HashStreamValidator_md5Digest, \"f\") === check;\n        }\n        return false;\n    }\n}\nexports.HashStreamValidator = HashStreamValidator;\n_HashStreamValidator_crc32cHash = new WeakMap(), _HashStreamValidator_md5Hash = new WeakMap(), _HashStreamValidator_md5Digest = new WeakMap();\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}