{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.uncompressibleCommands = exports.Compressor = void 0;\nexports.compress = compress;\nexports.decompress = decompress;\nexports.compressCommand = compressCommand;\nexports.decompressResponse = decompressResponse;\nconst util_1 = require(\"util\");\nconst zlib = require(\"zlib\");\nconst constants_1 = require(\"../../constants\");\nconst deps_1 = require(\"../../deps\");\nconst error_1 = require(\"../../error\");\nconst commands_1 = require(\"../commands\");\nconst constants_2 = require(\"./constants\");\n/** @public */\nexports.Compressor = Object.freeze({\n  none: 0,\n  snappy: 1,\n  zlib: 2,\n  zstd: 3\n});\nexports.uncompressibleCommands = new Set([constants_1.LEGACY_HELLO_COMMAND, 'saslStart', 'saslContinue', 'getnonce', 'authenticate', 'createUser', 'updateUser', 'copydbSaslStart', 'copydbgetnonce', 'copydb']);\nconst ZSTD_COMPRESSION_LEVEL = 3;\nconst zlibInflate = (0, util_1.promisify)(zlib.inflate.bind(zlib));\nconst zlibDeflate = (0, util_1.promisify)(zlib.deflate.bind(zlib));\nlet zstd;\nlet Snappy = null;\nfunction loadSnappy() {\n  if (Snappy == null) {\n    const snappyImport = (0, deps_1.getSnappy)();\n    if ('kModuleError' in snappyImport) {\n      throw snappyImport.kModuleError;\n    }\n    Snappy = snappyImport;\n  }\n  return Snappy;\n}\n// Facilitate compressing a message using an agreed compressor\nasync function compress(options, dataToBeCompressed) {\n  const zlibOptions = {};\n  switch (options.agreedCompressor) {\n    case 'snappy':\n      {\n        Snappy ??= loadSnappy();\n        return await Snappy.compress(dataToBeCompressed);\n      }\n    case 'zstd':\n      {\n        loadZstd();\n        if ('kModuleError' in zstd) {\n          throw zstd['kModuleError'];\n        }\n        return await zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);\n      }\n    case 'zlib':\n      {\n        if (options.zlibCompressionLevel) {\n          zlibOptions.level = options.zlibCompressionLevel;\n        }\n        return await zlibDeflate(dataToBeCompressed, zlibOptions);\n      }\n    default:\n      {\n        throw new error_1.MongoInvalidArgumentError(`Unknown compressor ${options.agreedCompressor} failed to compress`);\n      }\n  }\n}\n// Decompress a message using the given compressor\nasync function decompress(compressorID, compressedData) {\n  if (compressorID !== exports.Compressor.snappy && compressorID !== exports.Compressor.zstd && compressorID !== exports.Compressor.zlib && compressorID !== exports.Compressor.none) {\n    throw new error_1.MongoDecompressionError(`Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`);\n  }\n  switch (compressorID) {\n    case exports.Compressor.snappy:\n      {\n        Snappy ??= loadSnappy();\n        return await Snappy.uncompress(compressedData, {\n          asBuffer: true\n        });\n      }\n    case exports.Compressor.zstd:\n      {\n        loadZstd();\n        if ('kModuleError' in zstd) {\n          throw zstd['kModuleError'];\n        }\n        return await zstd.decompress(compressedData);\n      }\n    case exports.Compressor.zlib:\n      {\n        return await zlibInflate(compressedData);\n      }\n    default:\n      {\n        return compressedData;\n      }\n  }\n}\n/**\n * Load ZStandard if it is not already set.\n */\nfunction loadZstd() {\n  if (!zstd) {\n    zstd = (0, deps_1.getZstdLibrary)();\n  }\n}\nconst MESSAGE_HEADER_SIZE = 16;\n/**\n * @internal\n *\n * Compresses an OP_MSG or OP_QUERY message, if compression is configured.  This method\n * also serializes the command to BSON.\n */\nasync function compressCommand(command, description) {\n  const finalCommand = description.agreedCompressor === 'none' || !commands_1.OpCompressedRequest.canCompress(command) ? command : new commands_1.OpCompressedRequest(command, {\n    agreedCompressor: description.agreedCompressor ?? 'none',\n    zlibCompressionLevel: description.zlibCompressionLevel ?? 0\n  });\n  const data = await finalCommand.toBin();\n  return Buffer.concat(data);\n}\n/**\n * @internal\n *\n * Decompresses an OP_MSG or OP_QUERY response from the server, if compression is configured.\n *\n * This method does not parse the response's BSON.\n */\nasync function decompressResponse(message) {\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  if (messageHeader.opCode !== constants_2.OP_COMPRESSED) {\n    const ResponseType = messageHeader.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;\n    const messageBody = message.subarray(MESSAGE_HEADER_SIZE);\n    return new ResponseType(message, messageHeader, messageBody);\n  }\n  const header = {\n    ...messageHeader,\n    fromCompressed: true,\n    opCode: message.readInt32LE(MESSAGE_HEADER_SIZE),\n    length: message.readInt32LE(MESSAGE_HEADER_SIZE + 4)\n  };\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n  // recalculate based on wrapped opcode\n  const ResponseType = header.opCode === constants_2.OP_MSG ? commands_1.OpMsgResponse : commands_1.OpReply;\n  const messageBody = await decompress(compressorID, compressedBuffer);\n  if (messageBody.length !== header.length) {\n    throw new error_1.MongoDecompressionError('Message body and message header must be the same length');\n  }\n  return new ResponseType(message, header, messageBody);\n}","map":{"version":3,"mappings":"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","names":["exports","Object","freeze","none","snappy","zlib","zstd","Set","constants_1","ZSTD_COMPRESSION_LEVEL","zlibInflate","inflate","bind","zlibDeflate","deflate","Snappy","loadSnappy","snappyImport","kModuleError","compress","options","dataToBeCompressed","zlibOptions","agreedCompressor","loadZstd","zlibCompressionLevel","level","error_1","decompress","compressorID","compressedData","uncompress","asBuffer","MESSAGE_HEADER_SIZE","compressCommand","command","description","finalCommand","commands_1","canCompress","data","toBin","Buffer","concat","decompressResponse","message","messageHeader","length","readInt32LE","requestId","responseTo","opCode","constants_2","ResponseType","messageBody","subarray","header","fromCompressed","compressedBuffer","slice"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/cmap/wire_protocol/compression.ts"],"sourcesContent":["import { promisify } from 'util';\nimport * as zlib from 'zlib';\n\nimport { LEGACY_HELLO_COMMAND } from '../../constants';\nimport { getSnappy, getZstdLibrary, type SnappyLib, type ZStandard } from '../../deps';\nimport { MongoDecompressionError, MongoInvalidArgumentError } from '../../error';\nimport {\n  type MessageHeader,\n  OpCompressedRequest,\n  OpMsgResponse,\n  OpReply,\n  type WriteProtocolMessageType\n} from '../commands';\nimport { OP_COMPRESSED, OP_MSG } from './constants';\n\n/** @public */\nexport const Compressor = Object.freeze({\n  none: 0,\n  snappy: 1,\n  zlib: 2,\n  zstd: 3\n} as const);\n\n/** @public */\nexport type Compressor = (typeof Compressor)[CompressorName];\n\n/** @public */\nexport type CompressorName = keyof typeof Compressor;\n\nexport const uncompressibleCommands = new Set([\n  LEGACY_HELLO_COMMAND,\n  'saslStart',\n  'saslContinue',\n  'getnonce',\n  'authenticate',\n  'createUser',\n  'updateUser',\n  'copydbSaslStart',\n  'copydbgetnonce',\n  'copydb'\n]);\n\nconst ZSTD_COMPRESSION_LEVEL = 3;\n\nconst zlibInflate = promisify(zlib.inflate.bind(zlib));\nconst zlibDeflate = promisify(zlib.deflate.bind(zlib));\n\nlet zstd: ZStandard;\nlet Snappy: SnappyLib | null = null;\nfunction loadSnappy() {\n  if (Snappy == null) {\n    const snappyImport = getSnappy();\n    if ('kModuleError' in snappyImport) {\n      throw snappyImport.kModuleError;\n    }\n    Snappy = snappyImport;\n  }\n  return Snappy;\n}\n\n// Facilitate compressing a message using an agreed compressor\nexport async function compress(\n  options: { zlibCompressionLevel: number; agreedCompressor: CompressorName },\n  dataToBeCompressed: Buffer\n): Promise<Buffer> {\n  const zlibOptions = {} as zlib.ZlibOptions;\n  switch (options.agreedCompressor) {\n    case 'snappy': {\n      Snappy ??= loadSnappy();\n      return await Snappy.compress(dataToBeCompressed);\n    }\n    case 'zstd': {\n      loadZstd();\n      if ('kModuleError' in zstd) {\n        throw zstd['kModuleError'];\n      }\n      return await zstd.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL);\n    }\n    case 'zlib': {\n      if (options.zlibCompressionLevel) {\n        zlibOptions.level = options.zlibCompressionLevel;\n      }\n      return await zlibDeflate(dataToBeCompressed, zlibOptions);\n    }\n    default: {\n      throw new MongoInvalidArgumentError(\n        `Unknown compressor ${options.agreedCompressor} failed to compress`\n      );\n    }\n  }\n}\n\n// Decompress a message using the given compressor\nexport async function decompress(compressorID: number, compressedData: Buffer): Promise<Buffer> {\n  if (\n    compressorID !== Compressor.snappy &&\n    compressorID !== Compressor.zstd &&\n    compressorID !== Compressor.zlib &&\n    compressorID !== Compressor.none\n  ) {\n    throw new MongoDecompressionError(\n      `Server sent message compressed using an unsupported compressor. (Received compressor ID ${compressorID})`\n    );\n  }\n\n  switch (compressorID) {\n    case Compressor.snappy: {\n      Snappy ??= loadSnappy();\n      return await Snappy.uncompress(compressedData, { asBuffer: true });\n    }\n    case Compressor.zstd: {\n      loadZstd();\n      if ('kModuleError' in zstd) {\n        throw zstd['kModuleError'];\n      }\n      return await zstd.decompress(compressedData);\n    }\n    case Compressor.zlib: {\n      return await zlibInflate(compressedData);\n    }\n    default: {\n      return compressedData;\n    }\n  }\n}\n\n/**\n * Load ZStandard if it is not already set.\n */\nfunction loadZstd() {\n  if (!zstd) {\n    zstd = getZstdLibrary();\n  }\n}\n\nconst MESSAGE_HEADER_SIZE = 16;\n\n/**\n * @internal\n *\n * Compresses an OP_MSG or OP_QUERY message, if compression is configured.  This method\n * also serializes the command to BSON.\n */\nexport async function compressCommand(\n  command: WriteProtocolMessageType,\n  description: { agreedCompressor?: CompressorName; zlibCompressionLevel?: number }\n): Promise<Buffer> {\n  const finalCommand =\n    description.agreedCompressor === 'none' || !OpCompressedRequest.canCompress(command)\n      ? command\n      : new OpCompressedRequest(command, {\n          agreedCompressor: description.agreedCompressor ?? 'none',\n          zlibCompressionLevel: description.zlibCompressionLevel ?? 0\n        });\n  const data = await finalCommand.toBin();\n  return Buffer.concat(data);\n}\n\n/**\n * @internal\n *\n * Decompresses an OP_MSG or OP_QUERY response from the server, if compression is configured.\n *\n * This method does not parse the response's BSON.\n */\nexport async function decompressResponse(message: Buffer): Promise<OpMsgResponse | OpReply> {\n  const messageHeader: MessageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n\n  if (messageHeader.opCode !== OP_COMPRESSED) {\n    const ResponseType = messageHeader.opCode === OP_MSG ? OpMsgResponse : OpReply;\n    const messageBody = message.subarray(MESSAGE_HEADER_SIZE);\n    return new ResponseType(message, messageHeader, messageBody);\n  }\n\n  const header: MessageHeader = {\n    ...messageHeader,\n    fromCompressed: true,\n    opCode: message.readInt32LE(MESSAGE_HEADER_SIZE),\n    length: message.readInt32LE(MESSAGE_HEADER_SIZE + 4)\n  };\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n\n  // recalculate based on wrapped opcode\n  const ResponseType = header.opCode === OP_MSG ? OpMsgResponse : OpReply;\n  const messageBody = await decompress(compressorID, compressedBuffer);\n  if (messageBody.length !== header.length) {\n    throw new MongoDecompressionError('Message body and message header must be the same length');\n  }\n  return new ResponseType(message, header, messageBody);\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}