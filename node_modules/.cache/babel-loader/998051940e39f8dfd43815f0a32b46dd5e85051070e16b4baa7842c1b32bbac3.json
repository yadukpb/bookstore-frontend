{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MachineWorkflow = void 0;\nconst promises_1 = require(\"timers/promises\");\nconst utils_1 = require(\"../../../utils\");\nconst command_builders_1 = require(\"./command_builders\");\n/** The time to throttle callback calls. */\nconst THROTTLE_MS = 100;\n/**\n * Common behaviour for OIDC machine workflows.\n * @internal\n */\nclass MachineWorkflow {\n  /**\n   * Instantiate the machine workflow.\n   */\n  constructor(cache) {\n    this.cache = cache;\n    this.callback = this.withLock(this.getToken.bind(this));\n    this.lastExecutionTime = Date.now() - THROTTLE_MS;\n  }\n  /**\n   * Execute the workflow. Gets the token from the subclass implementation.\n   */\n  async execute(connection, credentials) {\n    const token = await this.getTokenFromCacheOrEnv(connection, credentials);\n    const command = (0, command_builders_1.finishCommandDocument)(token);\n    await connection.command((0, utils_1.ns)(credentials.source), command, undefined);\n  }\n  /**\n   * Reauthenticate on a machine workflow just grabs the token again since the server\n   * has said the current access token is invalid or expired.\n   */\n  async reauthenticate(connection, credentials) {\n    if (this.cache.hasAccessToken) {\n      // Reauthentication implies the token has expired.\n      if (connection.accessToken === this.cache.getAccessToken()) {\n        // If connection's access token is the same as the cache's, remove\n        // the token from the cache and connection.\n        this.cache.removeAccessToken();\n        delete connection.accessToken;\n      } else {\n        // If the connection's access token is different from the cache's, set\n        // the cache's token on the connection and do not remove from the\n        // cache.\n        connection.accessToken = this.cache.getAccessToken();\n      }\n    }\n    await this.execute(connection, credentials);\n  }\n  /**\n   * Get the document to add for speculative authentication.\n   */\n  async speculativeAuth(connection, credentials) {\n    // The spec states only cached access tokens can use speculative auth.\n    if (!this.cache.hasAccessToken) {\n      return {};\n    }\n    const token = await this.getTokenFromCacheOrEnv(connection, credentials);\n    const document = (0, command_builders_1.finishCommandDocument)(token);\n    document.db = credentials.source;\n    return {\n      speculativeAuthenticate: document\n    };\n  }\n  /**\n   * Get the token from the cache or environment.\n   */\n  async getTokenFromCacheOrEnv(connection, credentials) {\n    if (this.cache.hasAccessToken) {\n      return this.cache.getAccessToken();\n    } else {\n      const token = await this.callback(credentials);\n      this.cache.put({\n        accessToken: token.access_token,\n        expiresInSeconds: token.expires_in\n      });\n      // Put the access token on the connection as well.\n      connection.accessToken = token.access_token;\n      return token.access_token;\n    }\n  }\n  /**\n   * Ensure the callback is only executed one at a time, and throttled to\n   * only once per 100ms.\n   */\n  withLock(callback) {\n    let lock = Promise.resolve();\n    return async credentials => {\n      // We do this to ensure that we would never return the result of the\n      // previous lock, only the current callback's value would get returned.\n      await lock;\n      lock = lock.catch(() => null).then(async () => {\n        const difference = Date.now() - this.lastExecutionTime;\n        if (difference <= THROTTLE_MS) {\n          await (0, promises_1.setTimeout)(THROTTLE_MS - difference);\n        }\n        this.lastExecutionTime = Date.now();\n        return await callback(credentials);\n      });\n      return await lock;\n    };\n  }\n}\nexports.MachineWorkflow = MachineWorkflow;","map":{"version":3,"mappings":"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","names":["THROTTLE_MS","MachineWorkflow","constructor","cache","callback","withLock","getToken","bind","lastExecutionTime","Date","now","execute","connection","credentials","token","getTokenFromCacheOrEnv","command","source","undefined","reauthenticate","hasAccessToken","accessToken","getAccessToken","removeAccessToken","speculativeAuth","document","db","speculativeAuthenticate","put","access_token","expiresInSeconds","expires_in","lock","Promise","resolve","catch","then","difference","exports"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/cmap/auth/mongodb_oidc/machine_workflow.ts"],"sourcesContent":["import { setTimeout } from 'timers/promises';\n\nimport { type Document } from '../../../bson';\nimport { ns } from '../../../utils';\nimport type { Connection } from '../../connection';\nimport type { MongoCredentials } from '../mongo_credentials';\nimport type { Workflow } from '../mongodb_oidc';\nimport { finishCommandDocument } from './command_builders';\nimport { type TokenCache } from './token_cache';\n\n/** The time to throttle callback calls. */\nconst THROTTLE_MS = 100;\n\n/**\n * The access token format.\n * @internal\n */\nexport interface AccessToken {\n  access_token: string;\n  expires_in?: number;\n}\n\n/** @internal */\nexport type OIDCTokenFunction = (credentials: MongoCredentials) => Promise<AccessToken>;\n\n/**\n * Common behaviour for OIDC machine workflows.\n * @internal\n */\nexport abstract class MachineWorkflow implements Workflow {\n  cache: TokenCache;\n  callback: OIDCTokenFunction;\n  lastExecutionTime: number;\n\n  /**\n   * Instantiate the machine workflow.\n   */\n  constructor(cache: TokenCache) {\n    this.cache = cache;\n    this.callback = this.withLock(this.getToken.bind(this));\n    this.lastExecutionTime = Date.now() - THROTTLE_MS;\n  }\n\n  /**\n   * Execute the workflow. Gets the token from the subclass implementation.\n   */\n  async execute(connection: Connection, credentials: MongoCredentials): Promise<void> {\n    const token = await this.getTokenFromCacheOrEnv(connection, credentials);\n    const command = finishCommandDocument(token);\n    await connection.command(ns(credentials.source), command, undefined);\n  }\n\n  /**\n   * Reauthenticate on a machine workflow just grabs the token again since the server\n   * has said the current access token is invalid or expired.\n   */\n  async reauthenticate(connection: Connection, credentials: MongoCredentials): Promise<void> {\n    if (this.cache.hasAccessToken) {\n      // Reauthentication implies the token has expired.\n      if (connection.accessToken === this.cache.getAccessToken()) {\n        // If connection's access token is the same as the cache's, remove\n        // the token from the cache and connection.\n        this.cache.removeAccessToken();\n        delete connection.accessToken;\n      } else {\n        // If the connection's access token is different from the cache's, set\n        // the cache's token on the connection and do not remove from the\n        // cache.\n        connection.accessToken = this.cache.getAccessToken();\n      }\n    }\n    await this.execute(connection, credentials);\n  }\n\n  /**\n   * Get the document to add for speculative authentication.\n   */\n  async speculativeAuth(connection: Connection, credentials: MongoCredentials): Promise<Document> {\n    // The spec states only cached access tokens can use speculative auth.\n    if (!this.cache.hasAccessToken) {\n      return {};\n    }\n    const token = await this.getTokenFromCacheOrEnv(connection, credentials);\n    const document = finishCommandDocument(token);\n    document.db = credentials.source;\n    return { speculativeAuthenticate: document };\n  }\n\n  /**\n   * Get the token from the cache or environment.\n   */\n  private async getTokenFromCacheOrEnv(\n    connection: Connection,\n    credentials: MongoCredentials\n  ): Promise<string> {\n    if (this.cache.hasAccessToken) {\n      return this.cache.getAccessToken();\n    } else {\n      const token = await this.callback(credentials);\n      this.cache.put({ accessToken: token.access_token, expiresInSeconds: token.expires_in });\n      // Put the access token on the connection as well.\n      connection.accessToken = token.access_token;\n      return token.access_token;\n    }\n  }\n\n  /**\n   * Ensure the callback is only executed one at a time, and throttled to\n   * only once per 100ms.\n   */\n  private withLock(callback: OIDCTokenFunction): OIDCTokenFunction {\n    let lock: Promise<any> = Promise.resolve();\n    return async (credentials: MongoCredentials): Promise<AccessToken> => {\n      // We do this to ensure that we would never return the result of the\n      // previous lock, only the current callback's value would get returned.\n      await lock;\n      lock = lock\n\n        .catch(() => null)\n\n        .then(async () => {\n          const difference = Date.now() - this.lastExecutionTime;\n          if (difference <= THROTTLE_MS) {\n            await setTimeout(THROTTLE_MS - difference);\n          }\n          this.lastExecutionTime = Date.now();\n          return await callback(credentials);\n        });\n      return await lock;\n    };\n  }\n\n  /**\n   * Get the token from the environment or endpoint.\n   */\n  abstract getToken(credentials: MongoCredentials): Promise<AccessToken>;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}