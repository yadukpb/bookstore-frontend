{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KillCursorsOperation = void 0;\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst operation_1 = require(\"./operation\");\nclass KillCursorsOperation extends operation_1.AbstractOperation {\n  constructor(cursorId, ns, server, options) {\n    super(options);\n    this.ns = ns;\n    this.cursorId = cursorId;\n    this.server = server;\n  }\n  get commandName() {\n    return 'killCursors';\n  }\n  async execute(server, session) {\n    if (server !== this.server) {\n      throw new error_1.MongoRuntimeError('Killcursor must run on the same server operation began on');\n    }\n    const killCursors = this.ns.collection;\n    if (killCursors == null) {\n      // Cursors should have adopted the namespace returned by MongoDB\n      // which should always defined a collection name (even a pseudo one, ex. db.aggregate())\n      throw new error_1.MongoRuntimeError('A collection name must be determined before killCursors');\n    }\n    const killCursorsCommand = {\n      killCursors,\n      cursors: [this.cursorId]\n    };\n    try {\n      await server.command(this.ns, killCursorsCommand, {\n        session\n      });\n    } catch (error) {\n      // The driver should never emit errors from killCursors, this is spec-ed behavior\n      (0, utils_1.squashError)(error);\n    }\n  }\n}\nexports.KillCursorsOperation = KillCursorsOperation;\n(0, operation_1.defineAspects)(KillCursorsOperation, [operation_1.Aspect.MUST_SELECT_SAME_SERVER]);","map":{"version":3,"mappings":";;;;;;AACA;AAGA;AACA;AAYA,MAAaA,oBAAqB,SAAQC,6BAAiB;EAGzDC,YAAYC,QAAc,EAAEC,EAAoB,EAAEC,MAAc,EAAEC,OAAyB;IACzF,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAACF,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACD,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACE,MAAM,GAAGA,MAAM;EACtB;EAEA,IAAaE,WAAW;IACtB,OAAO,aAAsB;EAC/B;EAES,MAAMC,OAAO,CAACH,MAAc,EAAEI,OAAkC;IACvE,IAAIJ,MAAM,KAAK,IAAI,CAACA,MAAM,EAAE;MAC1B,MAAM,IAAIK,yBAAiB,CAAC,2DAA2D,CAAC;IAC1F;IAEA,MAAMC,WAAW,GAAG,IAAI,CAACP,EAAE,CAACQ,UAAU;IACtC,IAAID,WAAW,IAAI,IAAI,EAAE;MACvB;MACA;MACA,MAAM,IAAID,yBAAiB,CAAC,yDAAyD,CAAC;IACxF;IAEA,MAAMG,kBAAkB,GAAuB;MAC7CF,WAAW;MACXG,OAAO,EAAE,CAAC,IAAI,CAACX,QAAQ;KACxB;IACD,IAAI;MACF,MAAME,MAAM,CAACU,OAAO,CAAC,IAAI,CAACX,EAAE,EAAES,kBAAkB,EAAE;QAAEJ;MAAO,CAAE,CAAC;IAChE,CAAC,CAAC,OAAOO,KAAK,EAAE;MACd;MACA,uBAAW,EAACA,KAAK,CAAC;IACpB;EACF;;AApCFC;AAuCA,6BAAa,EAACjB,oBAAoB,EAAE,CAACC,kBAAM,CAACiB,uBAAuB,CAAC,CAAC","names":["KillCursorsOperation","operation_1","constructor","cursorId","ns","server","options","commandName","execute","session","error_1","killCursors","collection","killCursorsCommand","cursors","command","error","exports","MUST_SELECT_SAME_SERVER"],"sources":["/home/yadu/Music/Gifty/node_modules/mongodb/src/operations/kill_cursors.ts"],"sourcesContent":["import type { Long } from '../bson';\nimport { MongoRuntimeError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport { type MongoDBNamespace, squashError } from '../utils';\nimport { AbstractOperation, Aspect, defineAspects, type OperationOptions } from './operation';\n\n/**\n * https://www.mongodb.com/docs/manual/reference/command/killCursors/\n * @internal\n */\ninterface KillCursorsCommand {\n  killCursors: string;\n  cursors: Long[];\n  comment?: unknown;\n}\n\nexport class KillCursorsOperation extends AbstractOperation {\n  cursorId: Long;\n\n  constructor(cursorId: Long, ns: MongoDBNamespace, server: Server, options: OperationOptions) {\n    super(options);\n    this.ns = ns;\n    this.cursorId = cursorId;\n    this.server = server;\n  }\n\n  override get commandName() {\n    return 'killCursors' as const;\n  }\n\n  override async execute(server: Server, session: ClientSession | undefined): Promise<void> {\n    if (server !== this.server) {\n      throw new MongoRuntimeError('Killcursor must run on the same server operation began on');\n    }\n\n    const killCursors = this.ns.collection;\n    if (killCursors == null) {\n      // Cursors should have adopted the namespace returned by MongoDB\n      // which should always defined a collection name (even a pseudo one, ex. db.aggregate())\n      throw new MongoRuntimeError('A collection name must be determined before killCursors');\n    }\n\n    const killCursorsCommand: KillCursorsCommand = {\n      killCursors,\n      cursors: [this.cursorId]\n    };\n    try {\n      await server.command(this.ns, killCursorsCommand, { session });\n    } catch (error) {\n      // The driver should never emit errors from killCursors, this is spec-ed behavior\n      squashError(error);\n    }\n  }\n}\n\ndefineAspects(KillCursorsOperation, [Aspect.MUST_SELECT_SAME_SERVER]);\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}